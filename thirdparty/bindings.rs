/* automatically generated by rust-bindgen 0.71.1 */

#[cfg(feature = "defmt")]
use defmt::Format;

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const RPU_ADDR_GRAM_START: u32 = 3070230528;
pub const RPU_ADDR_GRAM_END: u32 = 3070296575;
pub const RPU_ADDR_SBUS_START: u32 = 2751463424;
pub const RPU_ADDR_SBUS_END: u32 = 2751496191;
pub const RPU_ADDR_PBUS_START: u32 = 2768240640;
pub const RPU_ADDR_PBUS_END: u32 = 2768502783;
pub const RPU_ADDR_BEV_START: u32 = 3217031168;
pub const RPU_ADDR_BEV_END: u32 = 3218079743;
pub const RPU_ADDR_PKTRAM_START: u32 = 2952790016;
pub const RPU_ADDR_PKTRAM_END: u32 = 2952990719;
pub const RPU_ADDR_LMAC_CORE_RET_START: u32 = 2147745792;
pub const RPU_ADDR_UMAC_CORE_RET_START: u32 = 2148007936;
pub const RPU_MCU_MAX_BOOT_VECTORS: u32 = 4;
pub const RPU_ADDR_MASK_BASE: u32 = 4278190080;
pub const RPU_ADDR_MASK_OFFSET: u32 = 16777215;
pub const RPU_ADDR_MASK_BEV_OFFSET: u32 = 1048575;
pub const RPU_REG_INT_FROM_RPU_CTRL: u32 = 2751464448;
pub const RPU_REG_BIT_INT_FROM_RPU_CTRL: u32 = 17;
pub const RPU_REG_INT_TO_MCU_CTRL: u32 = 2751464576;
pub const RPU_REG_INT_FROM_MCU_ACK: u32 = 2751464584;
pub const RPU_REG_BIT_INT_FROM_MCU_ACK: u32 = 31;
pub const RPU_REG_INT_FROM_MCU_CTRL: u32 = 2751464596;
pub const RPU_REG_BIT_INT_FROM_MCU_CTRL: u32 = 31;
pub const RPU_REG_UCC_SLEEP_CTRL_DATA_0: u32 = 2751474732;
pub const RPU_REG_UCC_SLEEP_CTRL_DATA_1: u32 = 2751474736;
pub const RPU_REG_MIPS_MCU_CONTROL: u32 = 2751463424;
pub const RPU_REG_MIPS_MCU2_CONTROL: u32 = 2751463680;
pub const RPU_REG_MIPS_MCU_UCCP_INT_STATUS: u32 = 2751463428;
pub const RPU_REG_BIT_MIPS_WATCHDOG_INT_STATUS: u32 = 1;
pub const RPU_REG_MIPS_MCU_TIMER: u32 = 2751463500;
pub const RPU_REG_MIPS_MCU_TIMER_RESET_VAL: u32 = 16777215;
pub const RPU_REG_MIPS_MCU_UCCP_INT_CLEAR: u32 = 2751463436;
pub const RPU_REG_BIT_MIPS_WATCHDOG_INT_CLEAR: u32 = 1;
pub const RPU_REG_MIPS_MCU_SYS_CORE_MEM_CTRL: u32 = 2751463472;
pub const RPU_REG_MIPS_MCU_SYS_CORE_MEM_WDATA: u32 = 2751463476;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_0: u32 = 2751463504;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_1: u32 = 2751463508;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_2: u32 = 2751463512;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_3: u32 = 2751463516;
pub const RPU_REG_MIPS_MCU2_SYS_CORE_MEM_CTRL: u32 = 2751463728;
pub const RPU_REG_MIPS_MCU2_SYS_CORE_MEM_WDATA: u32 = 2751463732;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_0: u32 = 2751463760;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_1: u32 = 2751463764;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_2: u32 = 2751463768;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_3: u32 = 2751463772;
pub const RPU_REG_BIT_PS_CTRL: u32 = 0;
pub const RPU_REG_BIT_PS_STATE: u32 = 1;
pub const RPU_REG_BIT_READY_STATE: u32 = 2;
pub const RPU_MEM_RX_CMD_BASE: u32 = 3070233944;
pub const RPU_MEM_HPQ_INFO: u32 = 2952790052;
pub const RPU_MEM_TX_CMD_BASE: u32 = 2952790200;
pub const RPU_MEM_OTP_FT_PROG_VERSION: u32 = 2952810456;
pub const RPU_MEM_OTP_INFO_FLAGS: u32 = 2952810460;
pub const RPU_MEM_OTP_PACKAGE_TYPE: u32 = 2952810452;
pub const RPU_MEM_PKT_BASE: u32 = 2952810496;
pub const RPU_CMD_START_MAGIC: u32 = 57005;
pub const RPU_DATA_CMD_SIZE_MAX_RX: u32 = 8;
pub const RPU_DATA_CMD_SIZE_MAX_TX: u32 = 148;
pub const RPU_EVENT_COMMON_SIZE_MAX: u32 = 128;
pub const MAX_EVENT_POOL_LEN: u32 = 1000;
pub const MAX_NUM_OF_RX_QUEUES: u32 = 3;
pub const RPU_PKTRAM_SIZE: u32 = 180224;
pub const RPU_MEM_RF_TEST_CAP_BASE: u32 = 2952814592;
pub const REGION_PROTECT: u32 = 64;
pub const PRODTEST_FT_PROGVERSION: u32 = 29;
pub const PRODTEST_TRIM0: u32 = 32;
pub const PRODTEST_TRIM1: u32 = 33;
pub const PRODTEST_TRIM2: u32 = 34;
pub const PRODTEST_TRIM3: u32 = 35;
pub const PRODTEST_TRIM4: u32 = 36;
pub const PRODTEST_TRIM5: u32 = 37;
pub const PRODTEST_TRIM6: u32 = 38;
pub const PRODTEST_TRIM7: u32 = 39;
pub const PRODTEST_TRIM8: u32 = 40;
pub const PRODTEST_TRIM9: u32 = 41;
pub const PRODTEST_TRIM10: u32 = 42;
pub const PRODTEST_TRIM11: u32 = 43;
pub const PRODTEST_TRIM12: u32 = 44;
pub const PRODTEST_TRIM13: u32 = 45;
pub const PRODTEST_TRIM14: u32 = 46;
pub const INFO_PART: u32 = 48;
pub const INFO_VARIANT: u32 = 49;
pub const INFO_UUID: u32 = 52;
pub const QSPI_KEY: u32 = 68;
pub const MAC0_ADDR: u32 = 72;
pub const MAC1_ADDR: u32 = 74;
pub const CALIB_XO: u32 = 76;
pub const REGION_DEFAULTS: u32 = 85;
pub const PRODRETEST_PROGVERSION: u32 = 86;
pub const PRODRETEST_TRIM0: u32 = 87;
pub const PRODRETEST_TRIM1: u32 = 88;
pub const PRODRETEST_TRIM2: u32 = 89;
pub const PRODRETEST_TRIM3: u32 = 90;
pub const PRODRETEST_TRIM4: u32 = 91;
pub const PRODRETEST_TRIM5: u32 = 92;
pub const PRODRETEST_TRIM6: u32 = 93;
pub const PRODRETEST_TRIM7: u32 = 94;
pub const PRODRETEST_TRIM8: u32 = 95;
pub const PRODRETEST_TRIM9: u32 = 96;
pub const PRODRETEST_TRIM10: u32 = 97;
pub const PRODRETEST_TRIM11: u32 = 98;
pub const PRODRETEST_TRIM12: u32 = 99;
pub const PRODRETEST_TRIM13: u32 = 100;
pub const PRODRETEST_TRIM14: u32 = 101;
pub const OTP_MAX_WORD_LEN: u32 = 128;
pub const QSPI_KEY_LENGTH_BYTES: u32 = 16;
pub const RETRIM_LEN: u32 = 15;
pub const OTP_SZ_CALIB_XO: u32 = 1;
pub const OTP_OFF_CALIB_XO: u32 = 0;
pub const QSPI_KEY_FLAG_MASK: i32 = -2;
pub const MAC0_ADDR_FLAG_MASK: i32 = -3;
pub const MAC1_ADDR_FLAG_MASK: i32 = -5;
pub const CALIB_XO_FLAG_MASK: i32 = -9;
pub const OTP_VOLTCTRL_ADDR: u32 = 102404;
pub const OTP_VOLTCTRL_2V5: u32 = 59;
pub const OTP_VOLTCTRL_1V8: u32 = 11;
pub const OTP_POLL_ADDR: u32 = 112644;
pub const OTP_WR_DONE: u32 = 1;
pub const OTP_READ_VALID: u32 = 2;
pub const OTP_READY: u32 = 4;
pub const OTP_RWSBMODE_ADDR: u32 = 112640;
pub const OTP_READ_MODE: u32 = 1;
pub const OTP_BYTE_WRITE_MODE: u32 = 66;
pub const OTP_RDENABLE_ADDR: u32 = 112656;
pub const OTP_READREG_ADDR: u32 = 112660;
pub const OTP_WRENABLE_ADDR: u32 = 112648;
pub const OTP_WRITEREG_ADDR: u32 = 112652;
pub const OTP_TIMING_REG1_ADDR: u32 = 112672;
pub const OTP_TIMING_REG1_VAL: u32 = 0;
pub const OTP_TIMING_REG2_ADDR: u32 = 112676;
pub const OTP_TIMING_REG2_VAL: u32 = 200075;
pub const OTP_FRESH_FROM_FAB: u32 = 4294967295;
pub const OTP_PROGRAMMED: u32 = 0;
pub const OTP_ENABLE_PATTERN: u32 = 1358582010;
pub const OTP_INVALID: u32 = 3735928559;
pub const FT_PROG_VER_MASK: u32 = 983040;
pub const RPU_MEM_UMAC_BOOT_SIG: u32 = 2952790016;
pub const RPU_MEM_UMAC_VER: u32 = 2952790020;
pub const RPU_MEM_UMAC_PEND_Q_BMP: u32 = 2952810428;
pub const RPU_MEM_UMAC_CMD_ADDRESS: u32 = 2952791976;
pub const RPU_MEM_UMAC_EVENT_ADDRESS: u32 = 2952793640;
pub const RPU_MEM_UMAC_PATCH_BIN: u32 = 2148057088;
pub const RPU_MEM_UMAC_PATCH_BIMG: u32 = 2148111360;
pub const NRF_WIFI_UMAC_BOOT_SIG: u32 = 1515870810;
pub const NRF_WIFI_UMAC_ROM_PATCH_OFFSET: u32 = 103424;
pub const NRF_WIFI_UMAC_BOOT_EXCP_VECT_0: u32 = 1008369664;
pub const NRF_WIFI_UMAC_BOOT_EXCP_VECT_1: u32 = 660209664;
pub const NRF_WIFI_UMAC_BOOT_EXCP_VECT_2: u32 = 54525960;
pub const NRF_WIFI_UMAC_BOOT_EXCP_VECT_3: u32 = 0;
pub const NRF_WIFI_PENDING_FRAMES_BITMAP_AC_VO: u32 = 1;
pub const NRF_WIFI_PENDING_FRAMES_BITMAP_AC_VI: u32 = 2;
pub const NRF_WIFI_PENDING_FRAMES_BITMAP_AC_BE: u32 = 4;
pub const NRF_WIFI_PENDING_FRAMES_BITMAP_AC_BK: u32 = 8;
pub const NRF_WIFI_RF_PARAMS_SIZE: u32 = 200;
pub const NRF_WIFI_RF_PARAMS_CONF_SIZE: u32 = 42;
pub const NUM_PCB_LOSS_OFFSET: u32 = 4;
pub const NRF_WIFI_PHY_CALIB_FLAG_RXDC: u32 = 1;
pub const NRF_WIFI_PHY_CALIB_FLAG_TXDC: u32 = 2;
pub const NRF_WIFI_PHY_CALIB_FLAG_TXPOW: u32 = 0;
pub const NRF_WIFI_PHY_CALIB_FLAG_TXIQ: u32 = 8;
pub const NRF_WIFI_PHY_CALIB_FLAG_RXIQ: u32 = 16;
pub const NRF_WIFI_PHY_CALIB_FLAG_DPD: u32 = 32;
pub const NRF_WIFI_PHY_CALIB_FLAG_ENHANCED_TXDC: u32 = 64;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_RXDC: u32 = 65536;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_TXDC: u32 = 131072;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_TXPOW: u32 = 0;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_TXIQ: u32 = 0;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_RXIQ: u32 = 0;
pub const NRF_WIFI_PHY_SCAN_CALIB_FLAG_DPD: u32 = 0;
pub const NRF_WIFI_DEF_PHY_CALIB: u32 = 196731;
pub const NRF_WIFI_DEF_PHY_TEMP_CALIB: u32 = 123;
pub const NRF_WIFI_TEMP_CALIB_PERIOD: u32 = 1048576;
pub const NRF_WIFI_TEMP_CALIB_THRESHOLD: u32 = 40;
pub const NRF_WIFI_TEMP_CALIB_ENABLE: u32 = 1;
pub const NRF_WIFI_DEF_PHY_VBAT_CALIB: u32 = 32;
pub const NRF_WIFI_VBAT_VERYLOW: u32 = 8;
pub const NRF_WIFI_VBAT_LOW: u32 = 12;
pub const NRF_WIFI_VBAT_HIGH: u32 = 14;
pub const QFN_PACKAGE_INFO: u32 = 20806;
pub const CSP_PACKAGE_INFO: u32 = 17221;
pub const PD_ADJUST_VAL: u32 = 0;
pub const CTRL_PWR_OPTIMIZATIONS: u32 = 0;
pub const RX_GAIN_OFFSET_HB_LOW_CHAN: u32 = 0;
pub const RX_GAIN_OFFSET_HB_MID_CHAN: u32 = 0;
pub const RX_GAIN_OFFSET_HB_HIGH_CHAN: u32 = 0;
pub const QFN_XO_VAL: u32 = 42;
pub const QFN_DSSS_BKF: u32 = 3;
pub const QFN_OFDM_BKF: u32 = 3;
pub const QFN_SYSTEM_OFFSET_LB: u32 = 51;
pub const QFN_SYSTEM_OFFSET_HB_CHAN_LOW: u32 = 3;
pub const QFN_SYSTEM_OFFSET_HB_CHAN_MID: u32 = 3;
pub const QFN_SYSTEM_OFFSET_HB_CHAN_HIGH: u32 = 3;
pub const QFN_MAX_TX_PWR_DSSS: u32 = 84;
pub const QFN_MAX_TX_PWR_LB_MCS7: u32 = 64;
pub const QFN_MAX_TX_PWR_LB_MCS0: u32 = 64;
pub const QFN_MAX_TX_PWR_HB_LOW_CHAN_MCS7: u32 = 52;
pub const QFN_MAX_TX_PWR_HB_MID_CHAN_MCS7: u32 = 52;
pub const QFN_MAX_TX_PWR_HB_HIGH_CHAN_MCS7: u32 = 48;
pub const QFN_MAX_TX_PWR_HB_LOW_CHAN_MCS0: u32 = 56;
pub const QFN_MAX_TX_PWR_HB_MID_CHAN_MCS0: u32 = 52;
pub const QFN_MAX_TX_PWR_HB_HIGH_CHAN_MCS0: u32 = 48;
pub const QFN_MAX_CHIP_TEMP: u32 = 67;
pub const QFN_MIN_CHIP_TEMP: u32 = 7;
pub const QFN_LB_MAX_PWR_BKF_HI_TEMP: u32 = 252;
pub const QFN_LB_MAX_PWR_BKF_LOW_TEMP: u32 = 0;
pub const QFN_HB_MAX_PWR_BKF_HI_TEMP: u32 = 248;
pub const QFN_HB_MAX_PWR_BKF_LOW_TEMP: u32 = 252;
pub const QFN_LB_VBT_LT_VLOW: u32 = 252;
pub const QFN_HB_VBT_LT_VLOW: u32 = 248;
pub const QFN_LB_VBT_LT_LOW: u32 = 0;
pub const QFN_HB_VBT_LT_LOW: u32 = 252;
pub const CSP_XO_VAL: u32 = 42;
pub const CSP_DSSS_BKF: u32 = 4;
pub const CSP_OFDM_BKF: u32 = 5;
pub const CSP_SYSTEM_OFFSET_LB: u32 = 69;
pub const CSP_SYSTEM_OFFSET_HB_CHAN_LOW: u32 = 5;
pub const CSP_SYSTEM_OFFSET_HB_CHAN_MID: u32 = 5;
pub const CSP_SYSTEM_OFFSET_HB_CHAN_HIGH: u32 = 5;
pub const CSP_MAX_TX_PWR_DSSS: u32 = 68;
pub const CSP_MAX_TX_PWR_LB_MCS7: u32 = 60;
pub const CSP_MAX_TX_PWR_LB_MCS0: u32 = 60;
pub const CSP_MAX_TX_PWR_HB_LOW_CHAN_MCS7: u32 = 52;
pub const CSP_MAX_TX_PWR_HB_MID_CHAN_MCS7: u32 = 52;
pub const CSP_MAX_TX_PWR_HB_HIGH_CHAN_MCS7: u32 = 52;
pub const CSP_MAX_TX_PWR_HB_LOW_CHAN_MCS0: u32 = 52;
pub const CSP_MAX_TX_PWR_HB_MID_CHAN_MCS0: u32 = 52;
pub const CSP_MAX_TX_PWR_HB_HIGH_CHAN_MCS0: u32 = 52;
pub const CSP_MAX_CHIP_TEMP: u32 = 67;
pub const CSP_MIN_CHIP_TEMP: u32 = 7;
pub const CSP_LB_MAX_PWR_BKF_HI_TEMP: u32 = 236;
pub const CSP_LB_MAX_PWR_BKF_LOW_TEMP: u32 = 0;
pub const CSP_HB_MAX_PWR_BKF_HI_TEMP: u32 = 252;
pub const CSP_HB_MAX_PWR_BKF_LOW_TEMP: u32 = 244;
pub const CSP_LB_VBT_LT_VLOW: u32 = 252;
pub const CSP_HB_VBT_LT_VLOW: u32 = 236;
pub const CSP_LB_VBT_LT_LOW: u32 = 0;
pub const CSP_HB_VBT_LT_LOW: u32 = 248;
pub const FT_PROG_VER1_2G_DSSS_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER1_2G_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER1_5G_LOW_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER1_5G_MID_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER1_5G_HIGH_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_2G_DSSS_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_2G_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_5G_LOW_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_5G_MID_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER2_5G_HIGH_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_2G_DSSS_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_2G_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_5G_LOW_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_5G_MID_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const FT_PROG_VER3_5G_HIGH_OFDM_TXCEIL_BKOFF: u32 = 0;
pub const RPU_MEM_LMAC_BOOT_SIG: u32 = 3070233936;
pub const RPU_MEM_LMAC_VER: u32 = 3070233940;
pub const RPU_MEM_LMAC_PATCH_BIN: u32 = 2147760768;
pub const RPU_MEM_LMAC_PATCH_BIMG: u32 = 2147793920;
pub const NRF_WIFI_LMAC_BOOT_SIG: u32 = 1515870810;
pub const NRF_WIFI_LMAC_ROM_PATCH_OFFSET: u32 = 48128;
pub const NRF_WIFI_LMAC_BOOT_EXCP_VECT_0: u32 = 1008369664;
pub const NRF_WIFI_LMAC_BOOT_EXCP_VECT_1: u32 = 660209664;
pub const NRF_WIFI_LMAC_BOOT_EXCP_VECT_2: u32 = 54525960;
pub const NRF_WIFI_LMAC_BOOT_EXCP_VECT_3: u32 = 0;
pub const NRF_WIFI_LMAC_MAX_RX_BUFS: u32 = 256;
pub const HW_SLEEP_ENABLE: u32 = 2;
pub const SW_SLEEP_ENABLE: u32 = 1;
pub const SLEEP_DISABLE: u32 = 0;
pub const HW_DELAY: u32 = 7300;
pub const SW_DELAY: u32 = 5000;
pub const BCN_TIMEOUT: u32 = 20000;
pub const CALIB_SLEEP_CLOCK_ENABLE: u32 = 1;
pub const ACTIVE_SCAN_DURATION: u32 = 50;
pub const PASSIVE_SCAN_DURATION: u32 = 130;
pub const WORKING_CH_SCAN_DURATION: u32 = 50;
pub const CHNL_PROBE_CNT: u32 = 2;
pub const PKT_TYPE_MPDU: u32 = 0;
pub const PKT_TYPE_MSDU_WITH_MAC: u32 = 1;
pub const PKT_TYPE_MSDU: u32 = 2;
pub const NRF_WIFI_RPU_PWR_STATUS_SUCCESS: u32 = 0;
pub const NRF_WIFI_RPU_PWR_STATUS_FAIL: i32 = -1;
pub const MAX_RSSI_SAMPLES: u32 = 10;
pub const FREQ_2_4_GHZ: u32 = 1;
pub const FREQ_5_GHZ: u32 = 2;
pub const NUM_32_QUEUES: u32 = 4;
pub const USE_PROTECTION_NONE: u32 = 0;
pub const USE_PROTECTION_RTS: u32 = 1;
pub const USE_PROTECTION_CTS2SELF: u32 = 2;
pub const USE_SHORT_PREAMBLE: u32 = 0;
pub const DONT_USE_SHORT_PREAMBLE: u32 = 1;
pub const MARK_RATE_AS_MCS_INDEX: u32 = 128;
pub const MARK_RATE_AS_RATE: u32 = 0;
pub const ENABLE_GREEN_FIELD: u32 = 1;
pub const ENABLE_CHNL_WIDTH_40MHZ: u32 = 2;
pub const ENABLE_SGI: u32 = 4;
pub const ENABLE_11N_FORMAT: u32 = 8;
pub const ENABLE_VHT_FORMAT: u32 = 16;
pub const ENABLE_CHNL_WIDTH_80MHZ: u32 = 32;
pub const MAX_TX_AGG_SIZE: u32 = 16;
pub const MAX_RX_BUFS_PER_EVNT: u32 = 64;
pub const MAX_MGMT_BUFS: u32 = 16;
pub const MAX_RF_CALIB_DATA: u32 = 900;
pub const NRF_WIFI_ETH_ADDR_LEN: u32 = 6;
pub const PHY_THRESHOLD_NORMAL: i32 = -65;
pub const PHY_THRESHOLD_PROD_MODE: i32 = -93;
pub const MAX_TX_STREAMS: u32 = 1;
pub const MAX_RX_STREAMS: u32 = 1;
pub const MAX_NUM_VIFS: u32 = 2;
pub const MAX_NUM_STAS: u32 = 2;
pub const MAX_NUM_APS: u32 = 1;
pub const NRF_WIFI_COUNTRY_CODE_LEN: u32 = 2;
pub const NRF_WIFI_FEATURE_DISABLE: u32 = 0;
pub const NRF_WIFI_FEATURE_ENABLE: u32 = 1;
pub const TWT_EXTEND_SP_EDCA: u32 = 1;
pub const DISABLE_DFS_CHANNELS: u32 = 2;
pub const NRF_WIFI_HE_GI_800NS: u32 = 0;
pub const NRF_WIFI_HE_GI_1600NS: u32 = 1;
pub const NRF_WIFI_HE_GI_3200NS: u32 = 2;
pub const NRF_WIFI_HE_LTF_3200NS: u32 = 0;
pub const NRF_WIFI_HE_LTF_6400NS: u32 = 1;
pub const NRF_WIFI_HE_LTF_12800NS: u32 = 2;
pub const NRF_WIFI_DISABLE: u32 = 0;
pub const NRF_WIFI_ENABLE: u32 = 1;
pub const NRF_WIFI_ENABLE_HE_SU: u32 = 64;
pub const NRF_WIFI_ENABLE_HE_ER_SU: u32 = 128;
pub const TX_BUF_HEADROOM: u32 = 52;
pub const NRF_WIFI_TX_FLAGS_DSCP_TOS_MASK: u32 = 65535;
pub const NRF_WIFI_TX_FLAGS_DSCP_TOS_SHIFT: u32 = 0;
pub const NRF_WIFI_TX_STATUS_SUCCESS: u32 = 0;
pub const NRF_WIFI_TX_STATUS_FAILED: u32 = 1;
pub const NRF_WIFI_CLIENT_ACTIVE: u32 = 0;
pub const NRF_WIFI_CLIENT_PS_MODE: u32 = 1;
pub const MAX_NRF_WIFI_UMAC_CMD_SIZE: u32 = 400;
pub const IEEE80211_STYPE_DISASSOC: u32 = 160;
pub const IEEE80211_STYPE_DEAUTH: u32 = 192;
pub const NRF_WIFI_MAX_SSID_LEN: u32 = 32;
pub const NRF_WIFI_MAX_IE_LEN: u32 = 400;
pub const NRF_WIFI_MAX_SEQ_LENGTH: u32 = 256;
pub const NRF_WIFI_MAX_KEY_LENGTH: u32 = 256;
pub const NRF_WIFI_MAX_SAE_DATA_LENGTH: u32 = 256;
pub const NRF_WIFI_MAX_FRAME_LEN: u32 = 400;
pub const NRF_WIFI_INDEX_IDS_WDEV_ID_VALID: u32 = 1;
pub const NRF_WIFI_INDEX_IDS_IFINDEX_VALID: u32 = 2;
pub const NRF_WIFI_INDEX_IDS_WIPHY_IDX_VALID: u32 = 4;
pub const NRF_WIFI_SUPP_RATES_BAND_VALID: u32 = 1;
pub const NRF_WIFI_MAX_SUPP_RATES: u32 = 60;
pub const NRF_WIFI_SCAN_MAX_NUM_SSIDS: u32 = 2;
pub const NRF_WIFI_SCAN_MAX_NUM_FREQUENCIES: u32 = 64;
pub const NRF_WIFI_SCAN_BAND_2GHZ: u32 = 1;
pub const NRF_WIFI_SCAN_BAND_5GHZ: u32 = 2;
pub const NRF_WIFI_SCAN_BAND_6GHZ: u32 = 4;
pub const NRF_WIFI_HT_CAPABILITY_VALID: u32 = 1;
pub const NRF_WIFI_HT_CAPABILITY_MASK_VALID: u32 = 2;
pub const NRF_WIFI_VHT_CAPABILITY_VALID: u32 = 4;
pub const NRF_WIFI_VHT_CAPABILITY_MASK_VALID: u32 = 8;
pub const NRF_WIFI_CMD_HT_VHT_CAPABILITY_DISABLE_HT: u32 = 1;
pub const NRF_WIFI_HT_VHT_CAPABILITY_MAX_SIZE: u32 = 256;
pub const NRF_WIFI_SIGNAL_TYPE_NONE: u32 = 1;
pub const NRF_WIFI_SIGNAL_TYPE_MBM: u32 = 2;
pub const NRF_WIFI_SIGNAL_TYPE_UNSPEC: u32 = 3;
pub const NRF_WIFI_WPA_VERSION_1: u32 = 1;
pub const NRF_WIFI_WPA_VERSION_2: u32 = 2;
pub const NRF_WIFI_CONNECT_COMMON_INFO_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CONNECT_COMMON_INFO_MAC_ADDR_HINT_VALID: u32 = 2;
pub const NRF_WIFI_CONNECT_COMMON_INFO_FREQ_VALID: u32 = 4;
pub const NRF_WIFI_CONNECT_COMMON_INFO_FREQ_HINT_VALID: u32 = 8;
pub const NRF_WIFI_CONNECT_COMMON_INFO_BG_SCAN_PERIOD_VALID: u32 = 16;
pub const NRF_WIFI_CONNECT_COMMON_INFO_SSID_VALID: u32 = 32;
pub const NRF_WIFI_CONNECT_COMMON_INFO_WPA_IE_VALID: u32 = 64;
pub const NRF_WIFI_CONNECT_COMMON_INFO_WPA_VERSIONS_VALID: u32 = 128;
pub const NRF_WIFI_CONNECT_COMMON_INFO_CIPHER_SUITES_PAIRWISE_VALID: u32 = 256;
pub const NRF_WIFI_CONNECT_COMMON_INFO_CIPHER_SUITE_GROUP_VALID: u32 = 512;
pub const NRF_WIFI_CONNECT_COMMON_INFO_AKM_SUITES_VALID: u32 = 1024;
pub const NRF_WIFI_CONNECT_COMMON_INFO_USE_MFP_VALID: u32 = 2048;
pub const NRF_WIFI_CONNECT_COMMON_INFO_CONTROL_PORT_ETHER_TYPE: u32 = 4096;
pub const NRF_WIFI_CONNECT_COMMON_INFO_CONTROL_PORT_NO_ENCRYPT: u32 = 8192;
pub const NRF_WIFI_MAX_NR_AKM_SUITES: u32 = 2;
pub const NRF_WIFI_CMD_CONNECT_COMMON_INFO_USE_RRM: u32 = 16384;
pub const NRF_WIFI_CONNECT_COMMON_INFO_PREV_BSSID: u32 = 32768;
pub const NRF_WIFI_CONNECT_COMMON_INFO_SECURITY: u32 = 65536;
pub const NRF_WIFI_BEACON_DATA_MAX_HEAD_LEN: u32 = 256;
pub const NRF_WIFI_BEACON_DATA_MAX_TAIL_LEN: u32 = 512;
pub const NRF_WIFI_BEACON_DATA_MAX_PROBE_RESP_LEN: u32 = 400;
pub const NRF_WIFI_STA_FLAG_INVALID: u32 = 1;
pub const NRF_WIFI_STA_FLAG_AUTHORIZED: u32 = 2;
pub const NRF_WIFI_STA_FLAG_SHORT_PREAMBLE: u32 = 4;
pub const NRF_WIFI_STA_FLAG_WME: u32 = 8;
pub const NRF_WIFI_STA_FLAG_MFP: u32 = 16;
pub const NRF_WIFI_STA_FLAG_AUTHENTICATED: u32 = 32;
pub const NRF_WIFI_STA_FLAG_TDLS_PEER: u32 = 64;
pub const NRF_WIFI_STA_FLAG_ASSOCIATED: u32 = 128;
pub const NRF_WIFI_RATE_INFO_BITRATE_VALID: u32 = 1;
pub const NRF_WIFI_RATE_INFO_BITRATE_COMPAT_VALID: u32 = 2;
pub const NRF_WIFI_RATE_INFO_BITRATE_MCS_VALID: u32 = 4;
pub const NRF_WIFI_RATE_INFO_BITRATE_VHT_MCS_VALID: u32 = 8;
pub const NRF_WIFI_RATE_INFO_BITRATE_VHT_NSS_VALID: u32 = 16;
pub const NRF_WIFI_RATE_INFO_0_MHZ_WIDTH: u32 = 1;
pub const NRF_WIFI_RATE_INFO_5_MHZ_WIDTH: u32 = 2;
pub const NRF_WIFI_RATE_INFO_10_MHZ_WIDTH: u32 = 4;
pub const NRF_WIFI_RATE_INFO_40_MHZ_WIDTH: u32 = 8;
pub const NRF_WIFI_RATE_INFO_80_MHZ_WIDTH: u32 = 16;
pub const NRF_WIFI_RATE_INFO_160_MHZ_WIDTH: u32 = 32;
pub const NRF_WIFI_RATE_INFO_SHORT_GI: u32 = 64;
pub const NRF_WIFI_RATE_INFO_80P80_MHZ_WIDTH: u32 = 128;
pub const NRF_WIFI_BSS_PARAM_FLAGS_CTS_PROT: u32 = 1;
pub const NRF_WIFI_BSS_PARAM_FLAGS_SHORT_PREAMBLE: u32 = 2;
pub const NRF_WIFI_BSS_PARAM_FLAGS_SHORT_SLOT_TIME: u32 = 4;
pub const NRF_WIFI_STA_INFO_CONNECTED_TIME_VALID: u32 = 1;
pub const NRF_WIFI_STA_INFO_INACTIVE_TIME_VALID: u32 = 2;
pub const NRF_WIFI_STA_INFO_RX_BYTES_VALID: u32 = 4;
pub const NRF_WIFI_STA_INFO_TX_BYTES_VALID: u32 = 8;
pub const NRF_WIFI_STA_INFO_CHAIN_SIGNAL_VALID: u32 = 16;
pub const NRF_WIFI_STA_INFO_CHAIN_SIGNAL_AVG_VALID: u32 = 32;
pub const NRF_WIFI_STA_INFO_TX_BITRATE_VALID: u32 = 64;
pub const NRF_WIFI_STA_INFO_RX_BITRATE_VALID: u32 = 128;
pub const NRF_WIFI_STA_INFO_STA_FLAGS_VALID: u32 = 256;
pub const NRF_WIFI_STA_INFO_LLID_VALID: u32 = 512;
pub const NRF_WIFI_STA_INFO_PLID_VALID: u32 = 1024;
pub const NRF_WIFI_STA_INFO_PLINK_STATE_VALID: u32 = 2048;
pub const NRF_WIFI_STA_INFO_SIGNAL_VALID: u32 = 4096;
pub const NRF_WIFI_STA_INFO_SIGNAL_AVG_VALID: u32 = 8192;
pub const NRF_WIFI_STA_INFO_RX_PACKETS_VALID: u32 = 16384;
pub const NRF_WIFI_STA_INFO_TX_PACKETS_VALID: u32 = 32768;
pub const NRF_WIFI_STA_INFO_TX_RETRIES_VALID: u32 = 65536;
pub const NRF_WIFI_STA_INFO_TX_FAILED_VALID: u32 = 131072;
pub const NRF_WIFI_STA_INFO_EXPECTED_THROUGHPUT_VALID: u32 = 262144;
pub const NRF_WIFI_STA_INFO_BEACON_LOSS_COUNT_VALID: u32 = 524288;
pub const NRF_WIFI_STA_INFO_LOCAL_PM_VALID: u32 = 1048576;
pub const NRF_WIFI_STA_INFO_PEER_PM_VALID: u32 = 2097152;
pub const NRF_WIFI_STA_INFO_NONPEER_PM_VALID: u32 = 4194304;
pub const NRF_WIFI_STA_INFO_T_OFFSET_VALID: u32 = 8388608;
pub const NRF_WIFI_STA_INFO_RX_DROPPED_MISC_VALID: u32 = 16777216;
pub const NRF_WIFI_STA_INFO_RX_BEACON_VALID: u32 = 33554432;
pub const NRF_WIFI_STA_INFO_RX_BEACON_SIGNAL_AVG_VALID: u32 = 67108864;
pub const NRF_WIFI_STA_INFO_STA_BSS_PARAMS_VALID: u32 = 134217728;
pub const NRF_WIFI_IEEE80211_MAX_CHAINS: u32 = 4;
pub const NRF_WIFI_KEY_VALID: u32 = 1;
pub const NRF_WIFI_KEY_TYPE_VALID: u32 = 2;
pub const NRF_WIFI_KEY_IDX_VALID: u32 = 4;
pub const NRF_WIFI_SEQ_VALID: u32 = 8;
pub const NRF_WIFI_CIPHER_SUITE_VALID: u32 = 16;
pub const NRF_WIFI_KEY_INFO_VALID: u32 = 32;
pub const NRF_WIFI_KEY_DEFAULT: u32 = 1;
pub const NRF_WIFI_KEY_DEFAULT_TYPES: u32 = 2;
pub const NRF_WIFI_KEY_DEFAULT_MGMT: u32 = 4;
pub const NRF_WIFI_KEY_DEFAULT_TYPE_UNICAST: u32 = 8;
pub const NRF_WIFI_KEY_DEFAULT_TYPE_MULTICAST: u32 = 16;
pub const MCAST_ADDR_ADD: u32 = 0;
pub const MCAST_ADDR_DEL: u32 = 1;
pub const NRF_WIFI_CMD_AUTHENTICATE_KEY_INFO_VALID: u32 = 1;
pub const NRF_WIFI_CMD_AUTHENTICATE_BSSID_VALID: u32 = 2;
pub const NRF_WIFI_CMD_AUTHENTICATE_FREQ_VALID: u32 = 4;
pub const NRF_WIFI_CMD_AUTHENTICATE_SSID_VALID: u32 = 8;
pub const NRF_WIFI_CMD_AUTHENTICATE_IE_VALID: u32 = 16;
pub const NRF_WIFI_CMD_AUTHENTICATE_SAE_VALID: u32 = 32;
pub const NRF_WIFI_CMD_AUTHENTICATE_LOCAL_STATE_CHANGE: u32 = 1;
pub const NRF_WIFI_CMD_ASSOCIATE_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_MLME_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_MLME_LOCAL_STATE_CHANGE: u32 = 1;
pub const NRF_WIFI_CMD_NEW_INTERFACE_USE_4ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_NEW_INTERFACE_MAC_ADDR_VALID: u32 = 2;
pub const NRF_WIFI_CMD_NEW_INTERFACE_IFTYPE_VALID: u32 = 4;
pub const NRF_WIFI_CMD_NEW_INTERFACE_IFNAME_VALID: u32 = 8;
pub const NRF_WIFI_FRAME_MATCH_MAX_LEN: u32 = 8;
pub const NRF_WIFI_CMD_KEY_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_BSS_CTS_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_BSS_PREAMBLE_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_BSS_SLOT_VALID: u32 = 4;
pub const NRF_WIFI_CMD_SET_BSS_HT_OPMODE_VALID: u32 = 8;
pub const NRF_WIFI_CMD_SET_BSS_AP_ISOLATE_VALID: u32 = 16;
pub const NRF_WIFI_CMD_SET_BSS_P2P_CTWINDOW_VALID: u32 = 32;
pub const NRF_WIFI_CMD_SET_BSS_P2P_OPPPS_VALID: u32 = 64;
pub const NRF_WIFI_BASIC_MAX_SUPP_RATES: u32 = 32;
pub const NRF_WIFI_SET_FREQ_PARAMS_FREQ_VALID: u32 = 1;
pub const NRF_WIFI_SET_FREQ_PARAMS_CHANNEL_WIDTH_VALID: u32 = 2;
pub const NRF_WIFI_SET_FREQ_PARAMS_CENTER_FREQ1_VALID: u32 = 4;
pub const NRF_WIFI_SET_FREQ_PARAMS_CENTER_FREQ2_VALID: u32 = 8;
pub const NRF_WIFI_SET_FREQ_PARAMS_CHANNEL_TYPE_VALID: u32 = 16;
pub const NRF_WIFI_TX_POWER_SETTING_TYPE_VALID: u32 = 1;
pub const NRF_WIFI_TX_POWER_SETTING_TX_POWER_LEVEL_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_WIPHY_FREQ_PARAMS_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_WIPHY_TXQ_PARAMS_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_WIPHY_RTS_THRESHOLD_VALID: u32 = 4;
pub const NRF_WIFI_CMD_SET_WIPHY_FRAG_THRESHOLD_VALID: u32 = 8;
pub const NRF_WIFI_CMD_SET_WIPHY_TX_POWER_SETTING_VALID: u32 = 16;
pub const NRF_WIFI_CMD_SET_WIPHY_ANTENNA_TX_VALID: u32 = 32;
pub const NRF_WIFI_CMD_SET_WIPHY_ANTENNA_RX_VALID: u32 = 64;
pub const NRF_WIFI_CMD_SET_WIPHY_RETRY_SHORT_VALID: u32 = 128;
pub const NRF_WIFI_CMD_SET_WIPHY_RETRY_LONG_VALID: u32 = 256;
pub const NRF_WIFI_CMD_SET_WIPHY_COVERAGE_CLASS_VALID: u32 = 512;
pub const NRF_WIFI_CMD_SET_WIPHY_WIPHY_NAME_VALID: u32 = 1024;
pub const NRF_WIFI_CMD_DEL_STATION_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_CMD_DEL_STATION_MGMT_SUBTYPE_VALID: u32 = 2;
pub const NRF_WIFI_CMD_DEL_STATION_REASON_CODE_VALID: u32 = 4;
pub const NRF_WIFI_EXT_CAPABILITY_MAX_LEN: u32 = 32;
pub const NRF_WIFI_SUPPORTED_CHANNELS_MAX_LEN: u32 = 64;
pub const NRF_WIFI_OPER_CLASSES_MAX_LEN: u32 = 64;
pub const NRF_WIFI_STA_FLAGS2_MAX_LEN: u32 = 64;
pub const NRF_WIFI_CMD_SET_STATION_SUPP_RATES_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_STATION_AID_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_STATION_PEER_AID_VALID: u32 = 4;
pub const NRF_WIFI_CMD_SET_STATION_STA_CAPABILITY_VALID: u32 = 8;
pub const NRF_WIFI_CMD_SET_STATION_EXT_CAPABILITY_VALID: u32 = 16;
pub const NRF_WIFI_CMD_SET_STATION_STA_VLAN_VALID: u32 = 32;
pub const NRF_WIFI_CMD_SET_STATION_HT_CAPABILITY_VALID: u32 = 64;
pub const NRF_WIFI_CMD_SET_STATION_VHT_CAPABILITY_VALID: u32 = 128;
pub const NRF_WIFI_CMD_SET_STATION_OPMODE_NOTIF_VALID: u32 = 512;
pub const NRF_WIFI_CMD_SET_STATION_SUPPORTED_CHANNELS_VALID: u32 = 1024;
pub const NRF_WIFI_CMD_SET_STATION_SUPPORTED_OPER_CLASSES_VALID: u32 = 2048;
pub const NRF_WIFI_CMD_SET_STATION_STA_FLAGS2_VALID: u32 = 4096;
pub const NRF_WIFI_CMD_SET_STATION_STA_WME_UAPSD_QUEUES_VALID: u32 = 8192;
pub const NRF_WIFI_CMD_SET_STATION_STA_WME_MAX_SP_VALID: u32 = 16384;
pub const NRF_WIFI_CMD_SET_STATION_LISTEN_INTERVAL_VALID: u32 = 32768;
pub const NRF_WIFI_CMD_NEW_STATION_SUPP_RATES_VALID: u32 = 1;
pub const NRF_WIFI_CMD_NEW_STATION_AID_VALID: u32 = 2;
pub const NRF_WIFI_CMD_NEW_STATION_PEER_AID_VALID: u32 = 4;
pub const NRF_WIFI_CMD_NEW_STATION_STA_CAPABILITY_VALID: u32 = 8;
pub const NRF_WIFI_CMD_NEW_STATION_EXT_CAPABILITY_VALID: u32 = 16;
pub const NRF_WIFI_CMD_NEW_STATION_STA_VLAN_VALID: u32 = 32;
pub const NRF_WIFI_CMD_NEW_STATION_HT_CAPABILITY_VALID: u32 = 64;
pub const NRF_WIFI_CMD_NEW_STATION_VHT_CAPABILITY_VALID: u32 = 128;
pub const NRF_WIFI_CMD_NEW_STATION_OPMODE_NOTIF_VALID: u32 = 512;
pub const NRF_WIFI_CMD_NEW_STATION_SUPPORTED_CHANNELS_VALID: u32 = 1024;
pub const NRF_WIFI_CMD_NEW_STATION_SUPPORTED_OPER_CLASSES_VALID: u32 = 2048;
pub const NRF_WIFI_CMD_NEW_STATION_STA_FLAGS2_VALID: u32 = 4096;
pub const NRF_WIFI_CMD_NEW_STATION_STA_WME_UAPSD_QUEUES_VALID: u32 = 8192;
pub const NRF_WIFI_CMD_NEW_STATION_STA_WME_MAX_SP_VALID: u32 = 16384;
pub const NRF_WIFI_CMD_NEW_STATION_LISTEN_INTERVAL_VALID: u32 = 32768;
pub const NRF_WIFI_CMD_BEACON_INFO_BEACON_INTERVAL_VALID: u32 = 1;
pub const NRF_WIFI_CMD_BEACON_INFO_AUTH_TYPE_VALID: u32 = 2;
pub const NRF_WIFI_CMD_BEACON_INFO_VERSIONS_VALID: u32 = 4;
pub const NRF_WIFI_CMD_BEACON_INFO_CIPHER_SUITE_GROUP_VALID: u32 = 8;
pub const NRF_WIFI_CMD_BEACON_INFO_INACTIVITY_TIMEOUT_VALID: u32 = 16;
pub const NRF_WIFI_CMD_BEACON_INFO_FREQ_PARAMS_VALID: u32 = 32;
pub const NRF_WIFI_CMD_BEACON_INFO_PRIVACY: u32 = 1;
pub const NRF_WIFI_CMD_BEACON_INFO_CONTROL_PORT_NO_ENCRYPT: u32 = 2;
pub const NRF_WIFI_CMD_BEACON_INFO_P2P_CTWINDOW_VALID: u32 = 64;
pub const NRF_WIFI_CMD_BEACON_INFO_P2P_OPPPS_VALID: u32 = 128;
pub const NRF_WIFI_SET_INTERFACE_IFTYPE_VALID: u32 = 1;
pub const NRF_WIFI_SET_INTERFACE_USE_4ADDR_VALID: u32 = 2;
pub const IFACENAMSIZ: u32 = 16;
pub const NRF_WIFI_CMD_FRAME_FREQ_VALID: u32 = 1;
pub const NRF_WIFI_CMD_FRAME_DURATION_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_FRAME_FREQ_PARAMS_VALID: u32 = 4;
pub const NRF_WIFI_CMD_FRAME_OFFCHANNEL_TX_OK: u32 = 1;
pub const NRF_WIFI_CMD_FRAME_TX_NO_CCK_RATE: u32 = 2;
pub const NRF_WIFI_CMD_FRAME_DONT_WAIT_FOR_ACK: u32 = 4;
pub const NRF_WIFI_TWT_NEGOTIATION_TYPE_INDIVIDUAL: u32 = 0;
pub const NRF_WIFI_TWT_NEGOTIATION_TYPE_BROADCAST: u32 = 2;
pub const NRF_WIFI_TWT_FLOW_TYPE_ANNOUNCED: u32 = 0;
pub const NRF_WIFI_TWT_FLOW_TYPE_UNANNOUNCED: u32 = 1;
pub const NRF_WIFI_TWT_RESP_RECEIVED: u32 = 0;
pub const NRF_WIFI_TWT_RESP_NOT_RECEIVED: u32 = 1;
pub const NRF_WIFI_INVALID_TWT_WAKE_INTERVAL: u32 = 3;
pub const INVALID_TIME: u32 = 1;
pub const TRIGGER_NOT_RECEIVED: u32 = 2;
pub const TWT_BLOCK_TX: u32 = 0;
pub const TWT_UNBLOCK_TX: u32 = 1;
pub const UAPSD_Q_MIN: u32 = 0;
pub const UAPSD_Q_MAX: u32 = 15;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_MAC_ADDR_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_IES_TSF_VALID: u32 = 2;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_IES_VALID: u32 = 4;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_BEACON_IES_TSF_VALID: u32 = 8;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_BEACON_IES_VALID: u32 = 16;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_BEACON_INTERVAL_VALID: u32 = 32;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_SIGNAL_VALID: u32 = 64;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_STATUS_VALID: u32 = 128;
pub const NRF_WIFI_EVENT_NEW_SCAN_RESULTS_BSS_PRESP_DATA: u32 = 256;
pub const NRF_WIFI_NEW_SCAN_RESULTS_BSS_PRESP_DATA: u32 = 1;
pub const NRF_WIFI_802_11A: u32 = 1;
pub const NRF_WIFI_802_11B: u32 = 2;
pub const NRF_WIFI_802_11G: u32 = 4;
pub const NRF_WIFI_802_11N: u32 = 8;
pub const NRF_WIFI_802_11AC: u32 = 16;
pub const NRF_WIFI_802_11AX: u32 = 32;
pub const NRF_WIFI_MFP_REQUIRED: u32 = 1;
pub const NRF_WIFI_MFP_CAPABLE: u32 = 2;
pub const DISPLAY_BSS_TOHOST_PEREVNT: u32 = 8;
pub const NRF_WIFI_EVENT_MLME_FRAME_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_MLME_MAC_ADDR_VALID: u32 = 2;
pub const NRF_WIFI_EVENT_MLME_FREQ_VALID: u32 = 4;
pub const NRF_WIFI_EVENT_MLME_COOKIE_VALID: u32 = 8;
pub const NRF_WIFI_EVENT_MLME_RX_SIGNAL_DBM_VALID: u32 = 16;
pub const NRF_WIFI_EVENT_MLME_WME_UAPSD_QUEUES_VALID: u32 = 32;
pub const NRF_WIFI_EVENT_MLME_RXMGMT_FLAGS_VALID: u32 = 64;
pub const NRF_WIFI_EVENT_MLME_IE_VALID: u32 = 128;
pub const NRF_WIFI_EVENT_MLME_RXDEAUTH_FROM_AP: u32 = 256;
pub const NRF_WIFI_EVENT_MLME_TIMED_OUT: u32 = 1;
pub const NRF_WIFI_EVENT_MLME_ACK: u32 = 2;
pub const NRF_WIFI_CMD_SEND_STATION_ASSOC_REQ_IES_VALID: u32 = 1;
pub const NRF_WIFI_CMD_COOKIE_RSP_COOKIE_VALID: u32 = 1;
pub const NRF_WIFI_CMD_COOKIE_RSP_MAC_ADDR_VALID: u32 = 2;
pub const NRF_WIFI_MAX_TWT_FLOWS: u32 = 8;
pub const NRF_WIFI_PS_MODE_LEGACY: u32 = 0;
pub const NRF_WIFI_PS_MODE_WMM: u32 = 1;
pub const NRF_WIFI_LISTEN_INTERVAL_MIN: u32 = 3;
pub const NRF_WIFI_EVENT_TRIGGER_SCAN_IE_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_TRIGGER_SCAN_SCAN_FLAGS_VALID: u32 = 2;
pub const NRF_WIFI_CMD_ROC_FREQ_PARAMS_VALID: u32 = 1;
pub const NRF_WIFI_CMD_ROC_DURATION_VALID: u32 = 2;
pub const NRF_WIFI_CMD_CANCEL_ROC_COOKIE_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_ROC_FREQ_VALID: u32 = 1;
pub const NRF_WIFI_EVENT_ROC_COOKIE_VALID: u32 = 2;
pub const NRF_WIFI_EVENT_ROC_DURATION_VALID: u32 = 4;
pub const NRF_WIFI_EVENT_ROC_CH_TYPE_VALID: u32 = 8;
pub const NRF_WIFI_INTERFACE_INFO_CHAN_DEF_VALID: u32 = 1;
pub const NRF_WIFI_INTERFACE_INFO_SSID_VALID: u32 = 2;
pub const NRF_WIFI_INTERFACE_INFO_IFNAME_VALID: u32 = 4;
pub const NRF_WIFI_HT_MCS_MASK_LEN: u32 = 10;
pub const NRF_WIFI_HT_MCS_RES_LEN: u32 = 3;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_IR: u32 = 1;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_IBSS: u32 = 2;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_RADAR: u32 = 4;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_HT40_MINUS: u32 = 8;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_HT40_PLUS: u32 = 16;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_80MHZ: u32 = 32;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_160MHZ: u32 = 64;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_INDOOR_ONLY: u32 = 128;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_GO_CONCURRENT: u32 = 256;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_20MHZ: u32 = 512;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_10MHZ: u32 = 1024;
pub const NRF_WIFI_CHAN_FLAG_FREQUENCY_DISABLED: u32 = 2048;
pub const NRF_WIFI_CHAN_DFS_VALID: u32 = 4096;
pub const NRF_WIFI_CHAN_DFS_CAC_TIME_VALID: u32 = 8192;
pub const NRF_WIFI_EVENT_GET_WIPHY_FLAG_RATE_SHORT_PREAMBLE: u32 = 1;
pub const NRF_WIFI_EVENT_GET_WIPHY_VALID_RADAR_DETECT_WIDTHS: u32 = 1;
pub const NRF_WIFI_EVENT_GET_WIPHY_VALID_RADAR_DETECT_REGIONS: u32 = 2;
pub const NRF_WIFI_EVENT_GET_WIPHY_VALID_: u32 = 4;
pub const NRF_WIFI_EVENT_GET_WIPHY_IBSS_RSN: u32 = 1;
pub const NRF_WIFI_EVENT_GET_WIPHY_MESH_AUTH: u32 = 2;
pub const NRF_WIFI_EVENT_GET_WIPHY_AP_UAPSD: u32 = 4;
pub const NRF_WIFI_EVENT_GET_WIPHY_SUPPORTS_FW_ROAM: u32 = 8;
pub const NRF_WIFI_EVENT_GET_WIPHY_SUPPORTS_TDLS: u32 = 16;
pub const NRF_WIFI_EVENT_GET_WIPHY_TDLS_EXTERNAL_SETUP: u32 = 32;
pub const NRF_WIFI_EVENT_GET_WIPHY_CONTROL_PORT_ETHERTYPE: u32 = 64;
pub const NRF_WIFI_EVENT_GET_WIPHY_OFFCHANNEL_TX_OK: u32 = 128;
pub const NRF_WIFI_GET_WIPHY_VALID_PROBE_RESP_OFFLOAD: u32 = 1;
pub const NRF_WIFI_GET_WIPHY_VALID_TX_ANT: u32 = 2;
pub const NRF_WIFI_GET_WIPHY_VALID_RX_ANT: u32 = 4;
pub const NRF_WIFI_GET_WIPHY_VALID_MAX_NUM_SCAN_SSIDS: u32 = 8;
pub const NRF_WIFI_GET_WIPHY_VALID_NUM_SCHED_SCAN_SSIDS: u32 = 16;
pub const NRF_WIFI_GET_WIPHY_VALID_MAX_MATCH_SETS: u32 = 32;
pub const NRF_WIFI_GET_WIPHY_VALID_MAC_ACL_MAX: u32 = 64;
pub const NRF_WIFI_GET_WIPHY_VALID_HAVE_AP_SME: u32 = 128;
pub const NRF_WIFI_GET_WIPHY_VALID_EXTENDED_CAPABILITIES: u32 = 256;
pub const NRF_WIFI_GET_WIPHY_VALID_MAX_AP_ASSOC_STA: u32 = 512;
pub const NRF_WIFI_GET_WIPHY_VALID_WIPHY_NAME: u32 = 1024;
pub const NRF_WIFI_GET_WIPHY_VALID_EXTENDED_FEATURES: u32 = 2048;
pub const NRF_WIFI_EVENT_GET_WIPHY_MAX_CIPHER_COUNT: u32 = 30;
pub const NRF_WIFI_INDEX_IDS_WIPHY_NAME: u32 = 32;
pub const NRF_WIFI_EVENT_GET_WIPHY_NUM_BANDS: u32 = 2;
pub const EXTENDED_FEATURE_LEN: u32 = 60;
pub const REG_RULE_FLAGS_VALID: u32 = 1;
pub const FREQ_RANGE_START_VALID: u32 = 2;
pub const FREQ_RANGE_END_VALID: u32 = 4;
pub const FREQ_RANGE_MAX_BW_VALID: u32 = 8;
pub const POWER_RULE_MAX_EIRP_VALID: u32 = 16;
pub const NRF_WIFI_RULE_FLAGS_NO_OFDM: u32 = 1;
pub const NRF_WIFI_RULE_FLAGS_NO_CCK: u32 = 2;
pub const NRF_WIFI_RULE_FLAGS_NO_INDOOR: u32 = 4;
pub const NRF_WIFI_RULE_FLAGS_NO_OUTDOOR: u32 = 8;
pub const NRF_WIFI_RULE_FLAGS_DFS: u32 = 16;
pub const NRF_WIFI_RULE_FLAGS_PTP_ONLY: u32 = 32;
pub const NRF_WIFI_RULE_FLAGS_PTMP_ONLY: u32 = 64;
pub const NRF_WIFI_RULE_FLAGS_NO_IR: u32 = 128;
pub const NRF_WIFI_RULE_FLAGS_IBSS: u32 = 256;
pub const NRF_WIFI_RULE_FLAGS_AUTO_BW: u32 = 2048;
pub const NRF_WIFI_RULE_FLAGS_IR_CONCURRENT: u32 = 4096;
pub const NRF_WIFI_RULE_FLAGS_NO_HT40MINUS: u32 = 8192;
pub const NRF_WIFI_RULE_FLAGS_NO_HT40PLUS: u32 = 16384;
pub const NRF_WIFI_RULE_FLAGS_NO_80MHZ: u32 = 32768;
pub const NRF_WIFI_RULE_FLAGS_NO_160MHZ: u32 = 65536;
pub const NRF_WIFI_CMD_SET_REG_ALPHA2_VALID: u32 = 1;
pub const NRF_WIFI_CMD_SET_REG_RULES_VALID: u32 = 2;
pub const NRF_WIFI_CMD_SET_REG_DFS_REGION_VALID: u32 = 4;
pub const MAX_NUM_REG_RULES: u32 = 32;
pub const NRF_WIFI_CMD_REQ_SET_REG_ALPHA2_VALID: u32 = 1;
pub const NRF_WIFI_CMD_REQ_SET_REG_USER_REG_HINT_TYPE_VALID: u32 = 2;
pub const NRF_WIFI_CMD_REQ_SET_REG_USER_REG_FORCE: u32 = 4;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const NRF_WIFI_LOG_LEVEL_ERR: u32 = 1;
pub const NRF_WIFI_LOG_LEVEL_INF: u32 = 3;
pub const NRF_WIFI_LOG_LEVEL_DBG: u32 = 4;
pub const MAX_HAL_RPU_READY_WAIT: u32 = 1000000;
pub const NRF_WIFI_SYS_DEF_RF_PARAMS : & [u8 ; 227] = b"007077003F032424001000002800323500000CF008087D8105010071630300EED501001F6F00003B350100F52E0000E35E0000B7B6000066EFFEFFB5F60000896200007A840200E28FFCFF080808080408120100000000A1A10178000000080050003B020726181818181A120A140E0600\0" ;
pub const NRF_WIFI_FW_CHUNK_ID_STR_LEN: u32 = 16;
pub const MAX_NUM_REG_CHANELS: u32 = 42;
pub const MAX_PEERS: u32 = 5;
pub const MAX_SW_PEERS: u32 = 6;
pub const NRF_WIFI_AC_TWT_PRIORITY_EMERGENCY: u32 = 255;
pub const NRF_WIFI_MAGIC_NUM_RAWTX: u32 = 305419896;
pub const RX_BUF_HEADROOM: u32 = 4;
pub const NRF_WIFI_PATCH_SIGNATURE: u32 = 3735887535;
pub const NRF_WIFI_PATCH_HASH_LEN: u32 = 32;
pub const NRF_WIFI_PATCH_NUM_IMAGES: u32 = 4;
pub const RPU_FAMILY: u32 = 1;
pub const RPU_MAJOR_VERSION: u32 = 2;
pub const RPU_MINOR_VERSION: u32 = 14;
pub const RPU_PATCH_VERSION: u32 = 0;
pub const NRF_WIFI_ADDR_REG_NAME_LEN: u32 = 16;
pub const SOC_BOOT_SUCCESS: u32 = 0;
pub const SOC_BOOT_FAIL: u32 = 1;
pub const SOC_BOOT_ERRORS: u32 = 2;
pub const DEFAULT_IMGPCI_VENDOR_ID: u32 = 1792;
pub const PCIE_BAR_OFFSET_WLAN_RPU: u32 = 0;
pub const PCIE_DMA_MASK: u32 = 4294967295;
pub const SOC_MMAP_ADDR_OFFSET_PKTRAM_HOST_VIEW: u32 = 786432;
pub const SOC_MMAP_ADDR_OFFSET_PKTRAM_RPU_VIEW: u32 = 3670016;
pub const SOC_MMAP_ADDR_OFFSET_GRAM_PKD: u32 = 524288;
pub const SOC_MMAP_ADDR_OFFSET_SYSBUS: u32 = 0;
pub const SOC_MMAP_ADDR_OFFSET_PBUS: u32 = 262144;
pub const RPU_MCU_CORE_INDIRECT_BASE: u32 = 3221225472;
pub const NRF_WIFI_FW_LMAC_PATCH_LOC_PRI: &[u8; 38] = b"img/wlan/nrf_wifi_lmac_patch_pri.bimg\0";
pub const NRF_WIFI_FW_LMAC_PATCH_LOC_SEC: &[u8; 37] = b"img/wlan/nrf_wifi_lmac_patch_sec.bin\0";
pub const NRF_WIFI_FW_UMAC_PATCH_LOC_PRI: &[u8; 38] = b"img/wlan/nrf_wifi_umac_patch_pri.bimg\0";
pub const NRF_WIFI_FW_UMAC_PATCH_LOC_SEC: &[u8; 37] = b"img/wlan/nrf_wifi_umac_patch_sec.bin\0";
#[repr(u32)]
#[doc = " @brief Regions in the MCU local memory.\n\n The MCU local memory in the nRF70 is divided into three regions:\n - ROM : Read-only memory region.\n - RETENTION : Retention memory region.\n - SCRATCH : Scratch memory region."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RPU_MCU_ADDR_REGIONS {
    RPU_MCU_ADDR_REGION_ROM = 0,
    RPU_MCU_ADDR_REGION_RETENTION = 1,
    RPU_MCU_ADDR_REGION_SCRATCH = 2,
    RPU_MCU_ADDR_REGION_MAX = 3,
}
#[doc = " @brief Address limits of each MCU local memory region.\n\n A MCU local memory region is defined by its:\n - Start address, and\n - End address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_addr_region {
    pub start: ::core::ffi::c_uint,
    pub end: ::core::ffi::c_uint,
}
#[doc = " @brief Address map of the MCU memory.\n\n The MCU memory map consists of three regions:\n - ROM : Read-only memory region.\n - RETENTION : Retention memory region.\n - SCRATCH : Scratch memory region."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_addr_map {
    pub regions: [rpu_addr_region; 3usize],
}
unsafe extern "C" {
    #[doc = " @brief Memory map of the MCUs in the RPU.\n\n The RPU consists of two MCUs:\n - MCU: For the LMAC.\n - MCU2 : For the UMAC.\n\n Each MCU memory consists of three regions:\n - ROM : Read-only memory region.\n - RETENTION : Retention memory region.\n - SCRATCH : Scratch memory region."]
    pub static RPU_ADDR_MAP_MCU: [rpu_addr_map; 2usize];
}
#[doc = " @brief Boot vector definition for a MCU in nRF70.\n\n The boot vectors for the MCUs in the nRF70 are defined by their:\n - Address, and\n - Value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_mcu_boot_vector {
    pub addr: ::core::ffi::c_uint,
    pub val: ::core::ffi::c_uint,
}
#[doc = " @brief Boot vectors for the MCUs in nRF70.\n\n The boot vectors for the MCUs in nRF70."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_mcu_boot_vectors {
    pub vectors: [rpu_mcu_boot_vector; 4usize],
}
#[doc = " @brief RX buffer related information to be passed to nRF70.\n\n This structure encapsulates the information to be passed to nRF70 for\n buffers which the nRf70 will use to pass the received frames."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_rx_buf_info {
    #[doc = " Address in the host memory where the RX buffer is located."]
    pub addr: ::core::ffi::c_uint,
}
#[doc = " @brief Hostport Queue (HPQ) information.\n\n This structure encapsulates the information which represents a HPQ."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_hpq {
    #[doc = " HPQ address where the host can post the address of a message intended for the RPU."]
    pub enqueue_addr: ::core::ffi::c_uint,
    #[doc = " HPQ address where the host can get the address of a message intended for the host."]
    pub dequeue_addr: ::core::ffi::c_uint,
}
#[doc = " @brief Information about Hostport Queues (HPQ) to be used\n\tfor exchanging information between the Host and RPU.\n\n Hostport queue information passed by the RPU to the host, which the host can\n use, to communicate with the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_hpqm_info {
    #[doc = " Queue which the RPU uses to inform the host about events."]
    pub event_busy_queue: host_rpu_hpq,
    #[doc = " Queue on which the consumed events are pushed so that RPU can reuse them."]
    pub event_avl_queue: host_rpu_hpq,
    #[doc = " Queue used by the host to push commands to the RPU."]
    pub cmd_busy_queue: host_rpu_hpq,
    #[doc = " Queue which RPU uses to inform host about command buffers which can be used to\n push commands to the RPU."]
    pub cmd_avl_queue: host_rpu_hpq,
    #[doc = " Queue used by the host to push RX buffers to the RPU."]
    pub rx_buf_busy_queue: [host_rpu_hpq; 3usize],
}
#[doc = " @brief Common header included in each command/event.\n This structure encapsulates the common information included at the start of\n each command/event exchanged with the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_msg_hdr {
    #[doc = " Length of the message."]
    pub len: ::core::ffi::c_uint,
    #[doc = " Flag to indicate whether the recipient is expected to resubmit the\n cmd/event address back to the trasmitting entity."]
    pub resubmit: ::core::ffi::c_uint,
}
#[repr(u32)]
#[doc = " @brief This enum defines the different categories of messages that can be exchanged between\n  the Host and the RPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_host_rpu_msg_type {
    #[doc = " System interface messages"]
    NRF_WIFI_HOST_RPU_MSG_TYPE_SYSTEM = 0,
    #[doc = " Unused"]
    NRF_WIFI_HOST_RPU_MSG_TYPE_SUPPLICANT = 1,
    #[doc = " Data path messages"]
    NRF_WIFI_HOST_RPU_MSG_TYPE_DATA = 2,
    #[doc = " Control path messages"]
    NRF_WIFI_HOST_RPU_MSG_TYPE_UMAC = 3,
}
#[doc = " @brief This structure defines the common message header used to encapsulate each message\n  exchanged between the Host and UMAC.\n"]
#[repr(C, packed)]
pub struct host_rpu_msg {
    #[doc = " Header"]
    pub hdr: host_rpu_msg_hdr,
    #[doc = " Type of the RPU message see &enum nrf_wifi_host_rpu_msg_type"]
    pub type_: ::core::ffi::c_int,
    #[doc = " Actual message"]
    pub msg: __IncompleteArrayField<::core::ffi::c_schar>,
}
#[doc = " @brief This new structure represents the bitmap of STA (Station) pending frames in\n  SoftAP power save mode.\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sap_client_pend_frames_bitmap {
    #[doc = " STA MAC address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Reserved: 2 byte for alignment"]
    pub reserved: [::core::ffi::c_uchar; 2usize],
    #[doc = " Pending frames bitmap for each access category"]
    pub pend_frames_bitmap: ::core::ffi::c_uchar,
    #[doc = " Reserved: 3 Bytes for alignment"]
    pub reserved1: [::core::ffi::c_uchar; 3usize],
}
#[doc = " @brief This structure represents the bitmap of STA (Station) pending frames in\n  SoftAP power save mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sap_pend_frames_bitmap {
    #[doc = " STA MAC address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Pending frames bitmap for each access category"]
    pub pend_frames_bitmap: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure represents the information related to UMAC.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_umac_info {
    #[doc = " Boot status signature"]
    pub boot_status: ::core::ffi::c_uint,
    #[doc = " UMAC version"]
    pub version: ::core::ffi::c_uint,
    #[doc = " @ref sap_pend_frames_bitmap"]
    pub sap_bitmap: [sap_pend_frames_bitmap; 4usize],
    #[doc = " Hardware queues info &enum host_rpu_hpqm_info"]
    pub hpqm_info: host_rpu_hpqm_info,
    #[doc = " OTP params"]
    pub info_part: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_variant: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_lromversion: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_uromversion: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_uuid: [::core::ffi::c_uint; 4usize],
    #[doc = " OTP params"]
    pub info_spare0: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub info_spare1: ::core::ffi::c_uint,
    #[doc = " OTP params"]
    pub mac_address0: [::core::ffi::c_uint; 2usize],
    #[doc = " OTP params"]
    pub mac_address1: [::core::ffi::c_uint; 2usize],
    #[doc = " OTP params"]
    pub calib: [::core::ffi::c_uint; 9usize],
}
#[doc = " XO adjustment value"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_xo_freq_offset {
    pub xo_freq_offset: ::core::ffi::c_uchar,
}
#[doc = " Power detector adjustment factor for MCS7"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_pd_adst_val {
    #[doc = " PD adjustment value corresponding to Channel 7"]
    pub pd_adjt_lb_chan: ::core::ffi::c_schar,
    #[doc = " PD adjustment value corresponding to Channel 36"]
    pub pd_adjt_hb_low_chan: ::core::ffi::c_schar,
    #[doc = " PD adjustment value corresponding to Channel 100"]
    pub pd_adjt_hb_mid_chan: ::core::ffi::c_schar,
    #[doc = " PD adjustment value corresponding to Channel 165"]
    pub pd_adjt_hb_high_chan: ::core::ffi::c_schar,
}
#[doc = " TX power systematic offset is the difference between set power\n  and the measured power"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_pwr_systm_offset {
    #[doc = " Systematic adjustment value corresponding to Channel 7"]
    pub syst_off_lb_chan: ::core::ffi::c_schar,
    #[doc = " Systematic adjustment value corresponding to Channel 36"]
    pub syst_off_hb_low_chan: ::core::ffi::c_schar,
    #[doc = " Systematic adjustment value corresponding to Channel 100"]
    pub syst_off_hb_mid_chan: ::core::ffi::c_schar,
    #[doc = " Systematic adjustment value corresponding to Channel 165"]
    pub syst_off_hb_high_chan: ::core::ffi::c_schar,
}
#[doc = " Max TX power value for which both EVM and SEM pass"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_pwr_ceil {
    #[doc = " Max output power for 11b for channel 7"]
    pub max_dsss_pwr: ::core::ffi::c_schar,
    #[doc = " Max output power for MCS7 for channel 7"]
    pub max_lb_mcs7_pwr: ::core::ffi::c_schar,
    #[doc = " Max output power for MCS0 for channel 7"]
    pub max_lb_mcs0_pwr: ::core::ffi::c_schar,
    #[doc = " Max output power for MCS7 for channel 36"]
    pub max_hb_low_chan_mcs7_pwr: ::core::ffi::c_schar,
    #[doc = " Max output power for MCS7 for channel 100"]
    pub max_hb_mid_chan_mcs7_pwr: ::core::ffi::c_schar,
    #[doc = " Max output power for MCS7 for channel 165"]
    pub max_hb_high_chan_mcs7_pwr: ::core::ffi::c_schar,
    #[doc = " Max output power for MCS0 for channel 36"]
    pub max_hb_low_chan_mcs0_pwr: ::core::ffi::c_schar,
    #[doc = " Max output power for MCS0 for channel 100"]
    pub max_hb_mid_chan_mcs0_pwr: ::core::ffi::c_schar,
    #[doc = " Max output power for MCS0 for channel 165"]
    pub max_hb_high_chan_mcs0_pwr: ::core::ffi::c_schar,
}
#[doc = " RX gain adjustment offsets"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_rx_gain_offset {
    #[doc = " Channel 7"]
    pub rx_gain_lb_chan: ::core::ffi::c_schar,
    #[doc = " Channel 36"]
    pub rx_gain_hb_low_chan: ::core::ffi::c_schar,
    #[doc = " Channel 100"]
    pub rx_gain_hb_mid_chan: ::core::ffi::c_schar,
    #[doc = " Channel 165"]
    pub rx_gain_hb_high_chan: ::core::ffi::c_schar,
}
#[doc = " Voltage and temperature dependent backoffs"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_temp_volt_depend_params {
    #[doc = " Maximum chip temperature in centigrade"]
    pub max_chip_temp: ::core::ffi::c_schar,
    #[doc = " Minimum chip temperature in centigrade"]
    pub min_chip_temp: ::core::ffi::c_schar,
    #[doc = " TX power backoff at high temperature in 2.4GHz"]
    pub lb_max_pwr_bkf_hi_temp: ::core::ffi::c_schar,
    #[doc = " TX power backoff at low temperature in 2.4GHz"]
    pub lb_max_pwr_bkf_low_temp: ::core::ffi::c_schar,
    #[doc = " TX power backoff at high temperature in 5GHz"]
    pub hb_max_pwr_bkf_hi_temp: ::core::ffi::c_schar,
    #[doc = " TX power backoff at low temperature in 5GHz"]
    pub hb_max_pwr_bkf_low_temp: ::core::ffi::c_schar,
    #[doc = " Voltage back off value in LowBand when VBAT< VBAT_VERYLOW"]
    pub lb_vbt_lt_vlow: ::core::ffi::c_schar,
    #[doc = " Voltage back off value in HighBand when VBAT< VBAT_VERYLOW"]
    pub hb_vbt_lt_vlow: ::core::ffi::c_schar,
    #[doc = " Voltage back off value in LowBand when VBAT< VBAT_LOW"]
    pub lb_vbt_lt_low: ::core::ffi::c_schar,
    #[doc = " Voltage back off value in HighBand when VBAT< VBAT_LOW"]
    pub hb_vbt_lt_low: ::core::ffi::c_schar,
    #[doc = " Reserved bytes"]
    pub reserved: [::core::ffi::c_schar; 4usize],
}
#[doc = " The top-level structure holds substructures,\n each containing information related to the\n first 42 bytes of RF parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_phy_rf_params {
    pub reserved: [::core::ffi::c_uchar; 6usize],
    pub xo_offset: nrf_wifi_xo_freq_offset,
    pub pd_adjust_val: nrf_wifi_pd_adst_val,
    pub syst_tx_pwr_offset: nrf_wifi_tx_pwr_systm_offset,
    pub max_pwr_ceil: nrf_wifi_tx_pwr_ceil,
    pub rx_gain_offset: nrf_wifi_rx_gain_offset,
    pub temp_volt_backoff: nrf_wifi_temp_volt_depend_params,
    pub phy_params: [::core::ffi::c_uchar; 158usize],
}
#[repr(u32)]
#[doc = " The byte offsets of RF parameters indicate the start offset\n of various RF parameters, such as XO, power detector adjust\n parameters, power ceiling parameters, RX gain adjustment parameters,\n and temperature and voltage-based power backoff values."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RF_PARAMS_OFFSETS {
    NRF_WIFI_XO_FREQ_BYTE_OFFSET = 6,
    NRF_WIFI_PD_ADST_VAL_BYTE_OFFSET = 7,
    NRF_WIFI_TX_PWR_SYSTM_BYTE_OFFSET = 11,
    NRF_WIFI_TX_PWR_CEIL_BYTE_OFFSET = 15,
    NRF_WIFI_RX_GAIN_BYTE_OFFSET = 24,
    NRF_WIFI_VT_DEPEND_PARAMS_BYTE_OFFSET = 28,
}
#[repr(u32)]
#[doc = " RF Params from byte starting with offset\n NRF_WIFI_TX_PWR_CEIL_BYTE_OFFSET contains the\n TX power celings based on DSSS, OFDM , Frequency\n band and MCS.\n In 5GHz band we have three subbands based on\n channel frequency, we have divided them in to\n LOW BAND, MID BAND and HIGH BAND"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MAX_POWER_OFFSETS {
    NRF_WIFI_MAX_OP_PWR_DSSS_OFST = 0,
    NRF_WIFI_MAX_OP_PWR_2PT4GHZ_OFDM_MCS7 = 1,
    NRF_WIFI_MAX_OP_PWR_2PT4GHZ_OFDM_MCS0 = 2,
    NRF_WIFI_MAX_OP_PWR_5GHZ_LB_MCS7 = 3,
    NRF_WIFI_MAX_OP_PWR_5GHZ_MID_MCS7 = 4,
    NRF_WIFI_MAX_OP_PWR_5GHZ_HI_MCS7 = 5,
    NRF_WIFI_MAX_OP_PWR_5GHZ_LB_MCS0 = 6,
    NRF_WIFI_MAX_OP_PWR_5GHZ_MID_MCS0 = 7,
    NRF_WIFI_MAX_OP_PWR_5GHZ_HI_MCS0 = 8,
}
#[repr(u32)]
#[doc = " The byte offsets of RF parameters indicate the start offset\n of PCB loss for 2.4 GHz and 5 GHz bands."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PCB_LOSS_BYTE_OFFSETS {
    PCB_LOSS_BYTE_2G_OFST = 185,
    PCB_LOSS_BYTE_5G_BAND1_OFST = 186,
    PCB_LOSS_BYTE_5G_BAND2_OFST = 187,
    PCB_LOSS_BYTE_5G_BAND3_OFST = 188,
}
#[repr(u32)]
#[doc = " The byte offsets of RF parameters indicate the start offset\n of antenna gain for 2.4 GHz and 5 GHz bands."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ANT_GAIN_OFFSETS {
    ANT_GAIN_2G_OFST = 181,
    ANT_GAIN_5G_BAND1_OFST = 182,
    ANT_GAIN_5G_BAND2_OFST = 183,
    ANT_GAIN_5G_BAND3_OFST = 184,
    NUM_ANT_GAIN = 4,
}
#[repr(u32)]
#[doc = " The byte offsets of RF parameters indicate the start offset\n of band edge backoffs for different frame formats and\n different sub-bands of 2.4 GHz and 5 GHz frequency band."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EDGE_BACKOFF_OFFSETS {
    BAND_2G_LW_ED_BKF_DSSS_OFST = 155,
    BAND_2G_LW_ED_BKF_HT_OFST = 156,
    BAND_2G_LW_ED_BKF_HE_OFST = 157,
    BAND_2G_UW_ED_BKF_DSSS_OFST = 158,
    BAND_2G_UW_ED_BKF_HT_OFST = 159,
    BAND_2G_UW_ED_BKF_HE_OFST = 160,
    BAND_UNII_1_LW_ED_BKF_HT_OFST = 161,
    BAND_UNII_1_LW_ED_BKF_HE_OFST = 162,
    BAND_UNII_1_UW_ED_BKF_HT_OFST = 163,
    BAND_UNII_1_UW_ED_BKF_HE_OFST = 164,
    BAND_UNII_2A_LW_ED_BKF_HT_OFST = 165,
    BAND_UNII_2A_LW_ED_BKF_HE_OFST = 166,
    BAND_UNII_2A_UW_ED_BKF_HT_OFST = 167,
    BAND_UNII_2A_UW_ED_BKF_HE_OFST = 168,
    BAND_UNII_2C_LW_ED_BKF_HT_OFST = 169,
    BAND_UNII_2C_LW_ED_BKF_HE_OFST = 170,
    BAND_UNII_2C_UW_ED_BKF_HT_OFST = 171,
    BAND_UNII_2C_UW_ED_BKF_HE_OFST = 172,
    BAND_UNII_3_LW_ED_BKF_HT_OFST = 173,
    BAND_UNII_3_LW_ED_BKF_HE_OFST = 174,
    BAND_UNII_3_UW_ED_BKF_HT_OFST = 175,
    BAND_UNII_3_UW_ED_BKF_HE_OFST = 176,
    BAND_UNII_4_LW_ED_BKF_HT_OFST = 177,
    BAND_UNII_4_LW_ED_BKF_HE_OFST = 178,
    BAND_UNII_4_UW_ED_BKF_HT_OFST = 179,
    BAND_UNII_4_UW_ED_BKF_HE_OFST = 180,
    NUM_EDGE_BACKOFF = 26,
}
#[doc = " @brief This structure defines the parameters used to control the max transmit (TX) power\n in both frequency bands for different data rates."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_pwr_ceil_params {
    #[doc = " Maximum power permitted while transmitting DSSS rates in 2.4G band.\n  Resolution is 0.25dBm."]
    pub max_pwr_2g_dsss: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS0 rate in 2.4G band.\n  Resolution is 0.25dBm."]
    pub max_pwr_2g_mcs0: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS7 rate in 2.4G band.\n  Resolution is 0.25dBm."]
    pub max_pwr_2g_mcs7: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS0 rate in 5G lowband.\n Low band corresponds to ch: 36 to 64 Resolution is 0.25dBm."]
    pub max_pwr_5g_low_mcs0: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS7 rate in 5G lowband.\n Low band corresponds to ch: 36 to 64, resolution is 0.25dBm."]
    pub max_pwr_5g_low_mcs7: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS0 rate in 5G midband.\n Mid band corresponds to ch: 96 to 132, resolution is 0.25dBm."]
    pub max_pwr_5g_mid_mcs0: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS7 rate in 5G midband.\n Mid band corresponds to ch: 96 to 132, resolution is 0.25dBm."]
    pub max_pwr_5g_mid_mcs7: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS0 rate in 5G highband.\n High band corresponds to ch: 136 to 177, resolution is 0.25dBm."]
    pub max_pwr_5g_high_mcs0: ::core::ffi::c_uchar,
    #[doc = " Maximum power permitted while transmitting MCS7 rate in 5G highband.\n High band corresponds to ch: 136 to 177, resolution is 0.25dBm."]
    pub max_pwr_5g_high_mcs7: ::core::ffi::c_uchar,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ft_prog_ver {
    FT_PROG_VER1 = 1,
    FT_PROG_VER2 = 2,
    FT_PROG_VER3 = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lmac_prod_stats {
    pub reset_cmd_cnt: ::core::ffi::c_uint,
    pub reset_complete_event_cnt: ::core::ffi::c_uint,
    pub unable_gen_event: ::core::ffi::c_uint,
    pub ch_prog_cmd_cnt: ::core::ffi::c_uint,
    pub channel_prog_done: ::core::ffi::c_uint,
    pub tx_pkt_cnt: ::core::ffi::c_uint,
    pub tx_pkt_done_cnt: ::core::ffi::c_uint,
    pub scan_pkt_cnt: ::core::ffi::c_uint,
    pub internal_pkt_cnt: ::core::ffi::c_uint,
    pub internal_pkt_done_cnt: ::core::ffi::c_uint,
    pub ack_resp_cnt: ::core::ffi::c_uint,
    pub tx_timeout: ::core::ffi::c_uint,
    pub deagg_isr: ::core::ffi::c_uint,
    pub deagg_inptr_desc_empty: ::core::ffi::c_uint,
    pub deagg_circular_buffer_full: ::core::ffi::c_uint,
    pub lmac_rxisr_cnt: ::core::ffi::c_uint,
    pub rx_decryptcnt: ::core::ffi::c_uint,
    pub process_decrypt_fail: ::core::ffi::c_uint,
    pub prepa_rx_event_fail: ::core::ffi::c_uint,
    pub rx_core_pool_full_cnt: ::core::ffi::c_uint,
    pub rx_mpdu_crc_success_cnt: ::core::ffi::c_uint,
    pub rx_mpdu_crc_fail_cnt: ::core::ffi::c_uint,
    pub rx_ofdm_crc_success_cnt: ::core::ffi::c_uint,
    pub rx_ofdm_crc_fail_cnt: ::core::ffi::c_uint,
    pub rxDSSSCrcSuccessCnt: ::core::ffi::c_uint,
    pub rxDSSSCrcFailCnt: ::core::ffi::c_uint,
    pub rx_crypto_start_cnt: ::core::ffi::c_uint,
    pub rx_crypto_done_cnt: ::core::ffi::c_uint,
    pub rx_event_buf_full: ::core::ffi::c_uint,
    pub rx_extram_buf_full: ::core::ffi::c_uint,
    pub scan_req: ::core::ffi::c_uint,
    pub scan_complete: ::core::ffi::c_uint,
    pub scan_abort_req: ::core::ffi::c_uint,
    pub scan_abort_complete: ::core::ffi::c_uint,
    pub internal_buf_pool_null: ::core::ffi::c_uint,
}
#[doc = " struct phy_prod_stats : used to get the production mode stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_prod_stats {
    pub ofdm_crc32_pass_cnt: ::core::ffi::c_uint,
    pub ofdm_crc32_fail_cnt: ::core::ffi::c_uint,
    pub dsss_crc32_pass_cnt: ::core::ffi::c_uint,
    pub dsss_crc32_fail_cnt: ::core::ffi::c_uint,
    pub averageRSSI: ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rpu_stats {
    pub lmac_stats: lmac_prod_stats,
    pub phy_stats: phy_prod_stats,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct hpqm_queue {
    pub pop_addr: ::core::ffi::c_uint,
    pub push_addr: ::core::ffi::c_uint,
    pub id_num: ::core::ffi::c_uint,
    pub status_addr: ::core::ffi::c_uint,
    pub status_mask: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct INT_HPQ {
    pub id: ::core::ffi::c_uint,
    pub head: ::core::ffi::c_uint,
    pub tail: ::core::ffi::c_uint,
}
#[doc = " @brief LMAC firmware config params\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lmac_fw_config_params {
    #[doc = " lmac firmware boot status. LMAC will set to 0x5a5a5a5a after completing boot process"]
    pub boot_status: ::core::ffi::c_uint,
    #[doc = " LMAC version"]
    pub version: ::core::ffi::c_uint,
    #[doc = " Address to resubmit Rx buffers"]
    pub lmac_rx_buffer_addr: ::core::ffi::c_uint,
    #[doc = " Maximum Rx descriptors"]
    pub lmac_rx_max_desc_cnt: ::core::ffi::c_uint,
    #[doc = " size of each descriptor size"]
    pub lmac_rx_desc_size: ::core::ffi::c_uint,
    #[doc = " rpu config name. this is a string"]
    pub rpu_config_name: [::core::ffi::c_uchar; 16usize],
    #[doc = " rpu config number"]
    pub rpu_config_number: [::core::ffi::c_uchar; 8usize],
    #[doc = " numRX"]
    pub numRX: ::core::ffi::c_uint,
    #[doc = " numTX"]
    pub numTX: ::core::ffi::c_uint,
    #[doc = " supported bands"]
    pub bands: ::core::ffi::c_uint,
    #[doc = " system frequency"]
    pub sys_frequency_in_mhz: ::core::ffi::c_uint,
    #[doc = " queue which contains Free GRAM pointers for commands"]
    pub FreeCmdPtrQ: hpqm_queue,
    #[doc = " Command pointer queue. Host should pick pointer from FreeCmdPtrQ, populate\n  command into that address and submit back to this queue for RPU"]
    pub cmdPtrQ: hpqm_queue,
    #[doc = " queue which contains Free GRAM pointers for events"]
    pub eventPtrQ: hpqm_queue,
    #[doc = " Event pointer queue. Host should pick pointer from FreeCmdPtrQ, populate\n  command into that address and submit back to this queue for RPU"]
    pub freeEventPtrQ: hpqm_queue,
    #[doc = " Rx buffer queue"]
    pub SKBGramPtrQ_1: hpqm_queue,
    #[doc = " Rx buffer queue"]
    pub SKBGramPtrQ_2: hpqm_queue,
    #[doc = " Rx buffer queue"]
    pub SKBGramPtrQ_3: hpqm_queue,
    #[doc = " lmac register address to enable ISR to Host"]
    pub HP_lmac_to_host_isr_en: ::core::ffi::c_uint,
    #[doc = " Address to Clear host ISR"]
    pub HP_lmac_to_host_isr_clear: ::core::ffi::c_uint,
    #[doc = " Address to set ISR to lmac Clear host ISR"]
    pub HP_set_lmac_isr: ::core::ffi::c_uint,
    #[doc = " Hardware queues"]
    pub hpq32: [INT_HPQ; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rx_buf_pool_params {
    #[doc = " buffer size"]
    pub buf_sz: ::core::ffi::c_ushort,
    #[doc = " number of buffers"]
    pub num_bufs: ::core::ffi::c_ushort,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct temp_vbat_config {
    pub temp_based_calib_en: ::core::ffi::c_uint,
    pub temp_calib_bitmap: ::core::ffi::c_uint,
    pub vbat_calibp_bitmap: ::core::ffi::c_uint,
    pub temp_vbat_mon_period: ::core::ffi::c_uint,
    pub vth_very_low: ::core::ffi::c_int,
    pub vth_low: ::core::ffi::c_int,
    pub vth_hi: ::core::ffi::c_int,
    pub temp_threshold: ::core::ffi::c_int,
    pub vbat_threshold: ::core::ffi::c_int,
}
#[repr(u32)]
#[doc = " @brief This enum provides a list of different operating modes.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_op_mode {
    #[doc = " Radio test mode is used for performing radio tests using\n  continuous Tx/Rx on a configured channel at a particular rate or power."]
    RPU_OP_MODE_RADIO_TEST = 0,
    #[doc = " In this mode different types of calibration like RF calibration can be performed"]
    RPU_OP_MODE_FCM = 1,
    #[doc = " Regular mode of operation"]
    RPU_OP_MODE_REG = 2,
    #[doc = " Debug mode can be used to control certain parameters like TX rate\n  in order to debug functional issues."]
    RPU_OP_MODE_DBG = 3,
    #[doc = " Highest mode number currently defined"]
    RPU_OP_MODE_MAX = 4,
}
#[repr(u32)]
#[doc = "  @brief This enum defines various types of statistics."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_stats_type {
    #[doc = " All statistics includes PHY, LMAC & UMAC"]
    RPU_STATS_TYPE_ALL = 0,
    #[doc = " Host statistics"]
    RPU_STATS_TYPE_HOST = 1,
    #[doc = " UMAC statistics"]
    RPU_STATS_TYPE_UMAC = 2,
    #[doc = " LMAC statistics"]
    RPU_STATS_TYPE_LMAC = 3,
    #[doc = " PHY statistics"]
    RPU_STATS_TYPE_PHY = 4,
    #[doc = " Offloaded Raw TX statistics"]
    RPU_STATS_TYPE_OFFLOADED_RAW_TX = 5,
    #[doc = " Highest statistics type number currently defined"]
    RPU_STATS_TYPE_MAX = 6,
}
#[repr(u32)]
#[doc = " @brief- Throughput mode\n Throughput mode to be used for transmitting the packet."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_tput_mode {
    #[doc = " Legacy mode"]
    RPU_TPUT_MODE_LEGACY = 0,
    #[doc = " High Throuput mode(11n)"]
    RPU_TPUT_MODE_HT = 1,
    #[doc = " Very hight throughput(11ac)"]
    RPU_TPUT_MODE_VHT = 2,
    #[doc = " HE SU mode"]
    RPU_TPUT_MODE_HE_SU = 3,
    #[doc = " HE ER SU mode"]
    RPU_TPUT_MODE_HE_ER_SU = 4,
    #[doc = " HE TB mode"]
    RPU_TPUT_MODE_HE_TB = 5,
    #[doc = " Highest throughput mode currently defined"]
    RPU_TPUT_MODE_MAX = 6,
}
#[repr(u32)]
#[doc = " @brief - System commands.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_sys_commands {
    #[doc = " Command to initialize RPU and RPU responds with NRF_WIFI_EVENT_INIT_DONE"]
    NRF_WIFI_CMD_INIT = 0,
    #[doc = " command to send a Tx packet in radiotest mode"]
    NRF_WIFI_CMD_TX = 1,
    #[doc = " Unused"]
    NRF_WIFI_CMD_IF_TYPE = 2,
    #[doc = " command to specify mode of operation"]
    NRF_WIFI_CMD_MODE = 3,
    #[doc = " command to get statistics"]
    NRF_WIFI_CMD_GET_STATS = 4,
    #[doc = " command to clear statistics"]
    NRF_WIFI_CMD_CLEAR_STATS = 5,
    #[doc = " command to ENABLE/DISABLE receiving packets in radiotest mode"]
    NRF_WIFI_CMD_RX = 6,
    #[doc = " Command to measure battery voltage and RPU responds\twith NRF_WIFI_EVENT_PWR_DATA"]
    NRF_WIFI_CMD_PWR = 7,
    #[doc = " RPU De-initialization"]
    NRF_WIFI_CMD_DEINIT = 8,
    #[doc = " Command for WIFI & SR coexistence"]
    NRF_WIFI_CMD_SRCOEX = 9,
    #[doc = " Command to start RF test"]
    NRF_WIFI_CMD_RF_TEST = 10,
    #[doc = " Configure HE_GI & HE_LTF"]
    NRF_WIFI_CMD_HE_GI_LTF_CONFIG = 11,
    #[doc = " Command for getting UMAC memory statistics"]
    NRF_WIFI_CMD_UMAC_INT_STATS = 12,
    #[doc = " Command for Setting the channel & Rf params in radiotest mode"]
    NRF_WIFI_CMD_RADIO_TEST_INIT = 13,
    #[doc = " Command for setting country in radiotest mode"]
    NRF_WIFI_CMD_RT_REQ_SET_REG = 14,
    #[doc = " Command to enable/disable fixed data rate in regular mode"]
    NRF_WIFI_CMD_TX_FIX_DATA_RATE = 15,
    #[doc = " Command to set channel in promiscuous, monitor  & packet injector mode"]
    NRF_WIFI_CMD_CHANNEL = 16,
    #[doc = " Command to configure promiscuous mode, Monitor mode & packet injector mode"]
    NRF_WIFI_CMD_RAW_CONFIG_MODE = 17,
    #[doc = " Command to configure promiscuous mode, Monitor mode filter"]
    NRF_WIFI_CMD_RAW_CONFIG_FILTER = 18,
    #[doc = " Command to configure packet injector mode or Raw Tx mode"]
    NRF_WIFI_CMD_RAW_TX_PKT = 19,
    #[doc = " Command to reset interface statistics"]
    NRF_WIFI_CMD_RESET_STATISTICS = 20,
    #[doc = " Command to configure raw tx offloading parameters"]
    NRF_WIFI_CMD_OFFLOAD_RAW_TX_PARAMS = 21,
    #[doc = " Command to enable/disable raw tx offloading"]
    NRF_WIFI_CMD_OFFLOAD_RAW_TX_CTRL = 22,
}
#[repr(u32)]
#[doc = " @brief - Events from the RPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_sys_events {
    #[doc = " Response to NRF_WIFI_CMD_PWR"]
    NRF_WIFI_EVENT_PWR_DATA = 0,
    #[doc = " Response to NRF_WIFI_CMD_INIT"]
    NRF_WIFI_EVENT_INIT_DONE = 1,
    #[doc = " Response to NRF_WIFI_CMD_GET_STATS"]
    NRF_WIFI_EVENT_STATS = 2,
    #[doc = " Response to NRF_WIFI_CMD_DEINIT"]
    NRF_WIFI_EVENT_DEINIT_DONE = 3,
    #[doc = " Response to NRF_WIFI_CMD_RF_TEST"]
    NRF_WIFI_EVENT_RF_TEST = 4,
    #[doc = " Response to NRF_WIFI_CMD_SRCOEX."]
    NRF_WIFI_EVENT_COEX_CONFIG = 5,
    #[doc = " Response to NRF_WIFI_CMD_UMAC_INT_STATS"]
    NRF_WIFI_EVENT_INT_UMAC_STATS = 6,
    #[doc = " Command status events for radio test commands"]
    NRF_WIFI_EVENT_RADIOCMD_STATUS = 7,
    #[doc = " Response to NRF_WIFI_CMD_CHANNEL"]
    NRF_WIFI_EVENT_CHANNEL_SET_DONE = 8,
    #[doc = " Response to NRF_WIFI_CMD_RAW_CONFIG_MODE"]
    NRF_WIFI_EVENT_MODE_SET_DONE = 9,
    #[doc = " Response to NRF_WIFI_CMD_RAW_CONFIG_FILTER"]
    NRF_WIFI_EVENT_FILTER_SET_DONE = 10,
    #[doc = " Tx done event for the Raw Tx"]
    NRF_WIFI_EVENT_RAW_TX_DONE = 11,
    #[doc = " Command status events for offloaded raw tx commands"]
    NRF_WIFI_EVENT_OFFLOADED_RAWTX_STATUS = 12,
}
#[repr(u32)]
#[doc = " @brief - Channel Bandwidth types.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_ch_bw {
    #[doc = " 20MHz bandwidth"]
    RPU_CH_BW_20 = 0,
    #[doc = " 40MHz bandwidth"]
    RPU_CH_BW_40 = 1,
    #[doc = " 80MHz bandwidth"]
    RPU_CH_BW_MAX = 2,
}
#[doc = " @brief - This structure specifies the parameters required to configure a specific channel.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct chan_params {
    #[doc = " Primary channel number"]
    pub primary_num: ::core::ffi::c_uint,
    #[doc = " Channel bandwidth"]
    pub bw: ::core::ffi::c_uchar,
    #[doc = " 20Mhz offset value"]
    pub sec_20_offset: ::core::ffi::c_int,
    #[doc = " 40Mhz offset value"]
    pub sec_40_offset: ::core::ffi::c_int,
}
#[doc = " @brief This structure specifies the parameters required to start or stop the RX (receive)\n  operation in radiotest mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_conf_rx_radio_test_params {
    #[doc = " Number of spatial streams supported. Currently unused."]
    pub nss: ::core::ffi::c_uchar,
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    #[doc = " An array containing RF and baseband control params"]
    pub chan: chan_params,
    #[doc = " Copy OTP params to this memory"]
    pub phy_threshold: ::core::ffi::c_schar,
    #[doc = " Calibration bit map value. More information can be found in the phy_rf_params.h file."]
    pub phy_calib: ::core::ffi::c_uint,
    #[doc = " Start Rx : 1, Stop Rx :0"]
    pub rx: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure specifies the UMAC (Upper MAC) RX (receive) debug parameters\n  specifically designed for debugging purpose.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_rx_dbg_params {
    #[doc = " Total lmac events received to UMAC"]
    pub lmac_events: ::core::ffi::c_uint,
    #[doc = " Total Rx events(LMAC_EVENT_RX) received in ISR"]
    pub rx_events: ::core::ffi::c_uint,
    #[doc = " Received coalised events from LMAC"]
    pub rx_coalesce_events: ::core::ffi::c_uint,
    #[doc = " Total Rx packets received from LMAC"]
    pub total_rx_pkts_from_lmac: ::core::ffi::c_uint,
    #[doc = " Maximum RX packets buffered at any point of time in UMAC."]
    pub max_refill_gap: ::core::ffi::c_uint,
    #[doc = " Difference between rx packets received from lmac and packets sent to host"]
    pub current_refill_gap: ::core::ffi::c_uint,
    #[doc = " Number of Packets queued to reorder buffer due to out of order"]
    pub out_of_order_mpdus: ::core::ffi::c_uint,
    #[doc = " Number of packets removed from reorder buffer"]
    pub reorder_free_mpdus: ::core::ffi::c_uint,
    #[doc = " Number of Rx packets resubmitted to LMAC by UMAC"]
    pub umac_consumed_pkts: ::core::ffi::c_uint,
    #[doc = " Number of Rx packets sent to Host for resubmiting"]
    pub host_consumed_pkts: ::core::ffi::c_uint,
    #[doc = " Total events posted to UMAC RX thread from LMAC"]
    pub rx_mbox_post: ::core::ffi::c_uint,
    #[doc = " Total events received to UMAC RX thread from LMAC"]
    pub rx_mbox_receive: ::core::ffi::c_uint,
    #[doc = " Number of packets received in out of order"]
    pub reordering_ampdu: ::core::ffi::c_uint,
    #[doc = " Messages posted  to TX mbox from timer ISR"]
    pub timer_mbox_post: ::core::ffi::c_uint,
    #[doc = " Messages received from timer ISR"]
    pub timer_mbox_rcv: ::core::ffi::c_uint,
    #[doc = " Messages posted to TX mbox from work scheduler"]
    pub work_mbox_post: ::core::ffi::c_uint,
    #[doc = " Messages received from work scheduler"]
    pub work_mbox_rcv: ::core::ffi::c_uint,
    #[doc = " Messages posted to TX mbox from tasklet function"]
    pub tasklet_mbox_post: ::core::ffi::c_uint,
    #[doc = " Messages received from tasklet function"]
    pub tasklet_mbox_rcv: ::core::ffi::c_uint,
    #[doc = " Management frames sent to userspace"]
    pub userspace_offload_frames: ::core::ffi::c_uint,
    #[doc = " Number of times where requested buffer size is not available\n  and allocated from next available memory buffer"]
    pub alloc_buf_fail: ::core::ffi::c_uint,
    #[doc = " Total packets count in RX thread"]
    pub rx_packet_total_count: ::core::ffi::c_uint,
    #[doc = " Number of data packets received"]
    pub rx_packet_data_count: ::core::ffi::c_uint,
    #[doc = " Number of Qos data packets received"]
    pub rx_packet_qos_data_count: ::core::ffi::c_uint,
    #[doc = " Number of protected data packets received"]
    pub rx_packet_protected_data_count: ::core::ffi::c_uint,
    #[doc = " Number of management packets received"]
    pub rx_packet_mgmt_count: ::core::ffi::c_uint,
    #[doc = " Number of beacon packets received"]
    pub rx_packet_beacon_count: ::core::ffi::c_uint,
    #[doc = " Number of probe response packets received"]
    pub rx_packet_probe_resp_count: ::core::ffi::c_uint,
    #[doc = " Number of authentication packets received"]
    pub rx_packet_auth_count: ::core::ffi::c_uint,
    #[doc = " Number of deauthentication packets received"]
    pub rx_packet_deauth_count: ::core::ffi::c_uint,
    #[doc = " Number of assoc response packets received"]
    pub rx_packet_assoc_resp_count: ::core::ffi::c_uint,
    #[doc = " Number of disassociation packets received"]
    pub rx_packet_disassoc_count: ::core::ffi::c_uint,
    #[doc = " Number of action frames received"]
    pub rx_packet_action_count: ::core::ffi::c_uint,
    #[doc = " Number of probe request packets received"]
    pub rx_packet_probe_req_count: ::core::ffi::c_uint,
    #[doc = " Other management packets received"]
    pub rx_packet_other_mgmt_count: ::core::ffi::c_uint,
    #[doc = " Maximum coalised packets received from LMAC in any RX event"]
    pub max_coalesce_pkts: ::core::ffi::c_schar,
    #[doc = " Packets received with null skb pointer from LMAC"]
    pub null_skb_pointer_from_lmac: ::core::ffi::c_uint,
    #[doc = " Number of unexpected management packets received in coalesce event"]
    pub unexpected_mgmt_pkt: ::core::ffi::c_uint,
}
#[doc = " @brief This structure specifies the UMAC TX (transmit) debug parameters used for\n  debugging purposes.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_tx_dbg_params {
    #[doc = " Total number of tx commands received from host"]
    pub tx_cmd: ::core::ffi::c_uint,
    #[doc = " Non coalesce packets received"]
    pub tx_non_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " coalesce packets received"]
    pub tx_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Maximum number of coalesce packets received in any\n  TX command coalesce packets received"]
    pub tx_max_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Maximum Tx commands currently in process at any point of time in UMAC"]
    pub tx_cmds_max_used: ::core::ffi::c_uint,
    #[doc = " Number of Tx commands that are currently in process in UMAC"]
    pub tx_cmds_currently_in_use: ::core::ffi::c_uint,
    #[doc = " Number of tx done events sent to host"]
    pub tx_done_events_send_to_host: ::core::ffi::c_uint,
    #[doc = " Number of tx done success packets sent to host"]
    pub tx_done_success_pkts_to_host: ::core::ffi::c_uint,
    #[doc = " Number of tx done failure packets sent to host"]
    pub tx_done_failure_pkts_to_host: ::core::ffi::c_uint,
    #[doc = " Number of packets received from host that needs to be encrypted"]
    pub tx_cmds_with_crypto_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Number of packets received from host that need not to be encrypted"]
    pub tx_cmds_with_non_crypto_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Number of broadcast\tpackets received from host"]
    pub tx_cmds_with_broadcast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Number of multicast\tpackets received from host"]
    pub tx_cmds_with_multicast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " Number of unicast packets received from host"]
    pub tx_cmds_with_unicast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    #[doc = " UMAC internal count"]
    pub xmit: ::core::ffi::c_uint,
    #[doc = " Number of addba requests sent"]
    pub send_addba_req: ::core::ffi::c_uint,
    #[doc = " Total ADD BA responses received from host"]
    pub addba_resp: ::core::ffi::c_uint,
    #[doc = " Total packets received in softmac tx function"]
    pub softmac_tx: ::core::ffi::c_uint,
    #[doc = " Number of packets generated internally in UMAC"]
    pub internal_pkts: ::core::ffi::c_uint,
    #[doc = " Number of packets Received from host"]
    pub external_pkts: ::core::ffi::c_uint,
    #[doc = " Total tx commmands sent to lmac"]
    pub tx_cmds_to_lmac: ::core::ffi::c_uint,
    #[doc = " Tx dones received from LMAC"]
    pub tx_dones_from_lmac: ::core::ffi::c_uint,
    #[doc = " Total commands sent to lmac in UMAC hal"]
    pub total_cmds_to_lmac: ::core::ffi::c_uint,
    #[doc = " Number of data packets sent"]
    pub tx_packet_data_count: ::core::ffi::c_uint,
    #[doc = " Number of management packets sent"]
    pub tx_packet_mgmt_count: ::core::ffi::c_uint,
    #[doc = " Number of beacon packets sent"]
    pub tx_packet_beacon_count: ::core::ffi::c_uint,
    #[doc = " Number of probe request packets sent"]
    pub tx_packet_probe_req_count: ::core::ffi::c_uint,
    #[doc = " Number of authentication packets sent"]
    pub tx_packet_auth_count: ::core::ffi::c_uint,
    #[doc = " Number of deauthentication packets sent"]
    pub tx_packet_deauth_count: ::core::ffi::c_uint,
    #[doc = " Number of association request packets sent"]
    pub tx_packet_assoc_req_count: ::core::ffi::c_uint,
    #[doc = " Number of disassociation packets sent"]
    pub tx_packet_disassoc_count: ::core::ffi::c_uint,
    #[doc = " Number of action packets sent"]
    pub tx_packet_action_count: ::core::ffi::c_uint,
    #[doc = " Other management packets sent"]
    pub tx_packet_other_mgmt_count: ::core::ffi::c_uint,
    #[doc = " Number of Non management packets sent"]
    pub tx_packet_non_mgmt_data_count: ::core::ffi::c_uint,
}
#[doc = " @brief This structure specifies the UMAC command and event debug parameters used for\n  debugging purpose.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_evnt_dbg_params {
    #[doc = " Number of command init received from host"]
    pub cmd_init: ::core::ffi::c_uchar,
    #[doc = " Number of init_done events sent to host"]
    pub event_init_done: ::core::ffi::c_uchar,
    #[doc = " Number of rf test command received from host"]
    pub cmd_rf_test: ::core::ffi::c_uchar,
    #[doc = " Number of connect command received from host"]
    pub cmd_connect: ::core::ffi::c_uchar,
    #[doc = " Number of get_stats command received from host"]
    pub cmd_get_stats: ::core::ffi::c_uint,
    #[doc = " Number of power save state events sent to host"]
    pub event_ps_state: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub cmd_set_reg: ::core::ffi::c_uint,
    #[doc = " Number of get regulatory commands received from host"]
    pub cmd_get_reg: ::core::ffi::c_uint,
    #[doc = " Number of request set regulatory commands received from host"]
    pub cmd_req_set_reg: ::core::ffi::c_uint,
    #[doc = " Number of trigger scan commands received from host"]
    pub cmd_trigger_scan: ::core::ffi::c_uint,
    #[doc = " Number of scan done events sent to host"]
    pub event_scan_done: ::core::ffi::c_uint,
    #[doc = " Number of get scan commands received from the host to get scan results"]
    pub cmd_get_scan: ::core::ffi::c_uint,
    #[doc = " Number of scan commands sent to LMAC"]
    pub umac_scan_req: ::core::ffi::c_uint,
    #[doc = " Number of scan complete events received from LMAC"]
    pub umac_scan_complete: ::core::ffi::c_uint,
    #[doc = " Number of scan requests received from host when previous scan is in progress"]
    pub umac_scan_busy: ::core::ffi::c_uint,
    #[doc = " Number of authentication requests received from host"]
    pub cmd_auth: ::core::ffi::c_uint,
    #[doc = " Number of association requests received from host"]
    pub cmd_assoc: ::core::ffi::c_uint,
    #[doc = " Number of deauthentication requests received from host"]
    pub cmd_deauth: ::core::ffi::c_uint,
    #[doc = " Number of register frame commands received from host to register\n  a management frame type which should be passed to host"]
    pub cmd_register_frame: ::core::ffi::c_uint,
    #[doc = " Number of command frames from host which will be used for\n  transmitting management frames"]
    pub cmd_frame: ::core::ffi::c_uint,
    #[doc = " Number of delete key commands from host"]
    pub cmd_del_key: ::core::ffi::c_uint,
    #[doc = " Number of new key commands received from host"]
    pub cmd_new_key: ::core::ffi::c_uint,
    #[doc = " Number of set key commands received from host"]
    pub cmd_set_key: ::core::ffi::c_uint,
    #[doc = " Number of get key commands received from host"]
    pub cmd_get_key: ::core::ffi::c_uint,
    #[doc = " Number of beacon hint events sent to host"]
    pub event_beacon_hint: ::core::ffi::c_uint,
    #[doc = " Number of regulatory change events sent to host when regulatory change command\n  received from host such as in response to command NL80211_CMD_REG_CHANGE"]
    pub event_reg_change: ::core::ffi::c_uint,
    #[doc = " Number of regulatory change events sent to host other than\n  host request for regulatory change"]
    pub event_wiphy_reg_change: ::core::ffi::c_uint,
    #[doc = " Number of set station commands received from host"]
    pub cmd_set_station: ::core::ffi::c_uint,
    #[doc = " Number of new station commands received from host"]
    pub cmd_new_station: ::core::ffi::c_uint,
    #[doc = " Number of del station commands received from host"]
    pub cmd_del_station: ::core::ffi::c_uint,
    #[doc = " Number of new interface commands received from host"]
    pub cmd_new_interface: ::core::ffi::c_uint,
    #[doc = " Number of set interface commands received from host"]
    pub cmd_set_interface: ::core::ffi::c_uint,
    #[doc = " Number of get interface commands received from host"]
    pub cmd_get_interface: ::core::ffi::c_uint,
    #[doc = " Number of set_ifflags commands received from host"]
    pub cmd_set_ifflags: ::core::ffi::c_uint,
    #[doc = " Number of set_ifflags events sent to host"]
    pub cmd_set_ifflags_done: ::core::ffi::c_uint,
    #[doc = " Number of set bss command received from host"]
    pub cmd_set_bss: ::core::ffi::c_uint,
    #[doc = " Number of set wiphy command received from host"]
    pub cmd_set_wiphy: ::core::ffi::c_uint,
    #[doc = " Number of start access point command received from host"]
    pub cmd_start_ap: ::core::ffi::c_uint,
    #[doc = " Number of power save configuration commands sent to LMAC"]
    pub LMAC_CMD_PS: ::core::ffi::c_uint,
    #[doc = " Current power save state configured to LMAC through LMAC_CMD_PS command"]
    pub CURR_STATE: ::core::ffi::c_uint,
}
#[doc = " @brief This structure specifies the UMAC interface debug parameters used for debugging purpose.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_interface_stats {
    #[doc = " Number of unicast packets sent"]
    pub tx_unicast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of multicast packets sent"]
    pub tx_multicast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of broadcast packets sent"]
    pub tx_broadcast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of tx data bytes sent"]
    pub tx_bytes: ::core::ffi::c_uint,
    #[doc = " Number of unicast packets received"]
    pub rx_unicast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of multicast packets received"]
    pub rx_multicast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of broadcast packets received"]
    pub rx_broadcast_pkt_count: ::core::ffi::c_uint,
    #[doc = " Number of beacon packets received"]
    pub rx_beacon_success_count: ::core::ffi::c_uint,
    #[doc = " Number of beacon packets missed"]
    pub rx_beacon_miss_count: ::core::ffi::c_uint,
    #[doc = " Number of rx data bytes received"]
    pub rx_bytes: ::core::ffi::c_uint,
    #[doc = " Number of packets with checksum mismatch received"]
    pub rx_checksum_error_count: ::core::ffi::c_uint,
    #[doc = " Number of duplicate packets received"]
    pub replay_attack_drop_cnt: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the UMAC debug statistics. It contains the necessary parameters\n  and fields used to gather and present debugging statistics within the UMAC layer.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_umac_stats {
    #[doc = " Transmit debug statistics @ref umac_tx_dbg_params"]
    pub tx_dbg_params: umac_tx_dbg_params,
    #[doc = " Receive debug statistics @ref umac_rx_dbg_params"]
    pub rx_dbg_params: umac_rx_dbg_params,
    #[doc = " Command Event debug statistics @ref umac_cmd_evnt_dbg_params"]
    pub cmd_evnt_dbg_params: umac_cmd_evnt_dbg_params,
    #[doc = " Interface debug parameters @ref nrf_wifi_interface_stats"]
    pub interface_data_stats: nrf_wifi_interface_stats,
}
#[doc = " @brief This structure defines the LMAC debug parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_lmac_stats {
    #[doc = " Number of reset command counts from UMAC"]
    pub reset_cmd_cnt: ::core::ffi::c_uint,
    #[doc = " Number of reset complete events sent to UMAC"]
    pub reset_complete_event_cnt: ::core::ffi::c_uint,
    #[doc = " Number of events unable to generate"]
    pub unable_gen_event: ::core::ffi::c_uint,
    #[doc = " Number of channel program commands from UMAC"]
    pub ch_prog_cmd_cnt: ::core::ffi::c_uint,
    #[doc = " Number of channel program done events to UMAC"]
    pub channel_prog_done: ::core::ffi::c_uint,
    #[doc = " Number of Tx commands from UMAC"]
    pub tx_pkt_cnt: ::core::ffi::c_uint,
    #[doc = " Number of Tx done events to UMAC"]
    pub tx_pkt_done_cnt: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub scan_pkt_cnt: ::core::ffi::c_uint,
    #[doc = " Number of internal Tx packets"]
    pub internal_pkt_cnt: ::core::ffi::c_uint,
    #[doc = " Number of Tx dones for internal packets"]
    pub internal_pkt_done_cnt: ::core::ffi::c_uint,
    #[doc = " Number of acknowledgment responses"]
    pub ack_resp_cnt: ::core::ffi::c_uint,
    #[doc = " Number of transmit timeouts"]
    pub tx_timeout: ::core::ffi::c_uint,
    #[doc = " Number of deaggregation ISRs"]
    pub deagg_isr: ::core::ffi::c_uint,
    #[doc = " Number of deaggregation input descriptor empties"]
    pub deagg_inptr_desc_empty: ::core::ffi::c_uint,
    #[doc = " Number of deaggregation circular buffer full events"]
    pub deagg_circular_buffer_full: ::core::ffi::c_uint,
    #[doc = " Number of LMAC received ISRs"]
    pub lmac_rxisr_cnt: ::core::ffi::c_uint,
    #[doc = " Number of received packets decrypted"]
    pub rx_decryptcnt: ::core::ffi::c_uint,
    #[doc = " Number of packet decryption failures during processing"]
    pub process_decrypt_fail: ::core::ffi::c_uint,
    #[doc = " Number of RX event preparation failures"]
    pub prepa_rx_event_fail: ::core::ffi::c_uint,
    #[doc = " Number of RX core pool full counts"]
    pub rx_core_pool_full_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX MPDU CRC successes"]
    pub rx_mpdu_crc_success_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX MPDU CRC failures"]
    pub rx_mpdu_crc_fail_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX OFDM CRC successes"]
    pub rx_ofdm_crc_success_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX OFDM CRC failures"]
    pub rx_ofdm_crc_fail_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX DSSS CRC successes"]
    pub rxDSSSCrcSuccessCnt: ::core::ffi::c_uint,
    #[doc = " Number of RX DSSS CRC failures"]
    pub rxDSSSCrcFailCnt: ::core::ffi::c_uint,
    #[doc = " Number of RX crypto start counts"]
    pub rx_crypto_start_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX crypto done counts"]
    pub rx_crypto_done_cnt: ::core::ffi::c_uint,
    #[doc = " Number of RX event buffer full counts"]
    pub rx_event_buf_full: ::core::ffi::c_uint,
    #[doc = " Number of RX external RAM buffer full counts"]
    pub rx_extram_buf_full: ::core::ffi::c_uint,
    #[doc = " Number of scan requests receive from UMAC"]
    pub scan_req: ::core::ffi::c_uint,
    #[doc = " Number of scan complete events sent to UMAC"]
    pub scan_complete: ::core::ffi::c_uint,
    #[doc = " Number of scan abort requests"]
    pub scan_abort_req: ::core::ffi::c_uint,
    #[doc = " Number of scan abort complete events"]
    pub scan_abort_complete: ::core::ffi::c_uint,
    #[doc = " Number of internal buffer pool null counts"]
    pub internal_buf_pool_null: ::core::ffi::c_uint,
    #[doc = " RPU hardware lockup event detection count"]
    pub rpu_hw_lockup_count: ::core::ffi::c_uint,
    #[doc = " RPU hardware lockup recovery completed count"]
    pub rpu_hw_lockup_recovery_done: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the PHY (Physical Layer) debug statistics.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_phy_stats {
    #[doc = " Rssi average value received from LMAC"]
    pub rssi_avg: ::core::ffi::c_schar,
    #[doc = " Unused"]
    pub pdout_val: ::core::ffi::c_uchar,
    #[doc = " Number of OFDM CRC Pass packets"]
    pub ofdm_crc32_pass_cnt: ::core::ffi::c_uint,
    #[doc = " Number of OFDM CRC Fail packets"]
    pub ofdm_crc32_fail_cnt: ::core::ffi::c_uint,
    #[doc = " Number of DSSS CRC Pass packets"]
    pub dsss_crc32_pass_cnt: ::core::ffi::c_uint,
    #[doc = " Number of DSSS CRC Fail packets"]
    pub dsss_crc32_fail_cnt: ::core::ffi::c_uint,
}
#[doc = " @brief The UMAC header structure for system commands and events defines the format\n  used to transmit and receive system-level commands and events.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sys_head {
    #[doc = " Command/Event id"]
    pub cmd_event: ::core::ffi::c_uint,
    #[doc = " message length"]
    pub len: ::core::ffi::c_uint,
}
#[repr(u32)]
#[doc = " @brief The maximum Rx (receive) A-MPDU size in KB.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum max_rx_ampdu_size {
    #[doc = " 8KB AMPDU Size"]
    MAX_RX_AMPDU_SIZE_8KB = 0,
    #[doc = " 16KB AMPDU Size"]
    MAX_RX_AMPDU_SIZE_16KB = 1,
    #[doc = " 32KB AMPDU Size"]
    MAX_RX_AMPDU_SIZE_32KB = 2,
    #[doc = " 64KB AMPDU Size"]
    MAX_RX_AMPDU_SIZE_64KB = 3,
}
#[doc = " @brief This structure specifies the configuration parameters used for configuring\n  data-related settings.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_data_config_params {
    #[doc = " rate_protection_type:0->NONE, 1->RTS/CTS, 2->CTS2SELF"]
    pub rate_protection_type: ::core::ffi::c_uchar,
    #[doc = " Aggregation is enabled(NRF_WIFI_FEATURE_ENABLE) or\n  disabled(NRF_WIFI_FEATURE_DISABLE)"]
    pub aggregation: ::core::ffi::c_uchar,
    #[doc = " WMM is enabled(NRF_WIFI_FEATURE_ENABLE) or\n  disabled(NRF_WIFI_FEATURE_DISABLE)"]
    pub wmm: ::core::ffi::c_uchar,
    #[doc = " Max number of aggregated TX sessions"]
    pub max_num_tx_agg_sessions: ::core::ffi::c_uchar,
    #[doc = " Max number of aggregated RX sessions"]
    pub max_num_rx_agg_sessions: ::core::ffi::c_uchar,
    #[doc = " maximum aggregation size"]
    pub max_tx_aggregation: ::core::ffi::c_uchar,
    #[doc = " Reorder buffer size (1 to 64)"]
    pub reorder_buf_size: ::core::ffi::c_uchar,
    #[doc = " Max RX AMPDU size (8/16/32/64 KB), see &enum max_rx_ampdu_size"]
    pub max_rxampdu_size: ::core::ffi::c_int,
}
#[doc = " @brief This structure specifies the parameters that need to be provided for the command\n NRF_WIFI_CMD_INIT for all modes. The NRF_WIFI_CMD_INIT command is typically used to\n initialize the Wi-Fi module and prepare it for further communication.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sys_params {
    #[doc = " enable rpu sleep"]
    pub sleep_enable: ::core::ffi::c_uint,
    #[doc = " Normal/FTM mode"]
    pub hw_bringup_time: ::core::ffi::c_uint,
    #[doc = " Antenna Configuration, applicable only for 1x1"]
    pub sw_bringup_time: ::core::ffi::c_uint,
    #[doc = " Internal tuning parameter"]
    pub bcn_time_out: ::core::ffi::c_uint,
    #[doc = " Set to 1 if rpu is expected to perform sleep clock calibration"]
    pub calib_sleep_clk: ::core::ffi::c_uint,
    #[doc = " calib bit map value. More info can be found in phy_rf_params.h NRF_WIFI_DEF_PHY_CALIB"]
    pub phy_calib: ::core::ffi::c_uint,
    #[doc = " MAC address of the interface. Not applicable to Radio Test mode"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " An array containing RF & baseband control params"]
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    #[doc = " Indicates whether the rf_params has a valid value"]
    pub rf_params_valid: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines the parameters used to control the transmit (TX) power.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_pwr_ctrl_params {
    #[doc = " Antenna gain for 2.4 GHz band"]
    pub ant_gain_2g: ::core::ffi::c_uchar,
    #[doc = " Antenna gain for 5 GHz band (5150 MHz - 5350 MHz)"]
    pub ant_gain_5g_band1: ::core::ffi::c_uchar,
    #[doc = " Antenna gain for 5 GHz band (5470 MHz - 5730 MHz)"]
    pub ant_gain_5g_band2: ::core::ffi::c_uchar,
    #[doc = " Antenna gain for 5 GHz band (5730 MHz - 5895 MHz)"]
    pub ant_gain_5g_band3: ::core::ffi::c_uchar,
    #[doc = " DSSS Transmit power backoff (in dB) for lower edge of 2.4 GHz frequency band"]
    pub band_edge_2g_lo_dss: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for lower edge of 2.4 GHz frequency band"]
    pub band_edge_2g_lo_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for lower edge of 2.4 GHz frequency band"]
    pub band_edge_2g_lo_he: ::core::ffi::c_uchar,
    #[doc = " DSSS Transmit power backoff (in dB) for upper edge of 2.4 GHz frequency band"]
    pub band_edge_2g_hi_dsss: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for upper edge of 2.4 GHz frequency band"]
    pub band_edge_2g_hi_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for upper edge of 2.4 GHz frequency band"]
    pub band_edge_2g_hi_he: ::core::ffi::c_uchar,
    #[doc = " HT Transmit power backoff (in dB) for lower edge of UNII-1 frequency band"]
    pub band_edge_5g_unii_1_lo_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for lower edge of UNII-1 frequency band"]
    pub band_edge_5g_unii_1_lo_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for upper edge of UNII-1 frequency band"]
    pub band_edge_5g_unii_1_hi_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for upper edge of UNII-1 frequency band"]
    pub band_edge_5g_unii_1_hi_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for lower edge of UNII-2A frequency band"]
    pub band_edge_5g_unii_2a_lo_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for lower edge of UNII-2A frequency band"]
    pub band_edge_5g_unii_2a_lo_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for upper edge of UNII-2A frequency band"]
    pub band_edge_5g_unii_2a_hi_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for upper edge of UNII-2A frequency band"]
    pub band_edge_5g_unii_2a_hi_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for lower edge of UNII-2C frequency band"]
    pub band_edge_5g_unii_2c_lo_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for lower edge of UNII-2C frequency band"]
    pub band_edge_5g_unii_2c_lo_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for upper edge of UNII-2C frequency band"]
    pub band_edge_5g_unii_2c_hi_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for upper edge of UNII-2C frequency band"]
    pub band_edge_5g_unii_2c_hi_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for lower edge of UNII-3 frequency band"]
    pub band_edge_5g_unii_3_lo_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for lower edge of UNII-3 frequency band"]
    pub band_edge_5g_unii_3_lo_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for upper edge of UNII-3 frequency band"]
    pub band_edge_5g_unii_3_hi_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for upper edge of UNII-3 frequency band"]
    pub band_edge_5g_unii_3_hi_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for lower edge of UNII-4 frequency band"]
    pub band_edge_5g_unii_4_lo_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for lower edge of UNII-4 frequency band"]
    pub band_edge_5g_unii_4_lo_he: ::core::ffi::c_uchar,
    #[doc = " HT/VHT Transmit power backoff (in dB) for upper edge of UNII-4 frequency band"]
    pub band_edge_5g_unii_4_hi_ht: ::core::ffi::c_uchar,
    #[doc = " HE Transmit power backoff (in dB) for upper edge of UNII-4 frequency band"]
    pub band_edge_5g_unii_4_hi_he: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines board dependent parameters like PCB loss.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_board_params {
    #[doc = " PCB loss for 2.4 GHz band"]
    pub pcb_loss_2g: ::core::ffi::c_uchar,
    #[doc = " PCB loss for 5 GHz band (5150 MHz - 5350 MHz)"]
    pub pcb_loss_5g_band1: ::core::ffi::c_uchar,
    #[doc = " PCB loss for 5 GHz band (5470 MHz - 5730 MHz)"]
    pub pcb_loss_5g_band2: ::core::ffi::c_uchar,
    #[doc = " PCB loss for 5 GHz band (5730 MHz - 5895 MHz)"]
    pub pcb_loss_5g_band3: ::core::ffi::c_uchar,
}
#[repr(u32)]
#[doc = " @brief This enum defines different types of operating bands.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum op_band {
    #[doc = " All bands"]
    BAND_ALL = 0,
    #[doc = " 2.4Ghz band"]
    BAND_24G = 1,
}
#[repr(u32)]
#[doc = " @brief This enum defines keep alive state\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_keep_alive_status {
    #[doc = " Keep alive feature disabled"]
    KEEP_ALIVE_DISABLED = 0,
    #[doc = " Keep alive feature enabled"]
    KEEP_ALIVE_ENABLED = 1,
}
#[repr(u32)]
#[doc = " @brief This enum specifies the type of frames used to retrieve buffered data\n  from the AP in power save mode."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ps_exit_strategy {
    #[doc = " Uses an intelligent algo and decide whether to\n stay or exit power save mode to receive buffered frames."]
    INT_PS = 0,
    #[doc = " Exits power save mode for every TIM"]
    EVERY_TIM = 1,
}
#[doc = " @brief This structure defines the command responsible for initializing the UMAC.\n  After the host driver brings up, the host sends NRF_WIFI_CMD_INIT to the RPU.\n  The RPU then performs the initialization and responds with NRF_WIFI_EVENT_INIT_DONE\n  once the initialization is completed.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_sys_init {
    #[doc = " umac header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " id of the interface"]
    pub wdev_id: ::core::ffi::c_uint,
    #[doc = " @ref nrf_wifi_sys_params"]
    pub sys_params: nrf_wifi_sys_params,
    #[doc = " LMAC Rx buffs pool params, @ref rx_buf_pool_params"]
    pub rx_buf_pools: [rx_buf_pool_params; 3usize],
    #[doc = " Data configuration params, @ref nrf_wifi_data_config_params"]
    pub data_config_params: nrf_wifi_data_config_params,
    #[doc = " Calibration trigger control info based on battery voltage and temperature changes.\n  @ref temp_vbat_config from lmac_if_common.h"]
    pub temp_vbat_config_params: temp_vbat_config,
    #[doc = " 0:umac checksum disable 1: umac checksum enable"]
    pub tcp_ip_checksum_offload: ::core::ffi::c_uchar,
    #[doc = " Country code to set"]
    pub country_code: [::core::ffi::c_uchar; 2usize],
    #[doc = " Operating band see enum op_band"]
    pub op_band: ::core::ffi::c_uint,
    #[doc = " Offload mgmt buffer refill to UMAC when enabled"]
    pub mgmt_buff_offload: ::core::ffi::c_uchar,
    #[doc = " Enable features from driver config"]
    pub feature_flags: ::core::ffi::c_uint,
    #[doc = " To deactivate beamforming, By default the RPU enables the beamforming feature.\n  If a user wishes to turn it off, they should set this parameter to 1."]
    pub disable_beamforming: ::core::ffi::c_uint,
    #[doc = " The RPU uses this value (in seconds) to decide how long to wait\n  without receiving beacons before disconnection."]
    pub discon_timeout: ::core::ffi::c_uint,
    #[doc = " RPU uses QoS null frame or PS-Poll frame to retrieve buffered frames\n from the AP in power save @ref ps_exit_strategy."]
    pub ps_exit_strategy: ::core::ffi::c_uchar,
    #[doc = " The RPU uses this value to configure watchdog timer"]
    pub watchdog_timer_val: ::core::ffi::c_uint,
    #[doc = " The RPU uses this value to decide whether keep alive\n  feature is enabled or not see enum keep_alive_status"]
    pub keep_alive_enable: ::core::ffi::c_uchar,
    #[doc = " The RPU uses this value(in seconds) for periodicity of the keep\n  alive frame."]
    pub keep_alive_period: ::core::ffi::c_uint,
    #[doc = " The RPU uses this value to define the limit on display scan BSS entries.\n  By default, the limit is set to 250 in scan-only mode and 150 in regular mode.\n  If this value is greater than 0, it overrides the default limits."]
    pub display_scan_bss_limit: ::core::ffi::c_uint,
    #[doc = " The RPU uses this value to enable/disable priority window for Wi-Fi scan\n  in the case of coexistence with Short Range radio."]
    pub coex_disable_ptiwin_for_wifi_scan: ::core::ffi::c_uint,
    #[doc = " The RPU uses this value to enable : 1 or disable : 0 the transmission of\n  beacon and probe responses to the host when mgmt buffer offloading is enabled."]
    pub raw_scan_enable: ::core::ffi::c_uchar,
    #[doc = " The RPU uses this value for the number of PS-POLL failures\n  to switch from ps-poll power save mode to QoS null-based\n  power save mode.\n  MIN: 10 (default), MAX: 0xfffffffe.\n  Set to 0xffffffff to disable this feature."]
    pub max_ps_poll_fail_cnt: ::core::ffi::c_uint,
    #[doc = " Enables or disables RX STBC in HT mode.\n  By default, RX STBC is enabled."]
    pub stbc_enable_in_ht: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the command used to de-initialize the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_sys_deinit {
    #[doc = " umac header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
}
#[doc = " @brief This structure defines the command used to configure\n  High-Efficiency Guard Interval(HE-GI) and High-Efficiency Long Training Field (HE-LTF).\n\n  HE-GI duration determines the guard interval length used in the HE transmission.\n  HE-LTF is used for channel estimation and signal detection in HE transmissions.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_he_gi_ltf_config {
    #[doc = " umac header, see &nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " wdev interface id"]
    pub wdev_id: ::core::ffi::c_uchar,
    #[doc = " HE GI type (NRF_WIFI_HE_GI_800NS/NRF_WIFI_HE_GI_1600NS/NRF_WIFI_HE_GI_3200NS)"]
    pub he_gi_type: ::core::ffi::c_uchar,
    #[doc = " HE LTF (NRF_WIFI_HE_LTF_3200NS/NRF_WIFI_HE_LTF_6400NS/NRF_WIFI_HE_LTF_12800NS)"]
    pub he_ltf: ::core::ffi::c_uchar,
    #[doc = " Fixed HE GI & LTF values can be enabled and disabled"]
    pub enable: ::core::ffi::c_uchar,
}
#[repr(u32)]
#[doc = " @brief This enum represents the different types of preambles used.\n  Preambles are sequences of known symbols transmitted before the actual\n  data transmission to enable synchronization, channel estimation, and\n  frame detection at the receiver.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_pkt_preamble {
    #[doc = " Short preamble packet"]
    RPU_PKT_PREAMBLE_SHORT = 0,
    #[doc = " Long preamble packet"]
    RPU_PKT_PREAMBLE_LONG = 1,
    #[doc = " mixed preamble packet"]
    RPU_PKT_PREAMBLE_MIXED = 2,
    #[doc = " Highest preamble type currently defined"]
    RPU_PKT_PREAMBLE_MAX = 3,
}
#[doc = " @brief This structure describes different Physical Layer (PHY) configuration parameters used\n  in RF test and Radio test scenarios. These parameters are specific to testing and evaluating\n  the performance of the radio hardware.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_conf_params {
    #[doc = " Unused. Number of spatial streams supported. Support is there for 1x1 only."]
    pub nss: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub antenna_sel: ::core::ffi::c_uchar,
    #[doc = " An array containing RF & baseband control params"]
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    #[doc = " Not required"]
    pub tx_pkt_chnl_bw: ::core::ffi::c_uchar,
    #[doc = " WLAN packet formats. 0->Legacy 1->HT 2->VHT 3->HE(SU) 4->HE(ERSU) and 5->HE(TB)"]
    pub tx_pkt_tput_mode: ::core::ffi::c_uchar,
    #[doc = " Short Guard enable/disable"]
    pub tx_pkt_sgi: ::core::ffi::c_uchar,
    #[doc = " Not required"]
    pub tx_pkt_nss: ::core::ffi::c_uchar,
    #[doc = " Preamble type. 0->short, 1->Long and 2->Mixed"]
    pub tx_pkt_preamble: ::core::ffi::c_uchar,
    #[doc = " Not used"]
    pub tx_pkt_stbc: ::core::ffi::c_uchar,
    #[doc = " 0->BCC 1->LDPC. Supporting only BCC in nRF7002"]
    pub tx_pkt_fec_coding: ::core::ffi::c_uchar,
    #[doc = " Valid MCS number between 0 to 7"]
    pub tx_pkt_mcs: ::core::ffi::c_schar,
    #[doc = " Legacy rate to be used in Mbps (1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54)"]
    pub tx_pkt_rate: ::core::ffi::c_schar,
    #[doc = " Copy OTP params to this memory"]
    pub phy_threshold: ::core::ffi::c_schar,
    #[doc = " Calibration bit map value. refer NRF_WIFI_DEF_PHY_CALIB"]
    pub phy_calib: ::core::ffi::c_uint,
    #[doc = " Radio test mode or System mode selection"]
    pub op_mode: ::core::ffi::c_int,
    #[doc = " Channel related info viz, channel, bandwidth, primary 20 offset"]
    pub chan: chan_params,
    #[doc = " Value of 0 means continuous transmission.Greater than 1 is invalid"]
    pub tx_mode: ::core::ffi::c_uchar,
    #[doc = " Number of packets to be transmitted. Any number above 0.\n  Set -1 for continuous transmission"]
    pub tx_pkt_num: ::core::ffi::c_int,
    #[doc = " Length of the packet (in bytes) to be transmitted"]
    pub tx_pkt_len: ::core::ffi::c_ushort,
    #[doc = " Desired TX power in dBm in the range 0 dBm to 21 dBm in steps of 1 dBm"]
    pub tx_power: ::core::ffi::c_uint,
    #[doc = " Transmit WLAN packet"]
    pub tx: ::core::ffi::c_uchar,
    #[doc = " Receive WLAN packet"]
    pub rx: ::core::ffi::c_uchar,
    #[doc = "  Not required"]
    pub aux_adc_input_chain_id: ::core::ffi::c_uchar,
    #[doc = "  Unused"]
    pub agg: ::core::ffi::c_uchar,
    #[doc = " Select HE LTF type viz, 0->1x, 1->2x and 2->4x"]
    pub he_ltf: ::core::ffi::c_uchar,
    #[doc = " Select HE LTF type viz, 0->0.8us, 1->1.6us and 2->3.2us"]
    pub he_gi: ::core::ffi::c_uchar,
    #[doc = " Not required"]
    pub set_he_ltf_gi: ::core::ffi::c_uchar,
    #[doc = " Not required"]
    pub power_save: ::core::ffi::c_uchar,
    #[doc = " Not required"]
    pub rts_threshold: ::core::ffi::c_uint,
    #[doc = " Not required"]
    pub uapsd_queue: ::core::ffi::c_uint,
    #[doc = " Interval between TX packets in us (Min: 200, Max: 200000, Default: 200)"]
    pub tx_pkt_gap_us: ::core::ffi::c_uint,
    #[doc = " Configure WLAN antenna switch(0-separate/1-shared)"]
    pub wlan_ant_switch_ctrl: ::core::ffi::c_uchar,
    #[doc = " Switch to control the SR antenna or shared WiFi antenna"]
    pub sr_ant_switch_ctrl: ::core::ffi::c_uchar,
    #[doc = " Resource unit (RU) size (26,52,106 or 242)"]
    pub ru_tone: ::core::ffi::c_uchar,
    #[doc = " Location of resource unit (RU) in 20 MHz spectrum"]
    pub ru_index: ::core::ffi::c_uchar,
    #[doc = " Desired tone frequency to be transmitted"]
    pub tx_tone_freq: ::core::ffi::c_schar,
    #[doc = " RX LNA gain"]
    pub lna_gain: ::core::ffi::c_uchar,
    #[doc = " RX BB gain"]
    pub bb_gain: ::core::ffi::c_uchar,
    #[doc = " Number of RX samples to be captured"]
    pub capture_length: ::core::ffi::c_ushort,
    #[doc = " Capture timeout in seconds"]
    pub capture_timeout: ::core::ffi::c_ushort,
    #[doc = " Configure WLAN to bypass regulatory"]
    pub bypass_regulatory: ::core::ffi::c_uchar,
    #[doc = " Two letter country code (00: Default for WORLD)"]
    pub country_code: [::core::ffi::c_uchar; 2usize],
    #[doc = " Contention window value to be configured"]
    pub tx_pkt_cw: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the command used to configure the RPU with different\n  PHY configuration parameters specifically designed for RF test and Radio test scenarios.\n  The command is intended to set up the RPU for testing and evaluating the performance\n  of the radio hardware.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_mode_params {
    #[doc = " UMAC header, See &struct nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " configuration parameters of different modes see &union rpu_conf_params"]
    pub conf: rpu_conf_params,
    #[doc = " Packet length"]
    pub pkt_length: [::core::ffi::c_ushort; 16usize],
    #[doc = " Packet ddr pointer"]
    pub ddr_ptrs: [::core::ffi::c_uint; 16usize],
}
#[doc = " @brief This structure represents the parameters required to initialize a radio test.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_radio_test_init_info {
    #[doc = " An array containing RF & baseband control params"]
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    #[doc = " Channel related info viz, channel, bandwidth, primary 20 offset"]
    pub chan: chan_params,
    #[doc = " Phy threshold value to be sent to LMAC in channel programming"]
    pub phy_threshold: ::core::ffi::c_schar,
    #[doc = " Calibration bit map value. refer phy_rf_params.h NRF_WIFI_DEF_PHY_CALIB"]
    pub phy_calib: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the command used to initialize a radio test.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_radio_test_init {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " radiotest init configuration parameters @ref nrf_wifi_radio_test_init_info"]
    pub conf: nrf_wifi_radio_test_init_info,
}
#[doc = " @brief This structure defines the command used to enable or disable the reception (Rx).\n  It allows controlling the radio hardware's receive functionality to start or stop listening\n  for incoming data frames."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_rx {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " rx configuration parameters @ref rpu_conf_rx_radio_test_params"]
    pub conf: rpu_conf_rx_radio_test_params,
}
#[doc = " @brief This structure defines the command used to retrieve statistics from the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_get_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Statistics type &enum rpu_stats_type"]
    pub stats_type: ::core::ffi::c_int,
    #[doc = " Production mode or FCM mode"]
    pub op_mode: ::core::ffi::c_int,
}
#[doc = " @brief This structure represents the channel parameters to configure specific channel.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_set_channel {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head."]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Interface index."]
    pub if_index: ::core::ffi::c_uchar,
    #[doc = " channel parameters, @ref chan_params."]
    pub chan: chan_params,
}
#[repr(u32)]
#[doc = " @brief This enum represents different types of operation modes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum wifi_operation_modes {
    #[doc = " STA mode setting enable."]
    NRF_WIFI_STA_MODE = 1,
    #[doc = " Monitor mode setting enable."]
    NRF_WIFI_MONITOR_MODE = 2,
    #[doc = " TX injection mode setting enable."]
    NRF_WIFI_TX_INJECTION_MODE = 4,
    #[doc = " Promiscuous mode setting enable."]
    NRF_WIFI_PROMISCUOUS_MODE = 8,
    #[doc = " AP mode setting enable."]
    NRF_WIFI_AP_MODE = 16,
    #[doc = " STA-AP mode setting enable."]
    NRF_WIFI_STA_AP_MODE = 32,
    #[doc = " Max limit check based on current modes supported."]
    WIFI_MODE_LIMIT_CHK = 47,
}
#[repr(u32)]
#[doc = " @brief This enum represents different types of filters used."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum wifi_packet_filter {
    #[doc = " Support management, data and control packet sniffing."]
    NRF_WIFI_PACKET_FILTER_ALL = 1,
    #[doc = " Support only sniffing of management packets."]
    NRF_WIFI_PACKET_FILTER_MGMT = 2,
    #[doc = " Support only sniffing of data packets."]
    NRF_WIFI_PACKET_FILTER_DATA = 4,
    #[doc = " Support only sniffing of control packets."]
    NRF_WIFI_PACKET_FILTER_CTRL = 8,
}
#[doc = " @brief This structure defines the command used to configure\n  promiscuous mode/Monitor mode/Packet injector mode."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_raw_config_mode {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head."]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Interface index."]
    pub if_index: ::core::ffi::c_uchar,
    #[doc = " Wireless device operating mode."]
    pub op_mode: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines the command used to configure\n  filters and capture length in promiscuous and monitor modes."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_raw_config_filter {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head."]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Interface index."]
    pub if_index: ::core::ffi::c_uchar,
    #[doc = " Wireless device operating mode filters for Promiscuous/Monitor modes."]
    pub filter: ::core::ffi::c_uchar,
    #[doc = " capture length."]
    pub capture_len: ::core::ffi::c_ushort,
}
#[repr(u32)]
#[doc = " @brief This enum represents the queues used to segregate the TX frames depending on\n their QoS categories. A separate queue is used for Beacon frames / frames\n transmitted during DTIM intervals."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum UMAC_QUEUE_NUM {
    #[doc = " Queue for frames belonging to the \"Background\" Access Category."]
    UMAC_AC_BK = 0,
    #[doc = " Queue for frames belonging to the \"Best-Effort\" Access Category."]
    UMAC_AC_BE = 1,
    #[doc = " Queue for frames belonging to the \"Video\" Access Category."]
    UMAC_AC_VI = 2,
    #[doc = " Queue for frames belonging to the \"Voice\" Access Category."]
    UMAC_AC_VO = 3,
    #[doc = " Queue for frames belonging to the \"Beacon\" Access Category."]
    UMAC_AC_BCN = 4,
    #[doc = " Maximum number of transmit queues supported."]
    UMAC_AC_MAX_CNT = 5,
}
#[doc = " @brief This structure defines the raw tx parameters used in packet injector mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_raw_tx_pkt {
    #[doc = " Queue number will be BK, BE, VI, VO and BCN refer UMAC_QUEUE_NUM."]
    pub queue_num: ::core::ffi::c_uchar,
    #[doc = " Descriptor identifier or token identifier."]
    pub desc_num: ::core::ffi::c_uchar,
    #[doc = " Packet lengths of frames."]
    pub pkt_length: ::core::ffi::c_ushort,
    #[doc = " Number of times a packet should be transmitted at each possible rate."]
    pub rate_retries: ::core::ffi::c_uchar,
    #[doc = " refer see &enum rpu_tput_mode."]
    pub rate_flags: ::core::ffi::c_uchar,
    #[doc = " rate: legacy rates: 1,2,55,11,6,9,12,18,24,36,48,54\n\t\t  11N VHT HE  : MCS index 0 to 7."]
    pub rate: ::core::ffi::c_uchar,
    #[doc = " Starting Physical address of each frame in Ext-RAM after dma_mapping."]
    pub frame_ddr_pointer: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the command used to configure packet injector mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_raw_tx {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head."]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Interface index."]
    pub if_index: ::core::ffi::c_uchar,
    #[doc = " Raw tx packet information."]
    pub raw_tx_info: nrf_wifi_raw_tx_pkt,
}
#[repr(u32)]
#[doc = " @brief This enum provides a list of different raw tx offloading types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_offload_rawtx_ctrl_type {
    NRF_WIFI_OFFLOAD_TX_STOP = 0,
    NRF_WIFI_OFFLOAD_TX_START = 1,
    NRF_WIFI_OFFLOAD_TX_CONFIG = 2,
}
#[doc = " @brief This structure defines the offloaded raw tx control information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_offload_ctrl_params {
    #[doc = " Time interval in micro seconds"]
    pub period_in_us: ::core::ffi::c_uint,
    #[doc = " Transmit power in dBm ( 0 to 20)"]
    pub tx_pwr: ::core::ffi::c_int,
    #[doc = " Channel number"]
    pub channel_no: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the offloading raw tx parameters\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_offload_tx_ctrl {
    #[doc = " Packet lengths of frames, min 26 bytes and max 600 bytes"]
    pub pkt_length: ::core::ffi::c_uint,
    #[doc = " Rate preamble type (USE_SHORT_PREAMBLE/DONT_USE_SHORT_PREAMBLE)"]
    pub rate_preamble_type: ::core::ffi::c_uint,
    #[doc = " Number of times a packet should be transmitted at each possible rate"]
    pub rate_retries: ::core::ffi::c_uint,
    #[doc = " Rate: legacy rates: 1,2,55,11,6,9,12,18,24,36,48,54\n \t \t 11N VHT HE: MCS index 0 to 7."]
    pub rate: ::core::ffi::c_uint,
    #[doc = " Refer see &enum rpu_tput_mode"]
    pub rate_flags: ::core::ffi::c_uint,
    #[doc = " HE GI type (NRF_WIFI_HE_GI_800NS/NRF_WIFI_HE_GI_1600NS/NRF_WIFI_HE_GI_3200NS)"]
    pub he_gi_type: ::core::ffi::c_uchar,
    #[doc = " HE LTF (NRF_WIFI_HE_LTF_3200NS/NRF_WIFI_HE_LTF_6400NS/NRF_WIFI_HE_LTF_12800NS)"]
    pub he_ltf: ::core::ffi::c_uchar,
    #[doc = " Payload pointer"]
    pub pkt_ram_ptr: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the command used for  offloading Raw tx\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_offload_raw_tx_params {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Id of the interface"]
    pub wdev_id: ::core::ffi::c_uint,
    #[doc = " Offloaded raw tx control information, @ref nrf_wifi_offload_ctrl_params"]
    pub ctrl_info: nrf_wifi_offload_ctrl_params,
    #[doc = " Offloaded raw tx params, @ref nrf_wifi_offload_tx_ctrl"]
    pub tx_params: nrf_wifi_offload_tx_ctrl,
}
#[doc = " @brief This structure defines the command used for  offloading Raw tx\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_offload_raw_tx_ctrl {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Id of the interface"]
    pub wdev_id: ::core::ffi::c_uint,
    #[doc = " Offloading type @ref nrf_wifi_offload_rawtx_ctrl_type"]
    pub ctrl_type: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines an event that indicates set channel command done.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_set_channel {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head."]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Interface index."]
    pub if_index: ::core::ffi::c_uchar,
    #[doc = " channel number."]
    pub chan_num: ::core::ffi::c_uint,
    #[doc = " status of the set channel command, success(0)/Fail(-1)."]
    pub status: ::core::ffi::c_int,
}
#[doc = " @brief This structure defines an event that indicates set raw config\n mode command done.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_raw_config_mode {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head."]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Interface index."]
    pub if_index: ::core::ffi::c_uchar,
    #[doc = " Operating mode."]
    pub op_mode: ::core::ffi::c_uchar,
    #[doc = " status of the set raw config mode command, success(0)/Fail(-1)."]
    pub status: ::core::ffi::c_int,
}
#[doc = " @brief This structure defines an event that indicates set raw config\n filter command done.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_raw_config_filter {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head."]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Interface index."]
    pub if_index: ::core::ffi::c_uchar,
    #[doc = " mode filter configured."]
    pub filter: ::core::ffi::c_uchar,
    #[doc = " capture len configured."]
    pub capture_len: ::core::ffi::c_ushort,
    #[doc = " status of the set raw filter command, success(0)/Fail(-1)."]
    pub status: ::core::ffi::c_int,
}
#[doc = " @brief This structure defines an event that indicates the Raw tx done.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_raw_tx_done {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head."]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " descriptor number."]
    pub desc_num: ::core::ffi::c_uchar,
    #[doc = " status of the raw tx packet command, success(0)/Fail(-1)."]
    pub status: ::core::ffi::c_int,
}
#[doc = " @brief This structure defines the command used to clear or reset statistics.\n\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_clear_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Type of statistics to clear &enum rpu_stats_type"]
    pub stats_type: ::core::ffi::c_int,
}
#[doc = " @brief This structure represents the command used to obtain power monitor information\n  specific to different data types.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_pwr {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Type of Control info that host need"]
    pub data_type: ::core::ffi::c_int,
}
#[doc = " @brief Structure for coexistence (coex) switch configuration.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct coex_wlan_switch_ctrl {
    #[doc = " Host to coexistence manager message id"]
    pub rpu_msg_id: ::core::ffi::c_int,
    #[doc = " Switch configuration value"]
    pub switch_A: ::core::ffi::c_int,
}
#[doc = " @brief The structure represents the command used to configure the Wi-Fi side shared switch\n  for SR coexistence.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_srcoex {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Switch configuration data"]
    pub conf: coex_wlan_switch_ctrl,
}
#[doc = " @brief The structure defines the parameters used to configure the coexistence hardware.\n"]
#[repr(C, packed)]
pub struct rpu_cmd_coex_config_info {
    #[doc = " Length of coexistence configuration data"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Coexistence configuration data"]
    pub coex_cmd: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[doc = " @brief This structure defines the command used to configure the coexistence hardware.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_cmd_coex_config {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Coexistence configuration data. @ref rpu_cmd_coex_config_info"]
    pub coex_config_info: rpu_cmd_coex_config_info,
}
#[doc = " @brief This structure describes the coexistence configuration data received\n  in the NRF_WIFI_EVENT_COEX_CONFIG event.\n"]
#[repr(C, packed)]
pub struct rpu_evnt_coex_config_info {
    #[doc = " Length of coexistence configuration data"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Coexistence configuration data"]
    pub coex_event: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[doc = " @brief This structure defines the event used to represent coexistence configuration.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_event_coex_config {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " Coexistence configuration data in the event. @ref rpu_evnt_coex_config_info"]
    pub coex_config_info: rpu_evnt_coex_config_info,
}
#[doc = " @brief This structure defines the command used to fix the transmission (Tx) data rate.\n  The command allows setting a specific data rate for data transmission, ensuring that the\n  system uses the designated rate instead of dynamically adapting to changing channel conditions.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_fix_tx_rate {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " refer see &enum rpu_tput_mode"]
    pub rate_flags: ::core::ffi::c_uchar,
    #[doc = " fixed_rate: -1 Disable fixed rate and use ratecontrol selected rate\n  fixed rate: >0 legacy rates: 1,2,55,11,6,9,12,18,24,36,48,54\n\t\t  11N VHT HE  : MCS index 0 to 7."]
    pub fixed_rate: ::core::ffi::c_int,
}
#[doc = " @brief This structure describes rf test command information.\n"]
#[repr(C, packed)]
pub struct rpu_cmd_rftest_info {
    #[doc = " length of the rf test command"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Rf test command data"]
    pub rfcmd: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[doc = " @brief This structure defines the command used for RF (Radio Frequency) testing.\n  RF test commands are specifically designed to configure and control the radio hardware\n  for conducting tests and evaluating its performance in various scenarios.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_cmd_rftest {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " @ref rpu_cmd_rftest_info"]
    pub rf_test_info: rpu_cmd_rftest_info,
}
#[doc = " @brief This structure describes rf test event information.\n"]
#[repr(C, packed)]
pub struct rpu_evnt_rftest_info {
    #[doc = " length of the rf test event"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Rf test event data"]
    pub rfevent: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[doc = " @brief This structure describes the event generated during RF (Radio Frequency) testing.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_event_rftest {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " @ref rpu_evnt_rftest_info"]
    pub rf_test_info: rpu_evnt_rftest_info,
}
#[doc = " @brief This structure is a comprehensive combination of all the firmware statistics\n  that the RPU (Radio Processing Unit) can provide in System mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_sys_fw_stats {
    #[doc = " PHY statistics  @ref rpu_phy_stats"]
    pub phy: rpu_phy_stats,
    #[doc = " LMAC statistics @ref rpu_lmac_stats"]
    pub lmac: rpu_lmac_stats,
    #[doc = " UMAC statistics @ref rpu_umac_stats"]
    pub umac: rpu_umac_stats,
}
#[doc = " @brief This structure is a comprehensive combination of all the firmware statistics\n  that the RPU (Radio Processing Unit) can provide in Radio test mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_rt_fw_stats {
    #[doc = " PHY statistics  @ref rpu_phy_stats"]
    pub phy: rpu_phy_stats,
}
#[doc = " @brief This structure defines the Offloaded raw tx debug statistics.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_off_raw_tx_fw_stats {
    pub offload_raw_tx_state: ::core::ffi::c_uint,
    pub offload_raw_tx_cnt: ::core::ffi::c_uint,
    pub offload_raw_tx_complete_cnt: ::core::ffi::c_uint,
    pub warm_boot_cnt: ::core::ffi::c_uint,
}
#[doc = " @brief This structure represents the event that provides RPU statistics in response\n to the command NRF_WIFI_CMD_GET_STATS in a wireless communication system in System\n mode.\n\n  The NRF_WIFI_CMD_GET_STATS command is used to request various statistics from the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sys_umac_event_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " All the statistics that the firmware can provide @ref rpu_sys_fw_stats"]
    pub fw: rpu_sys_fw_stats,
}
#[doc = " @brief This structure represents the event that provides RPU statistics in response\n to the command NRF_WIFI_CMD_GET_STATS in a wireless communication system in Radio\n test mode.\n\n  The NRF_WIFI_CMD_GET_STATS command is used to request various statistics from the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_rt_umac_event_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " All the statistics that the firmware can provide @ref rpu_rt_fw_stats"]
    pub fw: rpu_rt_fw_stats,
}
#[doc = " @brief This structure represents the event that provides RPU statistics in response\n to the command NRF_WIFI_CMD_GET_STATS in a wireless communication system in Offloaded\n raw TX mode.\n\n  The NRF_WIFI_CMD_GET_STATS command is used to request various statistics from the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_off_raw_tx_umac_event_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " All the statistics that the firmware can provide @ref rpu_off_raw_tx_fw_stats"]
    pub fw: rpu_off_raw_tx_fw_stats,
}
#[repr(u32)]
#[doc = " @brief This enum defines various command status values that can occur\n during radio tests and offloaded raw transmissions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_cmd_status {
    #[doc = " Command success"]
    NRF_WIFI_UMAC_CMD_SUCCESS = 1,
    #[doc = " Invalid channel error"]
    NRF_WIFI_UMAC_INVALID_CHNL = 2,
    #[doc = " Invalid power error wrt configured regulatory domain"]
    NRF_WIFI_UMAC_INVALID_TXPWR = 3,
}
#[doc = " @brief This structure defines an event that indicates the error status values that may occur\n  during a radio test. It serves as a response to the radio test commands.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_err_status {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " status of the command, Fail/success &enum nrf_wifi_radio_test_err_status"]
    pub status: ::core::ffi::c_uint,
}
#[doc = " @brief This structure represents the UMAC initialization done event.\n  The event is sent by the RPU (Radio Processing Unit) in response to\n  the NRF_WIFI_CMD_INIT command, indicating that the RPU initialization\n  process has been completed successfully."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_init_done {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
}
#[doc = " @brief structure for UMAC memory pool information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pool_data_to_host {
    #[doc = " Size of the memory buffer"]
    pub buffer_size: ::core::ffi::c_uint,
    #[doc = " Number of pool items available for the above memory buffer"]
    pub num_pool_items: ::core::ffi::c_uchar,
    #[doc = " Maximum pools allocated at any point of time"]
    pub items_num_max_allocated: ::core::ffi::c_uchar,
    #[doc = " Currently allocated pools"]
    pub items_num_cur_allocated: ::core::ffi::c_uchar,
    #[doc = " Total number of pool allocated"]
    pub items_num_total_allocated: ::core::ffi::c_uint,
    #[doc = " Number of times this memory pool is full"]
    pub items_num_not_allocated: ::core::ffi::c_uint,
}
#[doc = " @brief This structure represents the event that provides UMAC (Upper MAC) internal\n  memory statistics in response to the NRF_WIFI_CMD_UMAC_INT_STATS command.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_int_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
    #[doc = " See @ref pool_data_to_host"]
    pub scratch_dynamic_memory_info: [pool_data_to_host; 56usize],
    #[doc = " See @ref pool_data_to_host"]
    pub retention_dynamic_memory_info: [pool_data_to_host; 56usize],
}
#[doc = " @brief This structure represents the event that indicates the completion of UMAC\n  deinitialization. The RPU sends this event as a response to the NRF_WIFI_CMD_DEINIT\n  command, signaling that the UMAC has been successfully deinitialized."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_deinit_done {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
}
#[doc = " @brief This structure describes the command for reset of interface statistics.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_reset_stats {
    #[doc = " UMAC header, @ref nrf_wifi_sys_head"]
    pub sys_head: nrf_wifi_sys_head,
}
#[repr(u32)]
#[doc = " @brief UMAC data interface commands and events.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_umac_data_commands {
    #[doc = " Unused."]
    NRF_WIFI_CMD_MGMT_BUFF_CONFIG = 0,
    #[doc = " Transmit data packet @ref nrf_wifi_tx_buff"]
    NRF_WIFI_CMD_TX_BUFF = 1,
    #[doc = " TX done event @ref nrf_wifi_tx_buff_done"]
    NRF_WIFI_CMD_TX_BUFF_DONE = 2,
    #[doc = " RX packet event @ref nrf_wifi_rx_buff"]
    NRF_WIFI_CMD_RX_BUFF = 3,
    #[doc = " Event to indicate interface is operational\n  @ref nrf_wifi_data_carrier_state"]
    NRF_WIFI_CMD_CARRIER_ON = 4,
    #[doc = " Event to indicate interface is non-operational\n  @ref nrf_wifi_data_carrier_state"]
    NRF_WIFI_CMD_CARRIER_OFF = 5,
    #[doc = " Event to indicate softap client's power save mode\n  If client is in power save mode, host should start buffering\n  packets until it receives NRF_WIFI_CMD_PS_GET_FRAMES event."]
    NRF_WIFI_CMD_PM_MODE = 6,
    #[doc = " Event to indicate to start sending buffered packets for\n  softap client @ref nrf_wifi_sap_ps_get_frames."]
    NRF_WIFI_CMD_PS_GET_FRAMES = 7,
}
#[doc = " @brief Data interface Command and Event header.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_head {
    #[doc = " Command or Event id see &enum nrf_wifi_umac_data_commands"]
    pub cmd: ::core::ffi::c_uint,
    #[doc = " length"]
    pub len: ::core::ffi::c_uint,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_tx_flags {
    NRF_WIFI_TX_FLAG_TWT_EMERGENCY_TX = -2147483648,
    NRF_WIFI_TX_FLAG_CHKSUM_AVAILABLE = 1073741824,
}
#[doc = " @brief Tx mac80211 header information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tx_mac_hdr_info {
    #[doc = " Unused"]
    pub umac_fill_flags: ::core::ffi::c_int,
    #[doc = " frame control"]
    pub fc: ::core::ffi::c_ushort,
    #[doc = " source Mac header"]
    pub dest: [::core::ffi::c_uchar; 6usize],
    #[doc = " destination Mac address"]
    pub src: [::core::ffi::c_uchar; 6usize],
    #[doc = " Ethernet type"]
    pub etype: ::core::ffi::c_ushort,
    #[doc = " TX flags"]
    pub tx_flags: ::core::ffi::c_uint,
    #[doc = " more frames queued"]
    pub more_data: ::core::ffi::c_uchar,
    #[doc = " End Of Service Period flag(applicable in U-APSD)"]
    pub eosp: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure provides the information of each packet in the tx command.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_buff_info {
    #[doc = " Tx packet length"]
    pub pkt_length: ::core::ffi::c_ushort,
    #[doc = " Tx packet address"]
    pub ddr_ptr: ::core::ffi::c_uint,
}
#[doc = " @brief This structure provides the parameters for the tx command.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_tx_buff {
    #[doc = " Command header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uchar,
    #[doc = " Descriptor id"]
    pub tx_desc_num: ::core::ffi::c_uchar,
    #[doc = " Common mac header for all packets in this command\n  @ref tx_mac_hdr_info"]
    pub mac_hdr_info: tx_mac_hdr_info,
    #[doc = " Pending buffer size at host to encode queue size\n  in qos control field of mac header in TWT enable case"]
    pub pending_buf_size: ::core::ffi::c_uint,
    #[doc = " Number of packets sending in this command"]
    pub num_tx_pkts: ::core::ffi::c_uchar,
    #[doc = " Each packets information @ref nrf_wifi_tx_buff_info"]
    pub tx_buff_info: __IncompleteArrayField<nrf_wifi_tx_buff_info>,
}
#[doc = " @brief This structure represents the Tx done event(NRF_WIFI_CMD_TX_BUFF_DONE).\n"]
#[repr(C, packed)]
pub struct nrf_wifi_tx_buff_done {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Descriptor id"]
    pub tx_desc_num: ::core::ffi::c_uchar,
    #[doc = " Number of packets in this Tx done event"]
    pub num_tx_status_code: ::core::ffi::c_uchar,
    #[doc = " Frame sent time at Phy"]
    pub timestamp_t1: [::core::ffi::c_uchar; 6usize],
    #[doc = " Frame ack received time at Phy"]
    pub timestamp_t4: [::core::ffi::c_uchar; 6usize],
    #[doc = " Status of Tx packet. Maximum of MAX_TX_AGG_SIZE"]
    pub tx_status_code: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(u32)]
#[doc = " @brief This structure defines the type of received packet.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_rx_pkt_type {
    #[doc = " The Rx packet is of type data"]
    NRF_WIFI_RX_PKT_DATA = 0,
    #[doc = " RX packet is beacon or probe response"]
    NRF_WIFI_RX_PKT_BCN_PRB_RSP = 1,
    #[doc = " Raw Rx packet"]
    NRF_WIFI_RAW_RX_PKT = 2,
}
#[doc = " @brief This structure provides information about the parameters in the RX data event.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_rx_buff_info {
    #[doc = " Descriptor id"]
    pub descriptor_id: ::core::ffi::c_ushort,
    #[doc = " Rx packet length"]
    pub rx_pkt_len: ::core::ffi::c_ushort,
    #[doc = " type PKT_TYPE_MPDU/PKT_TYPE_MSDU_WITH_MAC/PKT_TYPE_MSDU"]
    pub pkt_type: ::core::ffi::c_uchar,
    #[doc = " Frame received time at Phy"]
    pub timestamp_t2: [::core::ffi::c_uchar; 6usize],
    #[doc = " Ack sent time at Phy"]
    pub timestamp_t3: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure represents RX data event(NRF_WIFI_CMD_RX_BUFF).\n"]
#[repr(C, packed)]
pub struct nrf_wifi_rx_buff {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Rx packet type. see &enum nrf_wifi_rx_pkt_type"]
    pub rx_pkt_type: ::core::ffi::c_short,
    #[doc = " Refer rpu_tput_mode"]
    pub rate_flags: ::core::ffi::c_uchar,
    #[doc = " Rate: Legacy : 1, 2, 55, 6, 9, 11, 12, 18, 24, 36, 48, 54\n\t\t  11N VHT HE  : MCS index 0 to 7."]
    pub rate: ::core::ffi::c_uchar,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uchar,
    #[doc = " Number of packets in this event"]
    pub rx_pkt_cnt: ::core::ffi::c_uchar,
    #[doc = " Depricated"]
    pub reserved: ::core::ffi::c_uchar,
    #[doc = " MAC header length. Same for all packets in this event"]
    pub mac_header_len: ::core::ffi::c_uchar,
    #[doc = " Frequency on which this packet received"]
    pub frequency: ::core::ffi::c_ushort,
    #[doc = " signal strength"]
    pub signal: ::core::ffi::c_short,
    #[doc = " Information of each packet. @ref nrf_wifi_rx_buff_info"]
    pub rx_buff_info: __IncompleteArrayField<nrf_wifi_rx_buff_info>,
}
#[doc = " @brief This structure provides information about the carrier (interface) state.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_data_carrier_state {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uint,
}
#[doc = " @brief This structure describes an event related to the power save state of the softap's client.\n  When the client is in PS mode (NRF_WIFI_CLIENT_PS_MODE), the host should queue Tx packets.\n  When the client is in wakeup mode (NRF_WIFI_CLIENT_ACTIVE), the host should send all\n  buffered and upcoming Tx packets.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sap_client_pwrsave {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uint,
    #[doc = " state NRF_WIFI_CLIENT_ACTIVE or NRF_WIFI_CLIENT_PS_MODE"]
    pub sta_ps_state: ::core::ffi::c_uchar,
    #[doc = " STA MAC Address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure represents an event that instructs the host to transmit a specific\n  number of frames that host queued when softap's client is in power save mode.\n  This event is primarily used when Softap's client operates in legacy power save mode.\n  In this scenario, the access point (AP) is required to send a single packet for every PS POLL\n  frame it receives from the client. Additionally, this mechanism will also be utilized in\n  UAPSD power save.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sap_ps_get_frames {
    #[doc = " Header @ref nrf_wifi_umac_head"]
    pub umac_head: nrf_wifi_umac_head,
    #[doc = " Interface id"]
    pub wdev_id: ::core::ffi::c_uint,
    #[doc = " STA MAC Address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Number of frames to be transmitted in this service period"]
    pub num_frames: ::core::ffi::c_schar,
}
#[repr(u32)]
#[doc = " @brief The host can send the following commands to the RPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_umac_commands {
    #[doc = " Trigger a new scan nrf_wifi_umac_cmd_scan"]
    NRF_WIFI_UMAC_CMD_TRIGGER_SCAN = 0,
    #[doc = " Request for scan results nrf_wifi_umac_cmd_get_scan_results"]
    NRF_WIFI_UMAC_CMD_GET_SCAN_RESULTS = 1,
    #[doc = " Send authentication request to AP nrf_wifi_umac_cmd_auth"]
    NRF_WIFI_UMAC_CMD_AUTHENTICATE = 2,
    #[doc = " Send associate request to AP nrf_wifi_umac_cmd_assoc"]
    NRF_WIFI_UMAC_CMD_ASSOCIATE = 3,
    #[doc = " Send deauthentication request to AP nrf_wifi_umac_cmd_disconn"]
    NRF_WIFI_UMAC_CMD_DEAUTHENTICATE = 4,
    #[doc = " Set wiphy parameters nrf_wifi_umac_cmd_set_wiphy"]
    NRF_WIFI_UMAC_CMD_SET_WIPHY = 5,
    #[doc = " Add new key nrf_wifi_umac_cmd_key"]
    NRF_WIFI_UMAC_CMD_NEW_KEY = 6,
    #[doc = " Delete key nrf_wifi_umac_cmd_key"]
    NRF_WIFI_UMAC_CMD_DEL_KEY = 7,
    #[doc = " Set default key to use nrf_wifi_umac_cmd_set_key"]
    NRF_WIFI_UMAC_CMD_SET_KEY = 8,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_GET_KEY = 9,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_NEW_BEACON = 10,
    #[doc = " Change the beacon on an AP interface nrf_wifi_umac_cmd_set_beacon"]
    NRF_WIFI_UMAC_CMD_SET_BEACON = 11,
    #[doc = " Set the BSS nrf_wifi_umac_cmd_set_bss"]
    NRF_WIFI_UMAC_CMD_SET_BSS = 12,
    #[doc = " Start soft AP operation on an AP interface nrf_wifi_umac_cmd_start_ap"]
    NRF_WIFI_UMAC_CMD_START_AP = 13,
    #[doc = " Stop soft AP operation nrf_wifi_umac_cmd_stop_ap"]
    NRF_WIFI_UMAC_CMD_STOP_AP = 14,
    #[doc = " Create new interface nrf_wifi_umac_cmd_add_vif"]
    NRF_WIFI_UMAC_CMD_NEW_INTERFACE = 15,
    #[doc = " Change interface configuration nrf_wifi_umac_cmd_chg_vif_attr"]
    NRF_WIFI_UMAC_CMD_SET_INTERFACE = 16,
    #[doc = " Delete interface nrf_wifi_umac_cmd_del_vif"]
    NRF_WIFI_UMAC_CMD_DEL_INTERFACE = 17,
    #[doc = " Change interface flags nrf_wifi_umac_cmd_chg_vif_state"]
    NRF_WIFI_UMAC_CMD_SET_IFFLAGS = 18,
    #[doc = " Add a new station nrf_wifi_umac_cmd_add_sta"]
    NRF_WIFI_UMAC_CMD_NEW_STATION = 19,
    #[doc = " Delete station nrf_wifi_umac_cmd_del_sta"]
    NRF_WIFI_UMAC_CMD_DEL_STATION = 20,
    #[doc = " Change station info nrf_wifi_umac_cmd_chg_sta"]
    NRF_WIFI_UMAC_CMD_SET_STATION = 21,
    #[doc = " Get station info nrf_wifi_umac_cmd_get_sta"]
    NRF_WIFI_UMAC_CMD_GET_STATION = 22,
    #[doc = " Start the P2P device nrf_wifi_cmd_start_p2p"]
    NRF_WIFI_UMAC_CMD_START_P2P_DEVICE = 23,
    #[doc = " Stop the P2P device nrf_wifi_umac_cmd_stop_p2p_dev"]
    NRF_WIFI_UMAC_CMD_STOP_P2P_DEVICE = 24,
    #[doc = " Remain awake on the specified channel nrf_wifi_umac_cmd_remain_on_channel"]
    NRF_WIFI_UMAC_CMD_REMAIN_ON_CHANNEL = 25,
    #[doc = " Cancel a pending ROC duration nrf_wifi_umac_cmd_cancel_remain_on_channel"]
    NRF_WIFI_UMAC_CMD_CANCEL_REMAIN_ON_CHANNEL = 26,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_SET_CHANNEL = 27,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_RADAR_DETECT = 28,
    #[doc = " Whitelist filter based on frame types nrf_wifi_umac_cmd_mgmt_frame_reg"]
    NRF_WIFI_UMAC_CMD_REGISTER_FRAME = 29,
    #[doc = " Send a management frame nrf_wifi_umac_cmd_mgmt_tx"]
    NRF_WIFI_UMAC_CMD_FRAME = 30,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_JOIN_IBSS = 31,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_WIN_STA_CONNECT = 32,
    #[doc = " Power save Enable/Disable nrf_wifi_umac_cmd_set_power_save"]
    NRF_WIFI_UMAC_CMD_SET_POWER_SAVE = 33,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_SET_WOWLAN = 34,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_SUSPEND = 35,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_RESUME = 36,
    #[doc = " QOS map nrf_wifi_umac_cmd_set_qos_map"]
    NRF_WIFI_UMAC_CMD_SET_QOS_MAP = 37,
    #[doc = " Get Channel info nrf_wifi_umac_cmd_get_channel"]
    NRF_WIFI_UMAC_CMD_GET_CHANNEL = 38,
    #[doc = " Get Tx power level nrf_wifi_umac_cmd_get_tx_power"]
    NRF_WIFI_UMAC_CMD_GET_TX_POWER = 39,
    #[doc = " Get interface nrf_wifi_cmd_get_interface"]
    NRF_WIFI_UMAC_CMD_GET_INTERFACE = 40,
    #[doc = " Get Wiphy info nrf_wifi_cmd_get_wiphy"]
    NRF_WIFI_UMAC_CMD_GET_WIPHY = 41,
    #[doc = " Get hardware address nrf_wifi_cmd_get_ifhwaddr"]
    NRF_WIFI_UMAC_CMD_GET_IFHWADDR = 42,
    #[doc = " Set hardware address nrf_wifi_cmd_set_ifhwaddr"]
    NRF_WIFI_UMAC_CMD_SET_IFHWADDR = 43,
    #[doc = " Get regulatory domain nrf_wifi_umac_cmd_get_reg"]
    NRF_WIFI_UMAC_CMD_GET_REG = 44,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_CMD_SET_REG = 45,
    #[doc = " Set regulatory domain  nrf_wifi_cmd_req_set_reg"]
    NRF_WIFI_UMAC_CMD_REQ_SET_REG = 46,
    #[doc = " Config UAPSD nrf_wifi_umac_cmd_config_uapsd"]
    NRF_WIFI_UMAC_CMD_CONFIG_UAPSD = 47,
    #[doc = " Config TWT nrf_wifi_umac_cmd_config_twt"]
    NRF_WIFI_UMAC_CMD_CONFIG_TWT = 48,
    #[doc = " Teardown TWT nrf_wifi_umac_cmd_teardown_twt"]
    NRF_WIFI_UMAC_CMD_TEARDOWN_TWT = 49,
    #[doc = " Abort scan nrf_wifi_umac_cmd_abort_scan"]
    NRF_WIFI_UMAC_CMD_ABORT_SCAN = 50,
    #[doc = " Multicast filter nrf_wifi_umac_cmd_mcast_filter"]
    NRF_WIFI_UMAC_CMD_MCAST_FILTER = 51,
    #[doc = " Change macaddress nrf_wifi_umac_cmd_change_macaddr"]
    NRF_WIFI_UMAC_CMD_CHANGE_MACADDR = 52,
    #[doc = " Set powersave timeout nrf_wifi_umac_cmd_set_power_save_timeout"]
    NRF_WIFI_UMAC_CMD_SET_POWER_SAVE_TIMEOUT = 53,
    #[doc = " Get connection information nrf_wifi_umac_cmd_conn_info"]
    NRF_WIFI_UMAC_CMD_GET_CONNECTION_INFO = 54,
    #[doc = " Get power save information nrf_wifi_umac_cmd_get_power_save_info"]
    NRF_WIFI_UMAC_CMD_GET_POWER_SAVE_INFO = 55,
    #[doc = " Set listen interval nrf_wifi_umac_cmd_set_listen_interval"]
    NRF_WIFI_UMAC_CMD_SET_LISTEN_INTERVAL = 56,
    #[doc = " Configure extended power save nrf_wifi_umac_cmd_config_extended_ps"]
    NRF_WIFI_UMAC_CMD_CONFIG_EXTENDED_PS = 57,
    #[doc = " Configure quiet period nrf_wifi_umac_cmd_config_quiet_period"]
    NRF_WIFI_UMAC_CMD_CONFIG_QUIET_PERIOD = 58,
    #[doc = " Command to specify power save exit strategy"]
    NRF_WIFI_UMAC_CMD_PS_EXIT_STRATEGY = 59,
}
#[repr(u32)]
#[doc = " @brief The host can receive the following events from the RPU.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_umac_events {
    NRF_WIFI_UMAC_EVENT_UNSPECIFIED = 256,
    #[doc = " Indicate scan started nrf_wifi_umac_event_trigger_scan"]
    NRF_WIFI_UMAC_EVENT_TRIGGER_SCAN_START = 257,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_SCAN_ABORTED = 258,
    #[doc = " Indicate scan done nrf_wifi_umac_event_scan_done"]
    NRF_WIFI_UMAC_EVENT_SCAN_DONE = 259,
    #[doc = " Scan result event nrf_wifi_umac_event_new_scan_results"]
    NRF_WIFI_UMAC_EVENT_SCAN_RESULT = 260,
    #[doc = " Authentication status nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_AUTHENTICATE = 261,
    #[doc = " Association status nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_ASSOCIATE = 262,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_CONNECT = 263,
    #[doc = " Station deauth event nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_DEAUTHENTICATE = 264,
    #[doc = " Station disassoc event nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_DISASSOCIATE = 265,
    #[doc = " Station added indication nrf_wifi_umac_event_new_station"]
    NRF_WIFI_UMAC_EVENT_NEW_STATION = 266,
    #[doc = " Station added indication nrf_wifi_umac_event_new_station"]
    NRF_WIFI_UMAC_EVENT_DEL_STATION = 267,
    #[doc = " Station info indication nrf_wifi_umac_event_new_station"]
    NRF_WIFI_UMAC_EVENT_GET_STATION = 268,
    #[doc = " remain on channel event nrf_wifi_event_remain_on_channel"]
    NRF_WIFI_UMAC_EVENT_REMAIN_ON_CHANNEL = 269,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_CANCEL_REMAIN_ON_CHANNEL = 270,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_DISCONNECT = 271,
    #[doc = " RX management frame nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_FRAME = 272,
    #[doc = " Cookie mapping for NRF_WIFI_UMAC_CMD_FRAME nrf_wifi_umac_event_cookie_rsp"]
    NRF_WIFI_UMAC_EVENT_COOKIE_RESP = 273,
    #[doc = " TX management frame transmitted nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_FRAME_TX_STATUS = 274,
    #[doc = " nrf_wifi_umac_event_vif_state"]
    NRF_WIFI_UMAC_EVENT_IFFLAGS_STATUS = 275,
    #[doc = " Send Tx power nrf_wifi_umac_event_get_tx_power"]
    NRF_WIFI_UMAC_EVENT_GET_TX_POWER = 276,
    #[doc = " Send Channel info nrf_wifi_umac_event_get_channel"]
    NRF_WIFI_UMAC_EVENT_GET_CHANNEL = 277,
    #[doc = " nrf_wifi_umac_event_set_interface"]
    NRF_WIFI_UMAC_EVENT_SET_INTERFACE = 278,
    #[doc = " nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_UNPROT_DEAUTHENTICATE = 279,
    #[doc = " nrf_wifi_umac_event_mlme"]
    NRF_WIFI_UMAC_EVENT_UNPROT_DISASSOCIATE = 280,
    #[doc = " nrf_wifi_interface_info"]
    NRF_WIFI_UMAC_EVENT_NEW_INTERFACE = 281,
    #[doc = " nrf_wifi_event_get_wiphy"]
    NRF_WIFI_UMAC_EVENT_NEW_WIPHY = 282,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_GET_IFHWADDR = 283,
    #[doc = " Get regulatory nrf_wifi_reg"]
    NRF_WIFI_UMAC_EVENT_GET_REG = 284,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_SET_REG = 285,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_REQ_SET_REG = 286,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_GET_KEY = 287,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_BEACON_HINT = 288,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_REG_CHANGE = 289,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_WIPHY_REG_CHANGE = 290,
    #[doc = " Display scan result nrf_wifi_umac_event_new_scan_display_results"]
    NRF_WIFI_UMAC_EVENT_SCAN_DISPLAY_RESULT = 291,
    #[doc = " nrf_wifi_umac_event_cmd_status"]
    NRF_WIFI_UMAC_EVENT_CMD_STATUS = 292,
    #[doc = " nrf_wifi_umac_event_new_scan_results"]
    NRF_WIFI_UMAC_EVENT_BSS_INFO = 293,
    #[doc = " Send TWT response information nrf_wifi_umac_cmd_config_twt"]
    NRF_WIFI_UMAC_EVENT_CONFIG_TWT = 294,
    #[doc = " Send TWT teardown information nrf_wifi_umac_cmd_teardown_twt"]
    NRF_WIFI_UMAC_EVENT_TEARDOWN_TWT = 295,
    #[doc = " Send block or unblock state nrf_wifi_umac_event_twt_sleep"]
    NRF_WIFI_UMAC_EVENT_TWT_SLEEP = 296,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_COALESCING = 297,
    #[doc = " Unused"]
    NRF_WIFI_UMAC_EVENT_MCAST_FILTER = 298,
    #[doc = " send connection information nrf_wifi_umac_event_conn_info."]
    NRF_WIFI_UMAC_EVENT_GET_CONNECTION_INFO = 299,
    #[doc = " nrf_wifi_umac_event_power_save_info"]
    NRF_WIFI_UMAC_EVENT_GET_POWER_SAVE_INFO = 300,
}
#[repr(u32)]
#[doc = " @brief Represents the values that can be used to specify the frequency band.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_band {
    #[doc = " 2.4 GHz ISM band"]
    NRF_WIFI_BAND_2GHZ = 0,
    #[doc = " Around 5 GHz band (4.9 - 5.7 GHz)"]
    NRF_WIFI_BAND_5GHZ = 1,
    #[doc = " Unused"]
    NRF_WIFI_BAND_60GHZ = 2,
    #[doc = " Invalid"]
    NRF_WIFI_BAND_INVALID = 3,
}
#[repr(u32)]
#[doc = " @brief Enable or Disable Management Frame Protection.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_mfp {
    #[doc = " Management frame protection not used"]
    NRF_WIFI_MFP_NO = 0,
    #[doc = " Management frame protection required"]
    NRF_WIFI_MFP_REQUIRED = 1,
}
#[repr(u32)]
#[doc = " @brief Enumerates the various categories of security keys.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_key_type {
    #[doc = " Group (broadcast/multicast) key"]
    NRF_WIFI_KEYTYPE_GROUP = 0,
    #[doc = " Pairwise (unicast/individual) key"]
    NRF_WIFI_KEYTYPE_PAIRWISE = 1,
    #[doc = " Peer key (DLS)"]
    NRF_WIFI_KEYTYPE_PEERKEY = 2,
    #[doc = " Number of defined key types"]
    NUM_NRF_WIFI_KEYTYPES = 3,
}
impl nrf_wifi_auth_type {
    pub const NRF_WIFI_AUTHTYPE_MAX: nrf_wifi_auth_type = nrf_wifi_auth_type::__NRF_WIFI_AUTHTYPE_NUM;
}
#[repr(u32)]
#[doc = " @brief Enumerates the various types of authentication mechanisms.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_auth_type {
    #[doc = " Open System authentication"]
    NRF_WIFI_AUTHTYPE_OPEN_SYSTEM = 0,
    #[doc = " Shared Key authentication (WEP only)"]
    NRF_WIFI_AUTHTYPE_SHARED_KEY = 1,
    #[doc = " Fast BSS Transition (IEEE 802.11r)"]
    NRF_WIFI_AUTHTYPE_FT = 2,
    #[doc = " Network EAP (some Cisco APs and mainly LEAP)"]
    NRF_WIFI_AUTHTYPE_NETWORK_EAP = 3,
    #[doc = " Simultaneous authentication of equals"]
    NRF_WIFI_AUTHTYPE_SAE = 4,
    #[doc = " Internal"]
    __NRF_WIFI_AUTHTYPE_NUM = 5,
    #[doc = " Determine automatically (if necessary by trying multiple times)"]
    NRF_WIFI_AUTHTYPE_AUTOMATIC = 6,
}
#[repr(u32)]
#[doc = " @brief Represents the interface's status concerning this BSS (Basic Service Set).\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_bss_status {
    #[doc = " Authenticated with this BSS\n Note that this is no longer used since cfg80211 no longer\n keeps track of whether or not authentication was done with\n a given BSS."]
    NRF_WIFI_BSS_STATUS_AUTHENTICATED = 0,
    #[doc = " Associated with this BSS"]
    NRF_WIFI_BSS_STATUS_ASSOCIATED = 1,
    #[doc = " Joined to this IBSS"]
    NRF_WIFI_BSS_STATUS_IBSS_JOINED = 2,
}
#[repr(u32)]
#[doc = " @brief Enumerates the various categories of channels.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_channel_type {
    #[doc = " 20 MHz, non-HT channel"]
    NRF_WIFI_CHAN_NO_HT = 0,
    #[doc = " 20 MHz HT channel"]
    NRF_WIFI_CHAN_HT20 = 1,
    #[doc = " HT40 channel, secondary channel below the control channel"]
    NRF_WIFI_CHAN_HT40MINUS = 2,
    #[doc = " HT40 channel, secondary channel above the control channel"]
    NRF_WIFI_CHAN_HT40PLUS = 3,
}
#[repr(u32)]
#[doc = " @brief Enumerates the various channel widths available.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_chan_width {
    #[doc = " 20 MHz, non-HT channel"]
    NRF_WIFI_CHAN_WIDTH_20_NOHT = 0,
    #[doc = " 20 MHz HT channel"]
    NRF_WIFI_CHAN_WIDTH_20 = 1,
    #[doc = " 40 MHz channel, the NRF_WIFI_ATTR_CENTER_FREQ1 must be provided as well"]
    NRF_WIFI_CHAN_WIDTH_40 = 2,
    #[doc = " 80 MHz channel, the NRF_WIFI_ATTR_CENTER_FREQ1 must be provided as well"]
    NRF_WIFI_CHAN_WIDTH_80 = 3,
    #[doc = " 80+80 MHz channel, the NRF_WIFI_ATTR_CENTER_FREQ1 and\n  NRF_WIFI_ATTR_CENTER_FREQ2 must be provided as well"]
    NRF_WIFI_CHAN_WIDTH_80P80 = 4,
    #[doc = " 160 MHz channel, the NRF_WIFI_ATTR_CENTER_FREQ1 must be provided as well"]
    NRF_WIFI_CHAN_WIDTH_160 = 5,
    #[doc = "  5 MHz OFDM channel"]
    NRF_WIFI_CHAN_WIDTH_5 = 6,
    #[doc = " 10 MHz OFDM channel"]
    NRF_WIFI_CHAN_WIDTH_10 = 7,
}
impl nrf_wifi_iftype {
    pub const NRF_WIFI_IFTYPE_MAX: nrf_wifi_iftype = nrf_wifi_iftype::NRF_WIFI_STA_PROMISC_TX_INJECTOR;
}
#[repr(u32)]
#[doc = " @brief Interface types based on functionality.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_iftype {
    #[doc = " Unspecified type, driver decides"]
    NRF_WIFI_IFTYPE_UNSPECIFIED = 0,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_ADHOC = 1,
    #[doc = " Managed BSS member"]
    NRF_WIFI_IFTYPE_STATION = 2,
    #[doc = " Access point"]
    NRF_WIFI_IFTYPE_AP = 3,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_AP_VLAN = 4,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_WDS = 5,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_MONITOR = 6,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_MESH_POINT = 7,
    #[doc = " P2P client"]
    NRF_WIFI_IFTYPE_P2P_CLIENT = 8,
    #[doc = " P2P group owner"]
    NRF_WIFI_IFTYPE_P2P_GO = 9,
    #[doc = " P2P device use the NRF_WIFI_UMAC_CMD_START_P2P_DEVICE &\n  NRF_WIFI_UMAC_CMD_STOP_P2P_DEVICE commands to create and destroy one"]
    NRF_WIFI_IFTYPE_P2P_DEVICE = 10,
    #[doc = " Not Supported"]
    NRF_WIFI_IFTYPE_OCB = 11,
    #[doc = " Tx Packet injector mode."]
    NRF_WIFI_TX_INJECTOR = 12,
    #[doc = " Station + Tx Packet injector mode."]
    NRF_WIFI_STA_TX_INJECTOR = 13,
    #[doc = " Monitor + Tx Packet injector mode."]
    NRF_WIFI_MONITOR_TX_INJECTOR = 14,
    #[doc = " Station + Promiscuous mode."]
    NRF_WIFI_STA_PROMISC = 15,
    #[doc = " Station + Promiscuous mode + TX Packet injector."]
    NRF_WIFI_STA_PROMISC_TX_INJECTOR = 16,
    #[doc = " Highest interface type number currently defined"]
    NUM_NRF_WIFI_IFTYPES = 17,
}
#[repr(u32)]
#[doc = " @brief Powersave state.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_ps_state {
    #[doc = " powersave is disabled"]
    NRF_WIFI_PS_DISABLED = 0,
    #[doc = " powersave is enabled"]
    NRF_WIFI_PS_ENABLED = 1,
}
#[repr(u32)]
#[doc = " @brief WLAN security types.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_security_type {
    #[doc = " OPEN"]
    NRF_WIFI_OPEN = 0,
    #[doc = " WEP"]
    NRF_WIFI_WEP = 1,
    #[doc = " WPA"]
    NRF_WIFI_WPA = 2,
    #[doc = " WPA2"]
    NRF_WIFI_WPA2 = 3,
    #[doc = " WAPI"]
    NRF_WIFI_WAPI = 4,
    #[doc = " Enterprise mode"]
    NRF_WIFI_EAP = 5,
    #[doc = " FT 8021X"]
    NRF_WIFI_FT_EAP = 6,
    #[doc = " Enterprise tls SHA256"]
    NRF_WIFI_EAP_TLS_SHA256 = 7,
    #[doc = " WPA2 SHA256"]
    NRF_WIFI_WPA2_256 = 8,
    #[doc = " WPA3"]
    NRF_WIFI_WPA3 = 9,
    #[doc = " 8021X SUITE-B SHA256"]
    NRF_WIFI_EAP_SUITEB_SHA256 = 10,
    #[doc = " 8021X SUITE-B SHA384"]
    NRF_WIFI_EAP_SUITEB_SHA384 = 11,
    #[doc = " FT 8021X SHA384"]
    NRF_WIFI_FT_EAP_SHA384 = 12,
    #[doc = " FT PSK SHA384"]
    NRF_WIFI_FT_PSK_SHA384 = 13,
    #[doc = " PSK SHA384"]
    NRF_WIFI_PSK_SHA384 = 14,
}
#[repr(u32)]
#[doc = " @brief Denotes the originator of a regulatory domain request.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_reg_initiator {
    #[doc = " Core queried CRDA for a dynamic world regulatory domain"]
    NRF_WIFI_REGDOM_SET_BY_CORE = 0,
    #[doc = " User asked the wireless core to set the regulatory domain"]
    NRF_WIFI_REGDOM_SET_BY_USER = 1,
    #[doc = " A wireless drivers has hinted to the wireless core it thinks\n its knows the regulatory domain we should be in"]
    NRF_WIFI_REGDOM_SET_BY_DRIVER = 2,
    #[doc = " the wireless core has received an\n 802.11 country information element with regulatory information it\n thinks we should consider. cfg80211 only processes the country\n code from the IE, and relies on the regulatory domain information\n structure passed by userspace (CRDA) from our wireless-regdb\n If a channel is enabled but the country code indicates it should\n be disabled we disable the channel and re-enable it upon disassociation"]
    NRF_WIFI_REGDOM_SET_BY_COUNTRY_IE = 3,
}
#[repr(u32)]
#[doc = " @brief Specifies the type of regulatory domain.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_reg_type {
    #[doc = " the regulatory domain set is one that pertains\n to a specific country. When this is set you can count on the\n ISO / IEC 3166 alpha2 country code being valid.\n"]
    NRF_WIFI_REGDOM_TYPE_COUNTRY = 0,
    #[doc = " the regulatory set domain is the world regulatory domain"]
    NRF_WIFI_REGDOM_TYPE_WORLD = 1,
    #[doc = " the regulatory domain set is a custom\n driver specific world regulatory domain. These do not apply system-wide\n and are only applicable to the individual devices which have requested\n them to be applied."]
    NRF_WIFI_REGDOM_TYPE_CUSTOM_WORLD = 2,
    #[doc = " the regulatory domain set is the product\n of an intersection between two regulatory domains -- the previously\n set regulatory domain on the system and the last accepted regulatory\n domain request to be processed."]
    NRF_WIFI_REGDOM_TYPE_INTERSECTION = 3,
}
#[doc = " @brief This structure provides details about the SSID.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_ssid {
    #[doc = " length of SSID"]
    pub nrf_wifi_ssid_len: ::core::ffi::c_uchar,
    #[doc = " SSID string"]
    pub nrf_wifi_ssid: [::core::ffi::c_uchar; 32usize],
}
#[doc = " @brief This structure contains data related to the Information Elements (IEs).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_ie {
    #[doc = " length of IE"]
    pub ie_len: ::core::ffi::c_ushort,
    #[doc = " Information element data"]
    pub ie: [::core::ffi::c_schar; 400usize],
}
#[doc = " @brief Transmit key sequence number.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_seq {
    #[doc = " Length of the seq parameter"]
    pub nrf_wifi_seq_len: ::core::ffi::c_int,
    #[doc = " Key sequence number data"]
    pub nrf_wifi_seq: [::core::ffi::c_uchar; 256usize],
}
#[doc = " @brief This structure holds information related to a security key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_key {
    #[doc = " Length of the key data"]
    pub nrf_wifi_key_len: ::core::ffi::c_uint,
    #[doc = " Key data"]
    pub nrf_wifi_key: [::core::ffi::c_uchar; 256usize],
}
#[doc = " @brief This structure represents SAE elements in Authentication frame.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sae {
    #[doc = " Length of SAE element data"]
    pub sae_data_len: ::core::ffi::c_int,
    #[doc = " SAE element data"]
    pub sae_data: [::core::ffi::c_uchar; 256usize],
}
#[doc = " @brief This structure defines the frame that is intended for transmission.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_frame {
    #[doc = " Length of the frame"]
    pub frame_len: ::core::ffi::c_int,
    #[doc = " frame data"]
    pub frame: [::core::ffi::c_schar; 400usize],
}
#[doc = " @brief This structure contains details about the interface information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_index_ids {
    #[doc = " Indicate which properties below are set"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " wdev id"]
    pub ifaceindex: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub nrf_wifi_wiphy_idx: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub wdev_id: ::core::ffi::c_ulonglong,
}
#[doc = " @brief This structure provides information about the rate parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_supp_rates {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Frequency band, see &enum nrf_wifi_band"]
    pub band: ::core::ffi::c_int,
    #[doc = " Number of values in rates parameter"]
    pub nrf_wifi_num_rates: ::core::ffi::c_int,
    #[doc = " List of supported rates as defined by IEEE 802.11 7.3.2.2"]
    pub rates: [::core::ffi::c_uchar; 60usize],
}
#[doc = " @brief This structure contains details about a channel's information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_channel {
    #[doc = " band this channel belongs to"]
    pub band: ::core::ffi::c_int,
    #[doc = " center frequency in MHz"]
    pub center_frequency: ::core::ffi::c_uint,
    #[doc = " channel flags from see &enum nrf_wifi_channel_flags"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " maximum antenna gain in dBi"]
    pub nrf_wifi_max_antenna_gain: ::core::ffi::c_int,
    #[doc = " maximum transmission power (in dBm)"]
    pub nrf_wifi_max_power: ::core::ffi::c_int,
    #[doc = " maximum regulatory transmission power (in dBm)"]
    pub nrf_wifi_max_reg_power: ::core::ffi::c_int,
    #[doc = " channel flags at registration time, used by regulatory\n  code to support devices with additional restrictions"]
    pub nrf_wifi_orig_flags: ::core::ffi::c_uint,
    #[doc = " internal use"]
    pub nrf_wifi_orig_mag: ::core::ffi::c_int,
    #[doc = " internal use"]
    pub nrf_wifi_orig_mpwr: ::core::ffi::c_int,
    #[doc = " hardware-specific value for the channel"]
    pub hw_value: ::core::ffi::c_ushort,
    #[doc = " helper to regulatory code to indicate when a beacon\n  has been found on this channel. Use regulatory_hint_found_beacon()\n  to enable this, this is useful only on 5 GHz band."]
    pub nrf_wifi_beacon_found: ::core::ffi::c_schar,
}
#[doc = " @brief This structure provides details about the parameters required for a scan request.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_scan_params {
    #[doc = " If 0x1, RPU force passive scan on all channels"]
    pub passive_scan: ::core::ffi::c_ushort,
    #[doc = " Number of ssid's in scan_ssids parameter"]
    pub num_scan_ssids: ::core::ffi::c_uchar,
    #[doc = " Specific SSID's to scan for"]
    pub scan_ssids: [nrf_wifi_ssid; 2usize],
    #[doc = " used to send probe requests at non CCK rate in 2GHz band"]
    pub no_cck: ::core::ffi::c_uchar,
    #[doc = "  Bitmap of bands to be scanned. Value Zero will scan both 2.4 and 5 GHZ"]
    pub bands: ::core::ffi::c_uchar,
    #[doc = " Information element(s) data nrf_wifi_ie"]
    pub ie: nrf_wifi_ie,
    #[doc = " MAC address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Max scan duration in active scan. If zero rpu programs 50msec"]
    pub dwell_time_active: ::core::ffi::c_ushort,
    #[doc = " Max scan duration in passive scan. If zero rpu programs 150msec"]
    pub dwell_time_passive: ::core::ffi::c_ushort,
    #[doc = " Number of channels to be scanned"]
    pub num_scan_channels: ::core::ffi::c_ushort,
    #[doc = " If true, skip local and IANA Unicast reserved MACs"]
    pub skip_local_admin_macs: ::core::ffi::c_uchar,
    #[doc = " specific channels to be scanned"]
    pub center_frequency: __IncompleteArrayField<::core::ffi::c_uint>,
}
#[doc = " @brief This structure contains specific information about the VHT (Very High Throughput)\n  and HT ((High Throughput)) capabilities.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_ht_vht_capabilities {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Indicate which capabilities have been specified"]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " HT Capability information element (from association request when\n  used with NRF_WIFI_UMAC_CMD_NEW_STATION)."]
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " Specify which bits of the ht_capability are masked"]
    pub ht_capability_mask: [::core::ffi::c_uchar; 256usize],
    #[doc = " VHT Capability information element"]
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " Specify which bits in vht_capability to which attention should be paid"]
    pub vht_capability_mask: [::core::ffi::c_uchar; 256usize],
}
#[doc = " @brief This structure represents information related to the signal strength.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct nrf_wifi_signal {
    #[doc = " MBM or unspecified"]
    pub signal_type: ::core::ffi::c_uint,
    pub signal: nrf_wifi_signal__bindgen_ty_1,
}
#[doc = " signal"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union nrf_wifi_signal__bindgen_ty_1 {
    #[doc = " If MBM signal strength of probe response/beacon\n  in mBm (100 * dBm) (s32)"]
    pub mbm_signal: ::core::ffi::c_uint,
    #[doc = " If unspecified signal strength of the probe response/beacon\n  in unspecified units, scaled to 0..100 (u8)."]
    pub unspec_signal: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure contains parameters related to the connection.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_connect_common_info {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Frequency of the selected channel in MHz"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Frequency of the recommended initial BSS"]
    pub freq_hint: ::core::ffi::c_uint,
    #[doc = " Indicates which WPA version(s)"]
    pub wpa_versions: ::core::ffi::c_uint,
    #[doc = " Number of pairwise cipher suites"]
    pub num_cipher_suites_pairwise: ::core::ffi::c_int,
    #[doc = " For crypto settings, indicates which pairwise cipher suites are used"]
    pub cipher_suites_pairwise: [::core::ffi::c_uint; 7usize],
    #[doc = " For crypto settings, indicates which group cipher suite is used"]
    pub cipher_suite_group: ::core::ffi::c_uint,
    #[doc = " Number of groupwise cipher suites"]
    pub num_akm_suites: ::core::ffi::c_uint,
    #[doc = " Indicate which key management algorithm(s) to use"]
    pub akm_suites: [::core::ffi::c_uint; 2usize],
    #[doc = " Whether management frame protection (IEEE 802.11w) is used for the association"]
    pub use_mfp: ::core::ffi::c_int,
    #[doc = " Flag for indicating whether the current connection\n  shall support Radio Resource Measurements (11k)"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " Background scan period in seconds or 0 to disable background scan"]
    pub bg_scan_period: ::core::ffi::c_ushort,
    #[doc = " MAC address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " MAC address recommendation as initial BSS"]
    pub mac_addr_hint: [::core::ffi::c_uchar; 6usize],
    #[doc = " SSID (binary attribute, 0..32 octets)"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " IE's nrf_wifi_ie"]
    pub wpa_ie: nrf_wifi_ie,
    #[doc = " VHT Capability information element nrf_wifi_ht_vht_capabilities"]
    pub ht_vht_capabilities: nrf_wifi_ht_vht_capabilities,
    #[doc = " A 16-bit value indicating the ethertype that will be used for key negotiation.\n  If it is not specified, the value defaults to 0x888E."]
    pub control_port_ether_type: ::core::ffi::c_ushort,
    #[doc = " When included along with control_port_ether_type, indicates that the custom\n  ethertype frames used for key negotiation must not be encrypted."]
    pub control_port_no_encrypt: ::core::ffi::c_uchar,
    #[doc = " Indicating whether user space controls IEEE 802.1X port, If set, the RPU will\n  assume that the port is unauthorized until authorized by user space.\n  Otherwise, port is marked authorized by default in station mode."]
    pub control_port: ::core::ffi::c_schar,
    #[doc = " previous BSSID, used to specify a request to reassociate\n  within an ESS that is, to use Reassociate Request frame (with the value of\n  this attribute in the Current AP address field) instead of Association\n  Request frame which is used for the initial association to an ESS."]
    pub prev_bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = " Bss max idle timeout value in sec which will be encapsulated into\n  BSS MAX IDLE IE in assoc request frame."]
    pub maxidle_insec: ::core::ffi::c_ushort,
}
#[doc = " @brief This structure provides information about beacon and probe data.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_beacon_data {
    #[doc = " length of head"]
    pub head_len: ::core::ffi::c_uint,
    #[doc = " length of tail"]
    pub tail_len: ::core::ffi::c_uint,
    #[doc = " length of probe response template (probe_resp)"]
    pub probe_resp_len: ::core::ffi::c_uint,
    #[doc = "  head portion of beacon (before TIM IE) or %NULL if not changed"]
    pub head: [::core::ffi::c_uchar; 256usize],
    #[doc = " tail portion of beacon (after TIM IE) or %NULL if not changed"]
    pub tail: [::core::ffi::c_uchar; 512usize],
    #[doc = " probe response template"]
    pub probe_resp: [::core::ffi::c_uchar; 400usize],
}
#[doc = " @brief This structure provides information regarding station flags.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sta_flag_update {
    #[doc = " Mask of station flags to set"]
    pub nrf_wifi_mask: ::core::ffi::c_uint,
    #[doc = " Values to set them to. NRF_WIFI_STA_FLAG_AUTHORIZED"]
    pub nrf_wifi_set: ::core::ffi::c_uint,
}
#[doc = " @brief This structure contains information about rate parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_rate_info {
    #[doc = " Valid fields with in this structure"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " bitrate"]
    pub bitrate: ::core::ffi::c_uint,
    #[doc = " Bitrate compatible"]
    pub bitrate_compat: ::core::ffi::c_ushort,
    #[doc = " Modulation and Coding Scheme(MCS)"]
    pub nrf_wifi_mcs: ::core::ffi::c_uchar,
    #[doc = " MCS related to VHT"]
    pub vht_mcs: ::core::ffi::c_uchar,
    #[doc = " NSS related to VHT"]
    pub vht_nss: ::core::ffi::c_uchar,
    #[doc = " Rate flags NRF_WIFI_RATE_INFO_0_MHZ_WIDTH"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
}
#[doc = " @brief This structure provides information about the Basic Service Set (BSS)\n  parameters for the attached station.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sta_bss_parameters {
    #[doc = " bitfields of flags NRF_WIFI_BSS_PARAM_FLAGS_CTS_PROT"]
    pub nrf_wifi_flags: ::core::ffi::c_uchar,
    #[doc = " DTIM period for the BSS"]
    pub dtim_period: ::core::ffi::c_uchar,
    #[doc = " beacon interval"]
    pub beacon_interval: ::core::ffi::c_ushort,
}
#[doc = " @brief This structure contains information about a Station (STA).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sta_info {
    #[doc = " Valid fields with in this structure"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " time since the station is last connected"]
    pub connected_time: ::core::ffi::c_uint,
    #[doc = " time since last activity, in msec"]
    pub inactive_time: ::core::ffi::c_uint,
    #[doc = " total received bytes from this station"]
    pub rx_bytes: ::core::ffi::c_uint,
    #[doc = " total transmitted bytes to this station"]
    pub tx_bytes: ::core::ffi::c_uint,
    #[doc = " per-chain signal mask value"]
    pub chain_signal_mask: ::core::ffi::c_uint,
    #[doc = " per-chain signal strength of last PPDU"]
    pub chain_signal: [::core::ffi::c_uchar; 4usize],
    #[doc = " per-chain signal strength average mask value"]
    pub chain_signal_avg_mask: ::core::ffi::c_uint,
    #[doc = " per-chain signal strength average"]
    pub chain_signal_avg: [::core::ffi::c_uchar; 4usize],
    #[doc = "nrf_wifi_rate_info"]
    pub tx_bitrate: nrf_wifi_rate_info,
    #[doc = "nrf_wifi_rate_info"]
    pub rx_bitrate: nrf_wifi_rate_info,
    #[doc = " Not used"]
    pub llid: ::core::ffi::c_ushort,
    #[doc = " Not used"]
    pub plid: ::core::ffi::c_ushort,
    #[doc = " Not used"]
    pub plink_state: ::core::ffi::c_uchar,
    #[doc = " signal strength of last received PPDU, in dbm"]
    pub signal: ::core::ffi::c_int,
    #[doc = " signal strength average, in dbm"]
    pub signal_avg: ::core::ffi::c_int,
    #[doc = " total received packet from this station"]
    pub rx_packets: ::core::ffi::c_uint,
    #[doc = " total transmitted packets to this station"]
    pub tx_packets: ::core::ffi::c_uint,
    #[doc = " total retries to this station"]
    pub tx_retries: ::core::ffi::c_uint,
    #[doc = " total failed packets to this station"]
    pub tx_failed: ::core::ffi::c_uint,
    #[doc = " expected throughput in kbps"]
    pub expected_throughput: ::core::ffi::c_uint,
    #[doc = " count of times beacon loss was detected"]
    pub beacon_loss_count: ::core::ffi::c_uint,
    #[doc = " Not used"]
    pub local_pm: ::core::ffi::c_uint,
    #[doc = " Not used"]
    pub peer_pm: ::core::ffi::c_uint,
    #[doc = " Not used"]
    pub nonpeer_pm: ::core::ffi::c_uint,
    #[doc = " station flags nrf_wifi_sta_flag_update"]
    pub sta_flags: nrf_wifi_sta_flag_update,
    #[doc = " timing offset with respect to this STA"]
    pub t_offset: ::core::ffi::c_ulonglong,
    #[doc = " count of times other(non beacon) loss was detected"]
    pub rx_dropped_misc: ::core::ffi::c_ulonglong,
    #[doc = " count of times beacon"]
    pub rx_beacon: ::core::ffi::c_ulonglong,
    #[doc = " average of beacon signal"]
    pub rx_beacon_signal_avg: ::core::ffi::c_longlong,
    #[doc = " Station connected BSS params. nrf_wifi_sta_bss_parameters"]
    pub bss_param: nrf_wifi_sta_bss_parameters,
}
#[doc = " @brief The command header expected by UMAC to handle requests from the control interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_hdr {
    #[doc = " unused"]
    pub portid: ::core::ffi::c_uint,
    #[doc = " unused"]
    pub seq: ::core::ffi::c_uint,
    #[doc = " UMAC command/event value see &enum nrf_wifi_umac_commands\n  see &enum nrf_wifi_umac_events"]
    pub cmd_evnt: ::core::ffi::c_uint,
    #[doc = " unused"]
    pub rpu_ret_val: ::core::ffi::c_int,
    #[doc = " Interface information nrf_wifi_index_ids"]
    pub ids: nrf_wifi_index_ids,
}
#[doc = " @brief This structure contains information about a security key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_key_info {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Key cipher suite (as defined by IEEE 802.11 section 7.3.2.25.1)"]
    pub cipher_suite: ::core::ffi::c_uint,
    #[doc = " Specify what a key should be set as default as example NRF_WIFI_KEY_DEFAULT_MGMT"]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " Key Type, see &enum nrf_wifi_key_type"]
    pub key_type: ::core::ffi::c_int,
    #[doc = " Key data nrf_wifi_key"]
    pub key: nrf_wifi_key,
    #[doc = " Transmit key sequence number (IV/PN) for TKIP and CCMP keys,\n  each six bytes in little endian nrf_wifi_seq"]
    pub seq: nrf_wifi_seq,
    #[doc = " Key ID (0-3)"]
    pub key_idx: ::core::ffi::c_uchar,
}
#[repr(u32)]
#[doc = " @brief This enum describes the different types of scan.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum scan_reason {
    #[doc = " scan for display purpose in user space"]
    SCAN_DISPLAY = 0,
    #[doc = " scan for connection purpose"]
    SCAN_CONNECT = 1,
}
#[doc = " @brief This structure contains details about scan request information.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_scan_info {
    #[doc = " scan type see &enum scan_reason"]
    pub scan_reason: ::core::ffi::c_int,
    #[doc = " scan parameters nrf_wifi_scan_params"]
    pub scan_params: nrf_wifi_scan_params,
}
#[doc = " @brief This structure defines a command scan request.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_cmd_scan {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " nrf_wifi_umac_scan_info"]
    pub info: nrf_wifi_umac_scan_info,
}
#[doc = " @brief This structure defines a command to abort a scan request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_abort_scan {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief TThis structure defines a command to request scan results.\n This command should be executed only if we have received a\n NRF_WIFI_UMAC_EVENT_SCAN_DONE event for a previous scan.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_scan_results {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " scan type see &enum scan_reason"]
    pub scan_reason: ::core::ffi::c_int,
}
#[doc = " @brief This structure provides details about the \"Scan Done\" event.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_scan_done {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " status, 0=Scan successful & 1=Scan aborted"]
    pub status: ::core::ffi::c_int,
    #[doc = " scan type see &enum scan_reason"]
    pub scan_type: ::core::ffi::c_uint,
}
#[doc = " @brief This structure represents the parameters used to configure the multicast address filter.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_mcast_cfg {
    #[doc = " Add (0) or Delete (1)"]
    pub type_: ::core::ffi::c_uint,
    #[doc = " multicast address to be added/deleted"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure defines a command used to set multicast (mcast) addresses.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_mcast_filter {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " nrf_wifi_umac_mcast_cfg"]
    pub info: nrf_wifi_umac_mcast_cfg,
}
#[doc = " @brief This structure represents the parameters used to change the MAC address.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_change_macaddr_info {
    #[doc = " MAC address to be set"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure describes command to change MAC address.\n  This has to be used only when the interface is down.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_change_macaddr {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " nrf_wifi_umac_change_macaddr_info"]
    pub macaddr_info: nrf_wifi_umac_change_macaddr_info,
}
#[doc = " @brief This structure specifies the parameters to be used when sending an authentication request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_auth_info {
    #[doc = " Frequency of the selected channel in MHz"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Flag attribute to indicate that a command is requesting a local\n  authentication/association state change without invoking actual management\n  frame exchange. This can be used with NRF_WIFI_UMAC_CMD_AUTHENTICATE\n  NRF_WIFI_UMAC_CMD_DEAUTHENTICATE."]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " Authentication type. see &enum nrf_wifi_auth_type"]
    pub auth_type: ::core::ffi::c_int,
    #[doc = " Key information"]
    pub key_info: nrf_wifi_umac_key_info,
    #[doc = " SSID (binary attribute, 0..32 octets)"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " Information element(s) data"]
    pub ie: nrf_wifi_ie,
    #[doc = " SAE elements in Authentication frames. This starts\n  with the Authentication transaction sequence number field."]
    pub sae: nrf_wifi_sae,
    #[doc = " MAC address (various uses)"]
    pub nrf_wifi_bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = " The following parameters will be used to construct bss database in case of\n cfg80211 offload to host case.\n/\n/** scanning width"]
    pub scan_width: ::core::ffi::c_int,
    #[doc = " Signal strength"]
    pub nrf_wifi_signal: ::core::ffi::c_int,
    #[doc = " Received elements from beacon or probe response"]
    pub from_beacon: ::core::ffi::c_int,
    #[doc = " BSS information element data"]
    pub bss_ie: nrf_wifi_ie,
    #[doc = " BSS capability"]
    pub capability: ::core::ffi::c_ushort,
    #[doc = " Beacon interval(ms)"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " Beacon tsf"]
    pub tsf: ::core::ffi::c_ulonglong,
}
#[doc = " @brief This structure defines a command used to send an authentication request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_auth {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Information to be passed in the authentication command nrf_wifi_umac_auth_info"]
    pub info: nrf_wifi_umac_auth_info,
}
#[doc = " @brief This structure specifies the parameters to be used when sending an association request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_assoc_info {
    #[doc = " Frequency of the selected channel in MHz"]
    pub center_frequency: ::core::ffi::c_uint,
    #[doc = " ssid nrf_wifi_ssid"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " MAC address (various uses)"]
    pub nrf_wifi_bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = "  WPA information element data. nrf_wifi_ie"]
    pub wpa_ie: nrf_wifi_ie,
    #[doc = " Whether management frame protection (IEEE 802.11w) is used for the association"]
    pub use_mfp: ::core::ffi::c_uchar,
    #[doc = " Indicating whether user space controls IEEE 802.1X port. If set, the RPU will\n  assume that the port is unauthorized until authorized by user space.\n  Otherwise, port is marked authorized by default in station mode."]
    pub control_port: ::core::ffi::c_schar,
    #[doc = " Previous BSSID used in flag"]
    pub prev_bssid_flag: ::core::ffi::c_uint,
    #[doc = " Previous BSSID used in Re-assoc."]
    pub prev_bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = " Bss max idle timeout value in sec wich will be encapsulated into\n  BSS MAX IDLE IE in assoc request frame."]
    pub bss_max_idle_time: ::core::ffi::c_ushort,
}
#[doc = " @brief This structure specifies the parameters to be used when sending an association request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_assoc {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " nrf_wifi_connect_common_info"]
    pub connect_common_info: nrf_wifi_connect_common_info,
    #[doc = " Previous BSSID, to be used by in ASSOCIATE commands to specify\n using a reassociate frame."]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure specifies the parameters to be passed while sending a\n  deauthentication request (NRF_WIFI_UMAC_CMD_DEAUTHENTICATE).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_disconn_info {
    #[doc = " Indicates that a command is requesting a local deauthentication/disassociation\n  state change without invoking actual management frame exchange."]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " Reason code for disassociation or deauthentication"]
    pub reason_code: ::core::ffi::c_ushort,
    #[doc = " MAC address (various uses)"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure specifies the parameters to be used when sending a disconnect request.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_disconn {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " nrf_wifi_umac_disconn_info"]
    pub info: nrf_wifi_umac_disconn_info,
}
#[doc = " @brief This structure contains the information to be passed to the RPU\n  to create a new virtual interface using the NRF_WIFI_UMAC_CMD_NEW_INTERFACE command.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_add_vif_info {
    #[doc = " Interface type, see enum nrf_wifi_sys_iftype"]
    pub iftype: ::core::ffi::c_int,
    #[doc = " Use 4-address frames on a virtual interface"]
    pub nrf_wifi_use_4addr: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub mon_flags: ::core::ffi::c_uint,
    #[doc = " MAC Address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[doc = " @brief This structure defines a command used to create a new virtual interface\n  using the NRF_WIFI_UMAC_CMD_NEW_INTERFACE command.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_add_vif {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " VIF specific information to be passed to the RPU nrf_wifi_umac_add_vif_info"]
    pub info: nrf_wifi_umac_add_vif_info,
}
#[doc = " @brief This structure defines a command used to delete a virtual interface.\n  However, this command is not allowed on the default interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_del_vif {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure represents the data of management frame that must be matched for\n  processing in userspace.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_frame_match {
    #[doc = " Length of data"]
    pub frame_match_len: ::core::ffi::c_uint,
    #[doc = " Data to match"]
    pub frame_match: [::core::ffi::c_uchar; 8usize],
}
#[doc = " @brief This structure contains information about the type of management frame\n  that should be passed to the driver for processing in userspace.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_mgmt_frame_info {
    #[doc = " Frame type/subtype"]
    pub frame_type: ::core::ffi::c_ushort,
    #[doc = " Match information Refer &struct nrf_wifi_umac_frame_match"]
    pub frame_match: nrf_wifi_umac_frame_match,
}
#[doc = " @brief This structure defines a command to inform the RPU to register a management frame,\n  which must not be filtered by the RPU and should instead be passed to the host for\n  userspace processing.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_mgmt_frame_reg {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Management frame specific information to be passed to the RPU.\n nrf_wifi_umac_mgmt_frame_info"]
    pub info: nrf_wifi_umac_mgmt_frame_info,
}
#[doc = " @brief This structure represents command to add a new key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_key {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Key information. nrf_wifi_umac_key_info"]
    pub key_info: nrf_wifi_umac_key_info,
    #[doc = " MAC address associated with the key"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure defines a command that is used to add a new key.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_key {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Key information , nrf_wifi_umac_key_info"]
    pub key_info: nrf_wifi_umac_key_info,
}
#[doc = " @brief This structure contains parameters that describe the BSS (Basic Service Set) information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_bss_info {
    #[doc = " P2P GO Client Traffic Window, used with\n  the START_AP and SET_BSS commands."]
    pub p2p_go_ctwindow: ::core::ffi::c_uint,
    #[doc = " P2P GO opportunistic PS, used with the\n  START_AP and SET_BSS commands. This can have the values 0 or 1;\n  if not given in START_AP 0 is assumed, if not given in SET_BSS\n  no change is made."]
    pub p2p_opp_ps: ::core::ffi::c_uint,
    #[doc = " Number of basic rate elements"]
    pub num_basic_rates: ::core::ffi::c_uint,
    #[doc = " HT operation mode"]
    pub ht_opmode: ::core::ffi::c_ushort,
    #[doc = " Whether CTS protection is enabled (0 or 1)"]
    pub nrf_wifi_cts: ::core::ffi::c_uchar,
    #[doc = " Whether short preamble is enabled (0 or 1)"]
    pub preamble: ::core::ffi::c_uchar,
    #[doc = " Whether short slot time enabled (0 or 1)"]
    pub nrf_wifi_slot: ::core::ffi::c_uchar,
    #[doc = " (AP mode) Do not forward traffic between stations connected to this BSS"]
    pub ap_isolate: ::core::ffi::c_uchar,
    #[doc = " Basic rates, array of basic rates in format defined by IEEE 802.11 7.3.2.2"]
    pub basic_rates: [::core::ffi::c_uchar; 32usize],
}
#[doc = " @brief This structure represents a command used to set BSS (Basic Service Set) parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_bss {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " BSS specific information to be passed to the RPU nrf_wifi_umac_bss_info"]
    pub bss_info: nrf_wifi_umac_bss_info,
}
#[doc = " @brief This structure contains information about frequency parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct freq_params {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Value in MHz"]
    pub frequency: ::core::ffi::c_int,
    #[doc = " Width of the channel @see &enu nrf_wifi_chan_width"]
    pub channel_width: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub center_frequency1: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub center_frequency2: ::core::ffi::c_int,
    #[doc = " Type of channel see &enum nrf_wifi_channel_type"]
    pub channel_type: ::core::ffi::c_int,
}
#[doc = " @brief This structure contains information about transmit queue parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_txq_params {
    #[doc = " Transmit oppurtunity"]
    pub txop: ::core::ffi::c_ushort,
    #[doc = " Minimum contention window"]
    pub cwmin: ::core::ffi::c_ushort,
    #[doc = " Maximum contention window"]
    pub cwmax: ::core::ffi::c_ushort,
    #[doc = " Arbitration interframe spacing"]
    pub aifs: ::core::ffi::c_uchar,
    #[doc = " Access category"]
    pub ac: ::core::ffi::c_uchar,
}
#[repr(u32)]
#[doc = " @brief Types of transmit power settings.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_tx_power_type {
    #[doc = " Automatically determine transmit power"]
    NRF_WIFI_TX_POWER_AUTOMATIC = 0,
    #[doc = " Limit TX power by the mBm parameter"]
    NRF_WIFI_TX_POWER_LIMITED = 1,
    #[doc = " Fix TX power to the mBm parameter"]
    NRF_WIFI_TX_POWER_FIXED = 2,
}
#[doc = " @brief This structure contains the parameters related to the transmit power setting.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_tx_power_setting {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Power value type, see nrf_wifi_tx_power_type"]
    pub type_: ::core::ffi::c_int,
    #[doc = " Transmit power level in signed mBm units"]
    pub tx_power_level: ::core::ffi::c_int,
}
#[doc = " @brief This structure contains information about the configuration parameters\n  needed to set up and configure the wireless Physical Layer.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_set_wiphy_info {
    #[doc = " RTS threshold, TX frames with length larger than or equal to this use RTS/CTS handshake\n  allowed range: 0..65536, disable with -1."]
    pub rts_threshold: ::core::ffi::c_int,
    #[doc = " Fragmentation threshold, maximum length in octets for frames.\n  allowed range: 256..8000, disable fragmentation with (u32)-1."]
    pub frag_threshold: ::core::ffi::c_uint,
    #[doc = " Bitmap of allowed antennas for transmitting. This can be used to mask out\n  antennas which are not attached or should not be used for transmitting.\n  If an antenna is not selected in this bitmap the hardware is not allowed\n  to transmit on this antenna."]
    pub antenna_tx: ::core::ffi::c_uint,
    #[doc = " Bitmap of allowed antennas for receiving. This can be used to mask out antennas\n  which are not attached or should not be used for receiving. If an antenna is\n  not selected in this bitmap the hardware should not be configured to receive\n  on this antenna."]
    pub antenna_rx: ::core::ffi::c_uint,
    #[doc = " Frequency information of the a channel see &struct freq_params"]
    pub freq_params: freq_params,
    #[doc = " TX queue parameters nrf_wifi_txq_params"]
    pub txq_params: nrf_wifi_txq_params,
    #[doc = " Tx power settings nrf_wifi_tx_power_setting nrf_wifi_tx_power_setting"]
    pub tx_power_setting: nrf_wifi_tx_power_setting,
    #[doc = " TX retry limit for frames whose length is less than or equal to the RTS threshold\n  allowed range: 1..255."]
    pub retry_short: ::core::ffi::c_uchar,
    #[doc = " TX retry limit for frames whose length is greater than the RTS threshold\n  allowed range: 1..255."]
    pub retry_long: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub coverage_class: ::core::ffi::c_uchar,
    #[doc = " WIPHY name (used for renaming)"]
    pub wiphy_name: [::core::ffi::c_schar; 32usize],
}
#[doc = " @brief This structure defines the command to set the wireless PHY configuration.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_wiphy {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicates which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " nrf_wifi_umac_set_wiphy_info"]
    pub info: nrf_wifi_umac_set_wiphy_info,
}
#[doc = " @brief This structure contains the parameters to delete a station.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_del_sta_info {
    #[doc = " MAC address of the station"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Management frame subtype"]
    pub mgmt_subtype: ::core::ffi::c_uchar,
    #[doc = " Reason code for DEAUTHENTICATION and DISASSOCIATION"]
    pub reason_code: ::core::ffi::c_ushort,
}
#[doc = " @brief This structure defines the command to delete a station.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_del_sta {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Information regarding the station to be deleted nrf_wifi_umac_del_sta_info"]
    pub info: nrf_wifi_umac_del_sta_info,
}
#[doc = " @brief This structure contains the information required for obtaining station details.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_get_sta_info {
    #[doc = " MAC address of the station"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure defines the command to get station information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_sta {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Information regarding the station to get nrf_wifi_umac_get_sta_info"]
    pub info: nrf_wifi_umac_get_sta_info,
}
#[doc = " @brief Extended capability information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_ext_capability {
    #[doc = " length"]
    pub ext_capability_len: ::core::ffi::c_uint,
    #[doc = " Extended capability info"]
    pub ext_capability: [::core::ffi::c_uchar; 32usize],
}
#[doc = " @brief Supported channels."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_supported_channels {
    #[doc = " number of channels"]
    pub supported_channels_len: ::core::ffi::c_uint,
    #[doc = " channels info"]
    pub supported_channels: [::core::ffi::c_uchar; 64usize],
}
#[doc = " @brief Operating classes information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_supported_oper_classes {
    #[doc = " length"]
    pub supported_oper_classes_len: ::core::ffi::c_uint,
    #[doc = " oper_class info"]
    pub supported_oper_classes: [::core::ffi::c_uchar; 64usize],
}
#[doc = " @brief Station flags."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sta_flags2 {
    #[doc = " length"]
    pub sta_flags2_len: ::core::ffi::c_uint,
    #[doc = " flags"]
    pub sta_flags2: [::core::ffi::c_uchar; 64usize],
}
#[doc = " @brief This structure represents the information needed to update a station entry\n in the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_chg_sta_info {
    #[doc = " Listen interval as defined by IEEE 802.11 7.3.1.6"]
    pub nrf_wifi_listen_interval: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub sta_vlan: ::core::ffi::c_uint,
    #[doc = " AID or zero for no change"]
    pub aid: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub nrf_wifi_peer_aid: ::core::ffi::c_ushort,
    #[doc = " Station capability"]
    pub sta_capability: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub spare: ::core::ffi::c_ushort,
    #[doc = " Supported rates in IEEE 802.11 format nrf_wifi_supp_rates"]
    pub supp_rates: nrf_wifi_supp_rates,
    #[doc = " Extended capabilities of the station nrf_wifi_ext_capability"]
    pub ext_capability: nrf_wifi_ext_capability,
    #[doc = " Supported channels in IEEE 802.11 format nrf_wifi_supported_channels"]
    pub supported_channels: nrf_wifi_supported_channels,
    #[doc = " Supported oper classes in IEEE 802.11 format nrf_wifi_supported_oper_classes"]
    pub supported_oper_classes: nrf_wifi_supported_oper_classes,
    #[doc = " station flags mask/set nrf_wifi_sta_flag_update nrf_wifi_sta_flag_update"]
    pub sta_flags2: nrf_wifi_sta_flag_update,
    #[doc = " HT capabilities of station"]
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " VHT capabilities of station"]
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " Station mac address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Information if operating mode field is used"]
    pub opmode_notif: ::core::ffi::c_uchar,
    #[doc = " Bitmap of queues configured for uapsd. Same format\n  as the AC bitmap in the QoS info field."]
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    #[doc = " Max Service Period. same format as the MAX_SP in the\n  QoS info field (but already shifted down)."]
    pub wme_max_sp: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines the command for updating the parameters of a station entry.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_chg_sta {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " nrf_wifi_umac_chg_sta_info"]
    pub info: nrf_wifi_umac_chg_sta_info,
}
#[doc = " @brief This structure describes the parameters for adding a new station entry to the RPU.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_add_sta_info {
    #[doc = " Listen interval as defined by IEEE 802.11 7.3.1.6"]
    pub nrf_wifi_listen_interval: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub sta_vlan: ::core::ffi::c_uint,
    #[doc = " AID or zero for no change"]
    pub aid: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub nrf_wifi_peer_aid: ::core::ffi::c_ushort,
    #[doc = " Station capability"]
    pub sta_capability: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub spare: ::core::ffi::c_ushort,
    #[doc = " Supported rates in IEEE 802.11 format nrf_wifi_supp_rates"]
    pub supp_rates: nrf_wifi_supp_rates,
    #[doc = " Extended capabilities of the station nrf_wifi_ext_capability"]
    pub ext_capability: nrf_wifi_ext_capability,
    #[doc = " Supported channels in IEEE 802.11 format nrf_wifi_supported_channels"]
    pub supported_channels: nrf_wifi_supported_channels,
    #[doc = " Supported oper classes in IEEE 802.11 format nrf_wifi_supported_oper_classes"]
    pub supported_oper_classes: nrf_wifi_supported_oper_classes,
    #[doc = " station flags mask/set nrf_wifi_sta_flag_update"]
    pub sta_flags2: nrf_wifi_sta_flag_update,
    #[doc = " HT capabilities of station"]
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " VHT capabilities of station"]
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    #[doc = " Station mac address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Information if operating mode field is used"]
    pub opmode_notif: ::core::ffi::c_uchar,
    #[doc = " Bitmap of queues configured for uapsd. same format\n  as the AC bitmap in the QoS info field."]
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    #[doc = " Max Service Period. same format as the MAX_SP in the\n  QoS info field (but already shifted down)."]
    pub wme_max_sp: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines the command for adding a new station entry.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_add_sta {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " nrf_wifi_umac_add_sta_info"]
    pub info: nrf_wifi_umac_add_sta_info,
}
#[doc = " @brief This structure describes the parameters required to be passed to the RPU when\n  initiating a SoftAP (Soft Access Point).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_start_ap_info {
    #[doc = " Beacon frame interval"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " DTIM count"]
    pub dtim_period: ::core::ffi::c_uchar,
    #[doc = " Send beacons with wildcard sssid"]
    pub hidden_ssid: ::core::ffi::c_int,
    #[doc = " Authentication type, see &enum nrf_wifi_auth_type"]
    pub auth_type: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub smps_mode: ::core::ffi::c_int,
    #[doc = " Beacon info flags"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " Beacon frame, nrf_wifi_beacon_data"]
    pub beacon_data: nrf_wifi_beacon_data,
    #[doc = " SSID string, nrf_wifi_ssid"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " Connect params, nrf_wifi_connect_common_info"]
    pub connect_common_info: nrf_wifi_connect_common_info,
    #[doc = " Channel info, see &struct freq_params"]
    pub freq_params: freq_params,
    #[doc = " Time to stop ap after inactivity period"]
    pub inactivity_timeout: ::core::ffi::c_ushort,
    #[doc = " P2P GO Client Traffic Window"]
    pub p2p_go_ctwindow: ::core::ffi::c_uchar,
    #[doc = " Opportunistic power save allows P2P Group Owner to save power\n  when all its associated clients are sleeping."]
    pub p2p_opp_ps: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines the command for starting the SoftAP using\n  NRF_WIFI_UMAC_CMD_NEW_BEACON and NRF_WIFI_UMAC_CMD_START_AP.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_start_ap {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Parameters that need to be passed to the RPU when starting a SoftAP.\n  nrf_wifi_umac_start_ap_info"]
    pub info: nrf_wifi_umac_start_ap_info,
}
#[doc = " @brief This structure defines the command used to stop Soft AP operation.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_stop_ap {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure represents the parameters that must be passed to the RPU when\n  configuring Beacon and Probe response data.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_set_beacon_info {
    #[doc = " Beacon frame, nrf_wifi_beacon_data"]
    pub beacon_data: nrf_wifi_beacon_data,
}
#[doc = " @brief This structure defines the command for setting the beacon data using\n  NRF_WIFI_UMAC_CMD_SET_BEACON.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_beacon {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " nrf_wifi_umac_set_beacon_info"]
    pub info: nrf_wifi_umac_set_beacon_info,
}
#[doc = " @brief This structure contains the information that needs to be provided to the RPU\n  when modifying the attributes of a virtual interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_chg_vif_attr_info {
    #[doc = " Interface type, see &enum nrf_wifi_iftype"]
    pub iftype: ::core::ffi::c_int,
    #[doc = " Unused"]
    pub nrf_wifi_use_4addr: ::core::ffi::c_int,
}
#[doc = " @brief This structure defines the command used to change the interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_chg_vif_attr {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Interface attributes to be changed nrf_wifi_umac_chg_vif_attr_info"]
    pub info: nrf_wifi_umac_chg_vif_attr_info,
}
#[doc = " @brief This structure contains the information that needs to be passed to the RPU\n  when changing the interface state, specifically when bringing it up or down\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_chg_vif_state_info {
    #[doc = " Interface state (1 = UP / 0 = DOWN)"]
    pub state: ::core::ffi::c_int,
    #[doc = " Interface index"]
    pub if_index: ::core::ffi::c_schar,
}
#[doc = " @brief This structure defines the command used to change the interface state.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_chg_vif_state {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " nrf_wifi_umac_chg_vif_state_info"]
    pub info: nrf_wifi_umac_chg_vif_state_info,
}
#[doc = " @brief This structure defines an event-to-command mapping for NRF_WIFI_UMAC_CMD_SET_IFFLAGS.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_vif_state {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Status to command NRF_WIFI_UMAC_CMD_SET_IFFLAGS"]
    pub status: ::core::ffi::c_int,
}
#[doc = " @brief This structure defines the command used to start P2P (Peer-to-Peer) mode on an interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_start_p2p {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure represents the command for stopping P2P mode on an interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_stop_p2p_dev {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure describes the parameters required to transmit a\n  management frame from the host.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_mgmt_tx_info {
    #[doc = " OFFCHANNEL_TX_OK, NO_CCK_RATE, DONT_WAIT_FOR_ACK"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " Channel frequency"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Duration field value"]
    pub dur: ::core::ffi::c_uint,
    #[doc = " Management frame to transmit, nrf_wifi_frame"]
    pub frame: nrf_wifi_frame,
    #[doc = " Frequency configuration, see &struct freq_params"]
    pub freq_params: freq_params,
    #[doc = " Identifier to be used for processing event,\n  NRF_WIFI_UMAC_EVENT_FRAME_TX_STATUS."]
    pub host_cookie: ::core::ffi::c_ulonglong,
}
#[doc = " @brief This structure defines the command used to transmit a management frame.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_mgmt_tx {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Information about the management frame to be transmitted.\n  nrf_wifi_umac_mgmt_tx_info"]
    pub info: nrf_wifi_umac_mgmt_tx_info,
}
#[doc = " @brief This structure represents the information regarding the power save state.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_set_power_save_info {
    #[doc = " power save is disabled or enabled, see enum nrf_wifi_ps_state"]
    pub ps_state: ::core::ffi::c_int,
}
#[doc = " @brief This structure represents the command used to enable or disable the power save\n  functionality.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_power_save {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Power save setting parameters.\n nrf_wifi_umac_set_power_save_info"]
    pub info: nrf_wifi_umac_set_power_save_info,
}
#[doc = " @brief This structure represents the command to configure power save timeout value.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_power_save_timeout {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Timeout value in milli seconds\n if timeout < 0 RPU will set timeout to 100ms"]
    pub timeout: ::core::ffi::c_int,
}
#[doc = " @brief This structure represents the information of qos_map.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_qos_map_info {
    #[doc = " length of qos_map info field"]
    pub qos_map_info_len: ::core::ffi::c_uint,
    #[doc = " contains qos_map info as received from stack"]
    pub qos_map_info: [::core::ffi::c_uchar; 256usize],
}
#[doc = " @brief This structure represents the information related to the Quality of Service (QoS) map.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_qos_map {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " qos map info. nrf_wifi_umac_qos_map_info"]
    pub info: nrf_wifi_umac_qos_map_info,
}
#[doc = " @brief This structure defines the command used to retrieve the transmit power information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_tx_power {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure defines the command used to obtain the regulatory domain information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_reg {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure defines the command used to retrieve channel information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_channel {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[repr(u32)]
#[doc = " @brief TWT setup commands and events.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_twt_setup_cmd_type {
    #[doc = " STA requests to join a TWT without specifying a target wake time"]
    NRF_WIFI_REQUEST_TWT = 0,
    #[doc = " STA requests to join a TWT with specifying a target wake time and\n  other params, these values can change during negotiation."]
    NRF_WIFI_SUGGEST_TWT = 1,
    #[doc = " requests to join a TWT with demanded a target wake time\n and other params. STA rejects if AP not scheduling those params."]
    NRF_WIFI_DEMAND_TWT = 2,
    #[doc = " Response to the STA request(suggest/demand), these may be different params"]
    NRF_WIFI_GROUPING_TWT = 3,
    #[doc = " AP accept the STA requested params"]
    NRF_WIFI_ACCEPT_TWT = 4,
    #[doc = " AP may suggest the params, these may be different from STA requested"]
    NRF_WIFI_ALTERNATE_TWT = 5,
    #[doc = " AP may suggest the params, these may be different from STA requested"]
    NRF_WIFI_DICTATE_TWT = 6,
    #[doc = " AP may reject the STA requested params"]
    NRF_WIFI_REJECT_TWT = 7,
}
#[doc = " @brief This structure describes the TWT information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_config_twt_info {
    #[doc = " TWT flow Id"]
    pub twt_flow_id: ::core::ffi::c_uchar,
    #[doc = " Negotiation type\n  NRF_WIFI_TWT_NEGOTIATION_TYPE_INDIVIDUAL or\n  NRF_WIFI_TWT_NEGOTIATION_TYPE_BROADAST"]
    pub neg_type: ::core::ffi::c_uchar,
    #[doc = " see &enum nrf_wifi_twt_setup_cmd_type"]
    pub setup_cmd: ::core::ffi::c_int,
    #[doc = " indicating AP to initiate a trigger frame (ps_poll/Null) before data transfer"]
    pub ap_trigger_frame: ::core::ffi::c_uchar,
    #[doc = " 1->implicit(same negotiated values to be used),\n  0->AP sends new calculated TWT values for every service period."]
    pub is_implicit: ::core::ffi::c_uchar,
    #[doc = " Whether STA has to send the PS-Poll/Null frame\n  indicating that it's in wake period(NRF_WIFI_TWT_FLOW_TYPE_ANNOUNCED)"]
    pub twt_flow_type: ::core::ffi::c_uchar,
    #[doc = " wake interval exponent value"]
    pub twt_target_wake_interval_exponent: ::core::ffi::c_uchar,
    #[doc = " wake interval mantissa value"]
    pub twt_target_wake_interval_mantissa: ::core::ffi::c_ushort,
    #[doc = " start of the waketime value after successful TWT negotiation"]
    pub target_wake_time: ::core::ffi::c_ulonglong,
    #[doc = " min TWT wake duration"]
    pub nominal_min_twt_wake_duration: ::core::ffi::c_uint,
    #[doc = " dialog_token of twt frame"]
    pub dialog_token: ::core::ffi::c_uchar,
    #[doc = " 0->not received 1->received"]
    pub twt_resp_status: ::core::ffi::c_uchar,
    #[doc = " TWT early wake duration"]
    pub twt_wake_ahead_duration: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the parameters required for setting up TWT session.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_config_twt {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " TWT configuration info nrf_wifi_umac_config_twt_info"]
    pub info: nrf_wifi_umac_config_twt_info,
}
#[doc = " @brief This structure represents the TWT delete information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_teardown_twt_info {
    #[doc = " TWT flow Id"]
    pub twt_flow_id: ::core::ffi::c_uchar,
    #[doc = " reason for teardown"]
    pub reason_code: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines the command used to delete or remove a TWT session\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_teardown_twt {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " nrf_wifi_umac_teardown_twt_info"]
    pub info: nrf_wifi_umac_teardown_twt_info,
}
#[doc = " @brief This structure represents the information related to Tx (transmit) block/unblock.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct twt_sleep_info {
    #[doc = " value for blocking/unblocking TX\n  (TWT_BLOCK_TX or TWT_UNBLOCK_TX)"]
    pub type_: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines an event used to indicate to the host whether to block or\n  unblock Tx (transmit) packets in TWT communication.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_twt_sleep {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " twt_sleep_info"]
    pub info: twt_sleep_info,
}
#[doc = " @brief This structure represents the information about UAPSD queues.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_uapsd_info {
    #[doc = " UAPSD-Q value"]
    pub uapsd_queue: ::core::ffi::c_uint,
}
#[doc = " @brief This structure defines the command used to configure the UAPSD-Q value.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_config_uapsd {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " nrf_wifi_umac_uapsd_info"]
    pub info: nrf_wifi_umac_uapsd_info,
}
#[doc = " @brief This structure represents the event used to indicate that a scan has started.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_trigger_scan {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Scan request control flags (u32). Bit values\n (NRF_WIFI_SCAN_FLAG_LOW_PRIORITY/NRF_WIFI_SCAN_FLAG_RANDOM_ADDR...)"]
    pub nrf_wifi_scan_flags: ::core::ffi::c_uint,
    #[doc = " No.of ssids in scan request"]
    pub num_scan_ssid: ::core::ffi::c_uchar,
    #[doc = " No.of frequencies in scan request"]
    pub num_scan_frequencies: ::core::ffi::c_uchar,
    #[doc = " center frequencies"]
    pub scan_frequencies: [::core::ffi::c_ushort; 64usize],
    #[doc = " nrf_wifi_ssid"]
    pub scan_ssid: [nrf_wifi_ssid; 2usize],
    #[doc = " nrf_wifi_ie"]
    pub ie: nrf_wifi_ie,
}
#[doc = " @brief This structure serves as a response to the command NRF_WIFI_UMAC_CMD_GET_SCAN_RESULTS.\n  It contains scan results for each entry. RPU sends multiple events of this type for every\n  scan entry, and when umac_hdr->seq == 0, it indicates the last scan entry.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_event_new_scan_results {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub generation: ::core::ffi::c_uint,
    #[doc = " Frequency in MHz"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Channel width of the control channel"]
    pub chan_width: ::core::ffi::c_uint,
    #[doc = " Age of this BSS entry in ms"]
    pub seen_ms_ago: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " Status, if this BSS is \"used\""]
    pub status: ::core::ffi::c_int,
    #[doc = " TSF of the received probe response/beacon (u64)"]
    pub ies_tsf: ::core::ffi::c_ulonglong,
    #[doc = " TSF of the last received beacon\n  (not present if no beacon frame has been received yet)."]
    pub beacon_ies_tsf: ::core::ffi::c_ulonglong,
    #[doc = " Beacon interval of BSS"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " Capability field"]
    pub capability: ::core::ffi::c_ushort,
    #[doc = " Signal strength, nrf_wifi_signal"]
    pub signal: nrf_wifi_signal,
    #[doc = " BSSID of the BSS (6 octets)"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Indicates length of IE's present at the starting of ies[0]"]
    pub ies_len: ::core::ffi::c_uint,
    #[doc = " Indicates length of beacon_ies present after ies+ies_len"]
    pub beacon_ies_len: ::core::ffi::c_uint,
    #[doc = " contains raw information elements from the probe response/beacon.\n If beacon_ies are not present then the IEs here are from a Probe Response\n frame; otherwise they are from a Beacon frame."]
    pub ies: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[doc = " @brief This structure represents the response for NRF_WIFI_UMAC_CMD_GET_SCAN_RESULTS.\n  It contains the displayed scan result.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct umac_display_results {
    #[doc = " Network SSID nrf_wifi_ssid"]
    pub ssid: nrf_wifi_ssid,
    #[doc = " BSSID of the BSS (6 octets)"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Network band of operation, refer &enum nrf_wifi_band"]
    pub nwk_band: ::core::ffi::c_int,
    #[doc = " Network channel number"]
    pub nwk_channel: ::core::ffi::c_uint,
    #[doc = "  Protocol type (NRF_WIFI_802_11A)"]
    pub protocol_flags: ::core::ffi::c_uchar,
    #[doc = " Network security mode, refer &enum nrf_wifi_security_type"]
    pub security_type: ::core::ffi::c_int,
    #[doc = " Beacon interval of the BSS"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " Capability field"]
    pub capability: ::core::ffi::c_ushort,
    #[doc = " Signal strength. Refer &struct nrf_wifi_signal"]
    pub signal: nrf_wifi_signal,
    #[doc = " TWT support"]
    pub twt_support: ::core::ffi::c_uchar,
    #[doc = " management frame protection NRF_WIFI_MFP_REQUIRED/NRF_WIFI_MFP_CAPABLE"]
    pub mfp_flag: ::core::ffi::c_uchar,
    #[doc = " reserved"]
    pub reserved3: ::core::ffi::c_uchar,
    #[doc = " reserved"]
    pub reserved4: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure serves as a response to the command NRF_WIFI_UMAC_CMD_GET_SCAN_RESULTS\n  of display scan type. It contains a maximum of DISPLAY_BSS_TOHOST_PEREVENT scan results\n  in each event. When umac_hdr->seq == 0, it indicates the last scan event.\n"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct nrf_wifi_umac_event_new_scan_display_results {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Number of scan results in the current event"]
    pub event_bss_count: ::core::ffi::c_uchar,
    #[doc = " Display scan results info umac_display_results"]
    pub display_results: [umac_display_results; 8usize],
}
#[doc = " @brief This structure represent different responses received from the access point during\n  various stages of the connection process like Authentication Response and Association Response.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_event_mlme {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Frequency of the channel in MHz"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " Signal strength in dBm"]
    pub rx_signal_dbm: ::core::ffi::c_uint,
    #[doc = " Indicate whether the frame was acked or timed out"]
    pub nrf_wifi_flags: ::core::ffi::c_uint,
    #[doc = " cookie identifier"]
    pub cookie: ::core::ffi::c_ulonglong,
    #[doc = " Frame data, including frame header and body nrf_wifi_frame"]
    pub frame: nrf_wifi_frame,
    #[doc = " BSSID of the BSS"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Bitmap of uapsd queues"]
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    #[doc = " Request(AUTH/ASSOC) ie length"]
    pub req_ie_len: ::core::ffi::c_uint,
    #[doc = " ie's"]
    pub req_ie: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[doc = " @brief This structure represents an event that is generated when a station is added or removed.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_new_station {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate if assoc_req ies is valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " set to 1: STA supports QoS/WME"]
    pub wme: ::core::ffi::c_uchar,
    #[doc = " Set to 1 if STA is Legacy(a/b/g)"]
    pub is_sta_legacy: ::core::ffi::c_uchar,
    #[doc = " Station mac address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " generation number"]
    pub generation: ::core::ffi::c_uint,
    #[doc = " Station information nrf_wifi_sta_info"]
    pub sta_info: nrf_wifi_sta_info,
    #[doc = " nrf_wifi_ie"]
    pub assoc_req_ies: nrf_wifi_ie,
}
#[doc = " @brief This structure specifies the cookie response event, which is used to receive an\n  RPU cookie associated with the host cookie passed during NRF_WIFI_UMAC_CMD_FRAME.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_cookie_rsp {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate if assoc_req ies is valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Identifier passed during NRF_WIFI_UMAC_CMD_FRAME"]
    pub host_cookie: ::core::ffi::c_ulonglong,
    #[doc = " Cookie used to indicate TX done in NRF_WIFI_UMAC_EVENT_FRAME_TX_STATUS"]
    pub cookie: ::core::ffi::c_ulonglong,
    #[doc = " Mac address"]
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure represents the event that corresponds to the command\n  NRF_WIFI_UMAC_CMD_GET_TX_POWER. It is used to retrieve the transmit power\n  information from the device\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_get_tx_power {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Tx power in dbm"]
    pub txpwr_level: ::core::ffi::c_int,
}
#[doc = " @brief This structure represents the response to the command NRF_WIFI_UMAC_CMD_SET_INTERFACE.\n  It contains the necessary information indicating the result or status of the interface\n  configuration operation after the command has been executed.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_set_interface {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " return value"]
    pub return_value: ::core::ffi::c_int,
}
#[repr(u32)]
#[doc = " @brief channel flags.\n\n Channel flags set by the regulatory control code.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_channel_flags {
    #[doc = " This channel is disabled"]
    CHAN_DISABLED = 1,
    #[doc = " do not initiate radiation, this includes sending probe requests or beaconing"]
    CHAN_NO_IR = 2,
    #[doc = " Radar detection is required on this channel hole at 1<<2"]
    CHAN_RADAR = 8,
    #[doc = " extension channel above this channel is not permitted"]
    CHAN_NO_HT40PLUS = 16,
    #[doc = " extension channel below this channel is not permitted"]
    CHAN_NO_HT40MINUS = 32,
    #[doc = " OFDM is not allowed on this channel"]
    CHAN_NO_OFDM = 64,
    #[doc = " If the driver supports 80 MHz on the band,\n this flag indicates that an 80 MHz channel cannot use this\n channel as the control or any of the secondary channels.\n This may be due to the driver or due to regulatory bandwidth\n restrictions."]
    CHAN_NO_80MHZ = 128,
    #[doc = " If the driver supports 160 MHz on the band,\n this flag indicates that an 160 MHz channel cannot use this\n channel as the control or any of the secondary channels.\n This may be due to the driver or due to regulatory bandwidth\n restrictions."]
    CHAN_NO_160MHZ = 256,
    #[doc = " NL80211_FREQUENCY_ATTR_INDOOR_ONLY"]
    CHAN_INDOOR_ONLY = 512,
    #[doc = " NL80211_FREQUENCY_ATTR_GO_CONCURRENT"]
    CHAN_GO_CONCURRENT = 1024,
    #[doc = " 20 MHz bandwidth is not permitted on this channel"]
    CHAN_NO_20MHZ = 2048,
    #[doc = " 10 MHz bandwidth is not permitted on this channel"]
    CHAN_NO_10MHZ = 4096,
}
#[doc = " @brief channel definition.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_chan_definition {
    #[doc = " Frequency of the selected channel in MHz"]
    pub chan: nrf_wifi_channel,
    #[doc = " channel width"]
    pub width: ::core::ffi::c_int,
    #[doc = " center frequency of first segment"]
    pub center_frequency1: ::core::ffi::c_uint,
    #[doc = " center frequency of second segment (only with 80+80 MHz)"]
    pub center_frequency2: ::core::ffi::c_uint,
}
#[doc = " @brief This structure represents channel information and serves as the event for the\n  command NRF_WIFI_UMAC_CMD_GET_CHANNEL.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_get_channel {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Channel information.nrf_wifi_chan_definition"]
    pub chan_def: nrf_wifi_chan_definition,
}
#[doc = " @brief This structure represents the command used to retrieve connection information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_conn_info {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum link_mode {
    NRF_WIFI_MODE_11B = 1,
    NRF_WIFI_MODE_11A = 2,
    NRF_WIFI_MODE_11G = 3,
    NRF_WIFI_MODE_11N = 4,
    NRF_WIFI_MODE_11AC = 5,
    NRF_WIFI_MODE_11AX = 6,
}
#[doc = " @brief This structure represents the information related to the connection of a station.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_conn_info {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Beacon interval"]
    pub beacon_interval: ::core::ffi::c_ushort,
    #[doc = " DTIM interval"]
    pub dtim_interval: ::core::ffi::c_uchar,
    #[doc = " Station association state"]
    pub associated: ::core::ffi::c_uchar,
    #[doc = " TWT supported or not"]
    pub twt_capable: ::core::ffi::c_uchar,
    #[doc = " Refer &enum link_mode"]
    pub linkmode: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure defines the command used to retrieve power save information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_get_power_save_info {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure defines the command used to set the listen interval period.\n  It determines how frequently a device wakes up to check for any pending data or traffic\n  from the access point. By setting the listen interval, devices can adjust their power-saving\n  behavior to balance power efficiency and responsiveness to incoming data.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_set_listen_interval {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " listen interval"]
    pub listen_interval: ::core::ffi::c_ushort,
}
#[doc = " @brief This structure represents the command used to enable or disable extended power save mode.\n  When enabled, the RPU wakes up based on the listen interval, allowing the device to spend more\n  time in a lower power state. When disabled, the RPU wakes up based on the DTIM period, which\n  may require more frequent wake-ups but can provide better responsiveness for receiving\n  multicast/broadcast traffic.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_config_extended_ps {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " 1=enable 0=disable"]
    pub enable_extended_ps: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure represents an event that provides information about the RPU power save\n  mode. It contains details regarding the current power save mode and its settings.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_umac_event_power_save_info {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Power save mode. NRF_WIFI_PS_MODE_LEGACY/NRF_WIFI_PS_MODE_WMM"]
    pub ps_mode: ::core::ffi::c_uchar,
    #[doc = " Power save enable flag"]
    pub enabled: ::core::ffi::c_uchar,
    #[doc = " Extended power save ON(1)/OFF(0)"]
    pub extended_ps: ::core::ffi::c_uchar,
    #[doc = " Is TWT responder"]
    pub twt_responder: ::core::ffi::c_uchar,
    #[doc = " Power save timed out value"]
    pub ps_timeout: ::core::ffi::c_uint,
    #[doc = " Listen interval value"]
    pub listen_interval: ::core::ffi::c_ushort,
    #[doc = " Power save exit strategy"]
    pub ps_exit_strategy: ::core::ffi::c_uchar,
    #[doc = " Number TWT flows"]
    pub num_twt_flows: ::core::ffi::c_uchar,
    #[doc = " TWT info of each flow nrf_wifi_umac_config_twt_info"]
    pub twt_flow_info: __IncompleteArrayField<nrf_wifi_umac_config_twt_info>,
}
#[doc = " @brief This structure contains information relevant to the \"Remain on Channel\" operation.\n  It is used to specify the details related to the duration and channel on which a device\n  needs to stay without regular data transmission or reception.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct remain_on_channel_info {
    #[doc = " Amount of time to remain on specified channel"]
    pub dur: ::core::ffi::c_uint,
    #[doc = " Frequency configuration, see &struct freq_params"]
    pub nrf_wifi_freq_params: freq_params,
    #[doc = " Identifier to be used for processing NRF_WIFI_UMAC_EVENT_COOKIE_RESP event"]
    pub host_cookie: ::core::ffi::c_ulonglong,
    #[doc = " Unused"]
    pub cookie: ::core::ffi::c_ulonglong,
}
#[doc = " @brief This structure represents the command used to keep the device awake on the specified\n  channel for a designated period. The command initiates the \"Remain on Channel\" operation.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_remain_on_channel {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Information about channel parameters.remain_on_channel_info"]
    pub info: remain_on_channel_info,
}
#[doc = " @brief This structure represents the command to cancel \"Remain on Channel\" operation.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_cancel_remain_on_channel {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " cookie to identify remain on channel"]
    pub cookie: ::core::ffi::c_ulonglong,
}
#[doc = " @brief This structure represents the response to command \"Remain on Channel\".\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_remain_on_channel {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Frequency of the channel"]
    pub frequency: ::core::ffi::c_uint,
    #[doc = " duration that can be requested with the remain-on-channel operation(ms)"]
    pub dur: ::core::ffi::c_uint,
    #[doc = " see &enum nrf_wifi_channel_type"]
    pub ch_type: ::core::ffi::c_uint,
    #[doc = " cookie to identify remain on channel"]
    pub cookie: ::core::ffi::c_ulonglong,
}
#[doc = " @brief This structure defines the command used to retrieve interface information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_get_interface {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure represents an event that contains information about a network interface.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_interface_info {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Interface type, see &enum nrf_wifi_iftype"]
    pub nrf_wifi_iftype: ::core::ffi::c_int,
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
    #[doc = " Mac address"]
    pub nrf_wifi_eth_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " nrf_wifi_chan_definition"]
    pub chan_def: nrf_wifi_chan_definition,
    #[doc = " nrf_wifi_ssid"]
    pub ssid: nrf_wifi_ssid,
}
#[doc = " @brief MCS information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_mcs_info {
    #[doc = " Highest supported RX rate"]
    pub nrf_wifi_rx_highest: ::core::ffi::c_ushort,
    #[doc = " RX mask"]
    pub nrf_wifi_rx_mask: [::core::ffi::c_uchar; 10usize],
    #[doc = " TX parameters"]
    pub nrf_wifi_tx_params: ::core::ffi::c_uchar,
    #[doc = " reserved"]
    pub nrf_wifi_reserved: [::core::ffi::c_uchar; 3usize],
}
#[doc = " @brief This structure represents HT capability parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_sta_ht_cap {
    #[doc = " 1 indicates HT Supported"]
    pub nrf_wifi_ht_supported: ::core::ffi::c_int,
    #[doc = " HT capabilities, as in the HT information IE"]
    pub nrf_wifi_cap: ::core::ffi::c_ushort,
    #[doc = " MCS information. nrf_wifi_event_mcs_info"]
    pub mcs: nrf_wifi_event_mcs_info,
    #[doc = " A-MPDU factor, as in 11n"]
    pub nrf_wifi_ampdu_factor: ::core::ffi::c_uchar,
    #[doc = " A-MPDU density, as in 11n"]
    pub nrf_wifi_ampdu_density: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure represents channel parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_channel {
    #[doc = " channel flags NRF_WIFI_CHAN_FLAG_FREQUENCY_ATTR_NO_IBSS"]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " maximum transmission power (in dBm)"]
    pub nrf_wifi_max_power: ::core::ffi::c_int,
    #[doc = " DFS state time"]
    pub nrf_wifi_time: ::core::ffi::c_uint,
    #[doc = " DFS CAC time in ms"]
    pub dfs_cac_msec: ::core::ffi::c_uint,
    #[doc = " Channel parameters are valid or not 1=valid"]
    pub ch_valid: ::core::ffi::c_schar,
    #[doc = " Channel center frequency"]
    pub center_frequency: ::core::ffi::c_ushort,
    #[doc = " Current dfs state"]
    pub dfs_state: ::core::ffi::c_schar,
}
#[doc = " @brief This structure represents rate information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_rate {
    #[doc = " NRF_WIFI_EVENT_GET_WIPHY_FLAG_RATE_SHORT_PREAMBLE"]
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    #[doc = " Bitrate in units of 100 kbps"]
    pub nrf_wifi_bitrate: ::core::ffi::c_ushort,
}
#[doc = " @brief VHT MCS information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_vht_mcs_info {
    #[doc = " RX MCS map 2 bits for each stream, total 8 streams"]
    pub rx_mcs_map: ::core::ffi::c_ushort,
    #[doc = " Indicates highest long GI VHT PPDU data rate\n  STA can receive. Rate expressed in units of 1 Mbps.\n  If this field is 0 this value should not be used to\n  consider the highest RX data rate supported."]
    pub rx_highest: ::core::ffi::c_ushort,
    #[doc = " TX MCS map 2 bits for each stream, total 8 streams"]
    pub tx_mcs_map: ::core::ffi::c_ushort,
    #[doc = " Indicates highest long GI VHT PPDU data rate\n  STA can transmit. Rate expressed in units of 1 Mbps.\n  If this field is 0 this value should not be used to\n  consider the highest TX data rate supported."]
    pub tx_highest: ::core::ffi::c_ushort,
}
#[doc = " @brief This structure represents VHT capability parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_sta_vht_cap {
    #[doc = " 1 indicates VHT Supported"]
    pub nrf_wifi_vht_supported: ::core::ffi::c_schar,
    #[doc = " VHT capability info"]
    pub nrf_wifi_cap: ::core::ffi::c_uint,
    #[doc = " Refer nrf_wifi_event_vht_mcs_info"]
    pub vht_mcs: nrf_wifi_event_vht_mcs_info,
}
#[doc = " @brief Frequency band information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_supported_band {
    #[doc = " No.of channels"]
    pub nrf_wifi_n_channels: ::core::ffi::c_ushort,
    #[doc = " No.of bitrates"]
    pub nrf_wifi_n_bitrates: ::core::ffi::c_ushort,
    #[doc = " Array of channels the hardware can operate in this band"]
    pub channels: [nrf_wifi_event_channel; 29usize],
    #[doc = " Array of bitrates the hardware can operate with in this band"]
    pub bitrates: [nrf_wifi_event_rate; 13usize],
    #[doc = " HT capabilities in this band"]
    pub ht_cap: nrf_wifi_event_sta_ht_cap,
    #[doc = " VHT capabilities in this band"]
    pub vht_cap: nrf_wifi_event_sta_vht_cap,
    #[doc = " the band this structure represents"]
    pub band: ::core::ffi::c_schar,
}
#[doc = " @brief Interface limits.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_iface_limit {
    #[doc = " max interface limits"]
    pub nrf_wifi_max: ::core::ffi::c_ushort,
    #[doc = " types"]
    pub nrf_wifi_types: ::core::ffi::c_ushort,
}
#[doc = " @brief This structure defines an event that represents interface combinations.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_iface_combination {
    #[doc = " channels count"]
    pub nrf_wifi_num_different_channels: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub beacon_int_infra_match: ::core::ffi::c_int,
    #[doc = " nrf_wifi_event_iface_limit"]
    pub limits: [nrf_wifi_event_iface_limit; 2usize],
    #[doc = " Max interfaces"]
    pub nrf_wifi_max_interfaces: ::core::ffi::c_ushort,
    #[doc = " Not used"]
    pub nrf_wifi_radar_detect_widths: ::core::ffi::c_uchar,
    #[doc = " Not used"]
    pub nrf_wifi_n_limits: ::core::ffi::c_uchar,
    #[doc = " Not used"]
    pub nrf_wifi_radar_detect_regions: ::core::ffi::c_uchar,
    #[doc = " Not used"]
    pub comb_valid: ::core::ffi::c_uchar,
}
#[doc = " @brief This structure represents wiphy parameters.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_get_wiphy {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Unused"]
    pub nrf_wifi_frag_threshold: ::core::ffi::c_uint,
    #[doc = " RTS threshold value"]
    pub nrf_wifi_rts_threshold: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub nrf_wifi_available_antennas_tx: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub nrf_wifi_available_antennas_rx: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub nrf_wifi_probe_resp_offload: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub tx_ant: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub rx_ant: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub split_start2_flags: ::core::ffi::c_uint,
    #[doc = " Maximum ROC duration"]
    pub max_remain_on_channel_duration: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub ap_sme_capa: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub features: ::core::ffi::c_uint,
    #[doc = " Unused"]
    pub max_acl_mac_addresses: ::core::ffi::c_uint,
    #[doc = " maximum number of associated stations supported in AP mode"]
    pub max_ap_assoc_sta: ::core::ffi::c_uint,
    #[doc = " supported cipher suites"]
    pub cipher_suites: [::core::ffi::c_uint; 30usize],
    #[doc = " wiphy flags NRF_WIFI_EVENT_GET_WIPHY_AP_UAPSD"]
    pub get_wiphy_flags: ::core::ffi::c_uint,
    #[doc = " valid parameters NRF_WIFI_GET_WIPHY_VALID_WIPHY_NAME"]
    pub params_valid: ::core::ffi::c_uint,
    #[doc = " Maximum scan IE length"]
    pub max_scan_ie_len: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub max_sched_scan_ie_len: ::core::ffi::c_ushort,
    #[doc = " bit mask of interface value of see &enum nrf_wifi_iftype"]
    pub interface_modes: ::core::ffi::c_ushort,
    #[doc = " Unused"]
    pub iface_com: [nrf_wifi_event_iface_combination; 6usize],
    #[doc = " Unused"]
    pub supp_commands: [::core::ffi::c_schar; 40usize],
    #[doc = " Retry limit for short frames"]
    pub retry_short: ::core::ffi::c_uchar,
    #[doc = " Retry limit for long frames"]
    pub retry_long: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub coverage_class: ::core::ffi::c_uchar,
    #[doc = " Maximum ssids supported in scan"]
    pub max_scan_ssids: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub max_sched_scan_ssids: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub max_match_sets: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub n_cipher_suites: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub max_num_pmkids: ::core::ffi::c_uchar,
    #[doc = " length of the extended capabilities"]
    pub extended_capabilities_len: ::core::ffi::c_uchar,
    #[doc = " Extended capabilities"]
    pub extended_capabilities: [::core::ffi::c_uchar; 10usize],
    #[doc = " Extended capabilities mask"]
    pub extended_capabilities_mask: [::core::ffi::c_uchar; 10usize],
    #[doc = " Unused"]
    pub ext_features: [::core::ffi::c_uchar; 8usize],
    #[doc = " Unused"]
    pub ext_features_len: ::core::ffi::c_uchar,
    #[doc = " Unused"]
    pub num_iface_com: ::core::ffi::c_schar,
    #[doc = " Wiphy name"]
    pub wiphy_name: [::core::ffi::c_schar; 32usize],
    #[doc = " Supported bands info. nrf_wifi_event_supported_band"]
    pub sband: [nrf_wifi_event_supported_band; 2usize],
}
#[doc = " @brief This structure represents the command used to retrieve Wireless PHY (wiphy) information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_get_wiphy {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
}
#[doc = " @brief This structure represents the command to get hardware address.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_get_ifhwaddr {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[doc = " @brief This structure represents the command used to retrieve the hardware address or\n  MAC address of the device.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_set_ifhwaddr {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Interface name"]
    pub ifacename: [::core::ffi::c_schar; 16usize],
    #[doc = " Hardware address to be set"]
    pub nrf_wifi_hwaddr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " @brief This structure represents the information related to the regulatory domain\n  of a wireless device. The regulatory domain defines the specific rules and regulations\n  that govern the usage of radio frequencies in a particular geographical region.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_reg_rules {
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " NRF_WIFI_RULE_FLAGS_NO_CCK and NRF_WIFI_RULE_FLAGS_NO_INDOOR"]
    pub rule_flags: ::core::ffi::c_uint,
    #[doc = " starting frequencry for the regulatory rule in KHz"]
    pub freq_range_start: ::core::ffi::c_uint,
    #[doc = " ending frequency for the regulatory rule in KHz"]
    pub freq_range_end: ::core::ffi::c_uint,
    #[doc = " maximum allowed bandwidth for this frequency range"]
    pub freq_range_max_bw: ::core::ffi::c_uint,
    #[doc = " maximum allowed EIRP mBm (100 * dBm)"]
    pub pwr_max_eirp: ::core::ffi::c_uint,
}
#[doc = " @brief This structure represents channels information like maximum power,\n  center frequency, channel supported and active or passive scan.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_get_reg_chn_info {
    #[doc = " center frequency in MHz"]
    pub center_frequency: ::core::ffi::c_uint,
    #[doc = " maximum transmission power (in dBm)"]
    pub max_power: ::core::ffi::c_uint,
    #[doc = " Particular channel is supported or not"]
    pub supported: ::core::ffi::c_char,
    #[doc = " Particular channel is supports passive scanning or not"]
    pub passive_channel: ::core::ffi::c_char,
    #[doc = " Particular channel is dfs or not"]
    pub dfs: ::core::ffi::c_char,
}
#[doc = " @brief This structure represents an event that contains regulatory domain information.\n"]
#[repr(C, packed)]
pub struct nrf_wifi_reg {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Country code"]
    pub nrf_wifi_alpha2: [::core::ffi::c_uchar; 2usize],
    #[doc = " Number of channel list information"]
    pub num_channels: ::core::ffi::c_uint,
    #[doc = " channels list information"]
    pub chn_info: __IncompleteArrayField<nrf_wifi_get_reg_chn_info>,
}
#[doc = " @brief This structure represents the command used to set the regulatory domain\n  for a wireless device. It allows configuring the device to adhere to the rules\n  and regulations specific to the geographical region in which it is operating.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_req_set_reg {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Indicate which of the following parameters are valid"]
    pub valid_fields: ::core::ffi::c_uint,
    #[doc = " Type of regulatory hint passed from userspace"]
    pub nrf_wifi_user_reg_hint_type: ::core::ffi::c_uint,
    #[doc = " Country code"]
    pub nrf_wifi_alpha2: [::core::ffi::c_uchar; 2usize],
}
#[doc = " @brief This structure represents the event that is generated when the regulatory domain\n is modified or updated. It contains the new regulatory domain information.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_event_regulatory_change {
    pub umac_hdr: nrf_wifi_umac_hdr,
    pub nrf_wifi_flags: ::core::ffi::c_ushort,
    pub intr: ::core::ffi::c_int,
    pub regulatory_type: ::core::ffi::c_schar,
    pub nrf_wifi_alpha2: [::core::ffi::c_uchar; 2usize],
}
#[doc = " @brief This structure represents the status code for a command. It is used to indicate\n  the outcome or result of executing a specific command. The status code provides valuable\n  information about the success, failure, or any errors encountered during the execution\n  of the command, helping to understand the current state of the device.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_event_cmd_status {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Command id. see &enum nrf_wifi_umac_commands"]
    pub cmd_id: ::core::ffi::c_uint,
    #[doc = " Status codes"]
    pub cmd_status: ::core::ffi::c_uint,
}
#[doc = " @brief This structure represents the command used to  configure quiet period.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_umac_cmd_config_quiet_period {
    #[doc = " Header nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " quiet period value in seconds"]
    pub quiet_period_in_sec: ::core::ffi::c_uint,
}
#[doc = " @}\n/\n/**\n @brief This structure defines the command used to configure the power save exit\n strategy for retrieving buffered data from the AP in power save mode.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_cmd_ps_exit_strategy {
    #[doc = " Header @ref nrf_wifi_umac_hdr"]
    pub umac_hdr: nrf_wifi_umac_hdr,
    #[doc = " Power save exit strategy"]
    pub ps_exit_strategy: ::core::ffi::c_uchar,
}
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type __gnuc_va_list = u32;
pub type va_list = u32;
#[repr(i32)]
#[doc = " @brief The status of an operation performed by the RPU driver."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_status {
    #[doc = " The operation was successful."]
    NRF_WIFI_STATUS_SUCCESS = 0,
    #[doc = " The operation failed."]
    NRF_WIFI_STATUS_FAIL = -1,
}
#[repr(u32)]
#[doc = " @brief DMA direction for a DMA operation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_osal_dma_dir {
    #[doc = " Data needs to be DMAed to the device."]
    NRF_WIFI_OSAL_DMA_DIR_TO_DEV = 0,
    #[doc = " Data needs to be DMAed from the device."]
    NRF_WIFI_OSAL_DMA_DIR_FROM_DEV = 1,
    #[doc = " Data can be DMAed in either direction i.e to or from the device."]
    NRF_WIFI_OSAL_DMA_DIR_BIDI = 2,
}
#[repr(u32)]
#[doc = " @brief The type of a tasklet."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_tasklet_type {
    #[doc = " The tasklet is a bottom half tasklet i.e it is scheduled from an interrupt context used\n for all except TX done tasklets."]
    NRF_WIFI_TASKLET_TYPE_BH = 0,
    #[doc = " The tasklet is an IRQ tasklet. It is scheduled from the Bus ISR, used internally by the\n SHIM layer."]
    NRF_WIFI_TASKLET_TYPE_IRQ = 1,
    #[doc = " The tasklet is a TX done tasklet. It is scheduled from the BH tasklet for TX done\n interrupts."]
    NRF_WIFI_TASKLET_TYPE_TX_DONE = 2,
    #[doc = " The tasklet is an RX tasklet. It is scheduled from the BH tasklet for RX interrupts."]
    NRF_WIFI_TASKLET_TYPE_RX = 3,
    #[doc = " The maximum number of tasklet types."]
    NRF_WIFI_TASKLET_TYPE_MAX = 4,
}
#[doc = " @brief Structure representing a host map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_osal_host_map {
    #[doc = " The address of the host map."]
    pub addr: ::core::ffi::c_ulong,
    #[doc = " The size of the host map."]
    pub size: ::core::ffi::c_ulong,
}
#[doc = " @brief Structure representing the private data of the OSAL layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_osal_priv {
    #[doc = " Pointer to the OSAL operations."]
    pub ops: *const nrf_wifi_osal_ops,
}
#[repr(u32)]
#[doc = " @brief The type of assertion operation to be performed."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_assert_op_type {
    #[doc = " The assertion check for equality."]
    NRF_WIFI_ASSERT_EQUAL_TO = 0,
    #[doc = " The assertion check for non-equality."]
    NRF_WIFI_ASSERT_NOT_EQUAL_TO = 1,
    #[doc = " The assertion check for lesser value."]
    NRF_WIFI_ASSERT_LESS_THAN = 2,
    #[doc = " The assertion check for equal or lesser."]
    NRF_WIFI_ASSERT_LESS_THAN_EQUAL_TO = 3,
    #[doc = " The assertion check for condition of more than value."]
    NRF_WIFI_ASSERT_GREATER_THAN = 4,
    #[doc = " The assertion check for condition equal or more than value."]
    NRF_WIFI_ASSERT_GREATER_THAN_EQUAL_TO = 5,
}
#[doc = " @brief struct nrf_wifi_osal_ops - Ops to be provided by a specific OS implementation.\n\n This structure exposes Ops which need to be implemented by the underlying OS\n in order for the WLAN driver to work. The Ops can be directly mapped to OS\n primitives where a one-to-one mapping is available. In case a mapping is not\n available, an equivalent function will need to be implemented and that\n function will then need to be mapped to the corresponding Op."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_osal_ops {
    #[doc = " @brief Allocate memory.\n\n @param size The size of the memory to allocate for control messages.\n @return A pointer to the start of the allocated memory."]
    pub mem_alloc: ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Allocate zero-initialized memory for control messages.\n\n @param size The size of the memory to allocate.\n @return A pointer to the start of the allocated memory."]
    pub mem_zalloc: ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Free memory allocated for control messages.\n\n @param buf A pointer to the memory to free."]
    pub mem_free: ::core::option::Option<unsafe extern "C" fn(buf: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Allocate zero-initialized memory for data.\n\n @param size The size of the memory to allocate.\n @return A pointer to the start of the allocated memory."]
    pub data_mem_zalloc: ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Free memory allocated for data.\n\n @param buf A pointer to the memory to free."]
    pub data_mem_free: ::core::option::Option<unsafe extern "C" fn(buf: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Copy memory.\n\n @param dest A pointer to the destination memory.\n @param src A pointer to the source memory.\n @param count The number of bytes to copy.\n @return A pointer to the destination memory."]
    pub mem_cpy: ::core::option::Option<
        unsafe extern "C" fn(
            dest: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Set memory.\n\n @param start A pointer to the start of the memory block.\n @param val The value to set.\n @param size The size of the memory block.\n @return A pointer to the start of the memory block."]
    pub mem_set: ::core::option::Option<
        unsafe extern "C" fn(
            start: *mut ::core::ffi::c_void,
            val: ::core::ffi::c_int,
            size: usize,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Compare memory.\n\n @param addr1 A pointer to the first memory block.\n @param addr2 A pointer to the second memory block.\n @param size The size of the memory blocks.\n @return 0 if the memory blocks are equal, a negative value if addr1 is less\n\t\tthan addr2, a positive value if addr1 is greater than addr2."]
    pub mem_cmp: ::core::option::Option<
        unsafe extern "C" fn(
            addr1: *const ::core::ffi::c_void,
            addr2: *const ::core::ffi::c_void,
            size: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " @brief Map IO memory into CPU space.\n\n @param addr The address of the IO memory.\n @param size The size of the IO memory.\n @return A pointer to the mapped IO memory."]
    pub iomem_mmap: ::core::option::Option<
        unsafe extern "C" fn(addr: ::core::ffi::c_ulong, size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Unmap IO memory from CPU space.\n\n @param addr A pointer to the mapped IO memory."]
    pub iomem_unmap: ::core::option::Option<unsafe extern "C" fn(addr: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Read a 32-bit value from a device register using a memory mapped address.\n\n @param addr A pointer to the memory mapped address.\n @return The value read from the device register."]
    pub iomem_read_reg32:
        ::core::option::Option<unsafe extern "C" fn(addr: *const ::core::ffi::c_void) -> ::core::ffi::c_uint>,
    #[doc = " @brief Write a 32-bit value to a device register using a memory mapped address.\n\n @param addr A pointer to the memory mapped address.\n @param val The value to write to the device register."]
    pub iomem_write_reg32:
        ::core::option::Option<unsafe extern "C" fn(addr: *mut ::core::ffi::c_void, val: ::core::ffi::c_uint)>,
    #[doc = " @brief Copy data from memory mapped device memory to host memory.\n\n @param dest A pointer to the destination memory.\n @param src A pointer to the source memory.\n @param count The number of bytes to copy."]
    pub iomem_cpy_from: ::core::option::Option<
        unsafe extern "C" fn(dest: *mut ::core::ffi::c_void, src: *const ::core::ffi::c_void, count: usize),
    >,
    #[doc = " @brief Copy data from host memory to memory mapped device memory.\n\n @param dest A pointer to the destination memory.\n @param src A pointer to the source memory.\n @param count The number of bytes to copy."]
    pub iomem_cpy_to: ::core::option::Option<
        unsafe extern "C" fn(dest: *mut ::core::ffi::c_void, src: *const ::core::ffi::c_void, count: usize),
    >,
    #[doc = " @brief Read a 32-bit value from a QSPI device register.\n\n @param priv A pointer to the QSPI device private data.\n @param addr The address of the device register.\n @return The value read from the device register."]
    pub qspi_read_reg32: ::core::option::Option<
        unsafe extern "C" fn(priv_: *mut ::core::ffi::c_void, addr: ::core::ffi::c_ulong) -> ::core::ffi::c_uint,
    >,
    #[doc = " @brief Write a 32-bit value to a QSPI device register.\n\n @param priv A pointer to the QSPI device private data.\n @param addr The address of the device register.\n @param val The value to write to the device register."]
    pub qspi_write_reg32: ::core::option::Option<
        unsafe extern "C" fn(priv_: *mut ::core::ffi::c_void, addr: ::core::ffi::c_ulong, val: ::core::ffi::c_uint),
    >,
    #[doc = " @brief Copy data from QSPI device memory to host memory.\n\n @param priv A pointer to the QSPI device private data.\n @param dest A pointer to the destination memory.\n @param addr The address of the device memory.\n @param count The number of bytes to copy."]
    pub qspi_cpy_from: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            dest: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            count: usize,
        ),
    >,
    #[doc = " @brief Copy data from host memory to QSPI device memory.\n\n @param priv A pointer to the QSPI device private data.\n @param addr The address of the device memory.\n @param src A pointer to the source memory.\n @param count The number of bytes to copy."]
    pub qspi_cpy_to: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            src: *const ::core::ffi::c_void,
            count: usize,
        ),
    >,
    #[doc = " @brief Read a 32-bit value from a SPI device register.\n\n @param priv A pointer to the SPI device private data.\n @param addr The address of the device register.\n @return The value read from the device register."]
    pub spi_read_reg32: ::core::option::Option<
        unsafe extern "C" fn(priv_: *mut ::core::ffi::c_void, addr: ::core::ffi::c_ulong) -> ::core::ffi::c_uint,
    >,
    #[doc = " @brief Write a 32-bit value to a SPI device register.\n\n @param priv A pointer to the SPI device private data.\n @param addr The address of the device register.\n @param val The value to write to the device register."]
    pub spi_write_reg32: ::core::option::Option<
        unsafe extern "C" fn(priv_: *mut ::core::ffi::c_void, addr: ::core::ffi::c_ulong, val: ::core::ffi::c_uint),
    >,
    #[doc = " @brief Copy data from SPI device memory to host memory.\n\n @param priv A pointer to the SPI device private data.\n @param dest A pointer to the destination memory.\n @param addr The address of the device memory.\n @param count The number of bytes to copy."]
    pub spi_cpy_from: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            dest: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            count: usize,
        ),
    >,
    #[doc = " @brief Copy data from host memory to SPI device memory.\n\n @param priv A pointer to the SPI device private data.\n @param addr The address of the device memory.\n @param src A pointer to the source memory.\n @param count The number of bytes to copy."]
    pub spi_cpy_to: ::core::option::Option<
        unsafe extern "C" fn(
            priv_: *mut ::core::ffi::c_void,
            addr: ::core::ffi::c_ulong,
            src: *const ::core::ffi::c_void,
            count: usize,
        ),
    >,
    #[doc = " @brief Allocate a spinlock.\n\n @return A pointer to the allocated spinlock."]
    pub spinlock_alloc: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Free a spinlock.\n\n @param lock A pointer to the spinlock to free."]
    pub spinlock_free: ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Initialize a spinlock.\n\n @param lock A pointer to the spinlock to initialize."]
    pub spinlock_init: ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Acquire a spinlock.\n\n @param lock A pointer to the spinlock to acquire."]
    pub spinlock_take: ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Release a spinlock.\n\n @param lock A pointer to the spinlock to release."]
    pub spinlock_rel: ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Save interrupt states, disable interrupts, and acquire a spinlock.\n\n @param lock A pointer to the spinlock to acquire.\n @param flags A pointer to store the saved interrupt states."]
    pub spinlock_irq_take:
        ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void, flags: *mut ::core::ffi::c_ulong)>,
    #[doc = " @brief Restore interrupt states and release a spinlock.\n\n @param lock A pointer to the spinlock to release.\n @param flags A pointer to the saved interrupt states."]
    pub spinlock_irq_rel:
        ::core::option::Option<unsafe extern "C" fn(lock: *mut ::core::ffi::c_void, flags: *mut ::core::ffi::c_ulong)>,
    #[doc = " @brief Log a debug message.\n\n @param fmt The format string of the message.\n @param args The arguments for the format string.\n @return The number of characters written."]
    pub log_dbg: ::core::option::Option<
        unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, args: va_list) -> ::core::ffi::c_int,
    >,
    #[doc = " @brief Log an informational message.\n\n @param fmt The format string of the message.\n @param args The arguments for the format string.\n @return The number of characters written."]
    pub log_info: ::core::option::Option<
        unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, args: va_list) -> ::core::ffi::c_int,
    >,
    #[doc = " @brief Log an error message.\n\n @param fmt The format string of the message.\n @param args The arguments for the format string.\n @return The number of characters written."]
    pub log_err: ::core::option::Option<
        unsafe extern "C" fn(fmt: *const ::core::ffi::c_char, args: va_list) -> ::core::ffi::c_int,
    >,
    #[doc = " @brief Allocate a linked list node.\n\n @return A pointer to the allocated linked list node."]
    pub llist_node_alloc: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Allocate a linked list node from control pool.\n\n @return A pointer to the allocated linked list node."]
    pub ctrl_llist_node_alloc: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Free a linked list node.\n\n @param node A pointer to the linked list node to free."]
    pub llist_node_free: ::core::option::Option<unsafe extern "C" fn(node: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Free a linked list node from control pool.\n\n @param node A pointer to the linked list node to free."]
    pub ctrl_llist_node_free: ::core::option::Option<unsafe extern "C" fn(node: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Get the pointer to the data which the linked list node points to.\n\n @param node A pointer to the linked list node.\n @return A pointer to the data."]
    pub llist_node_data_get:
        ::core::option::Option<unsafe extern "C" fn(node: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Store the pointer to the data in the linked list node.\n\n @param node A pointer to the linked list node.\n @param data A pointer to the data."]
    pub llist_node_data_set:
        ::core::option::Option<unsafe extern "C" fn(node: *mut ::core::ffi::c_void, data: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Allocate a linked list.\n\n @return A pointer to the allocated linked list."]
    pub llist_alloc: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Allocate a linked list for control path.\n\n @return A pointer to the allocated linked list."]
    pub ctrl_llist_alloc: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Free a linked list.\n\n @param llist A pointer to the linked list to free."]
    pub llist_free: ::core::option::Option<unsafe extern "C" fn(llist: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Free a linked list for control path.\n\n @param llist A pointer to the linked list to free."]
    pub ctrl_llist_free: ::core::option::Option<unsafe extern "C" fn(llist: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Initialize a linked list.\n\n @param llist A pointer to the linked list to initialize."]
    pub llist_init: ::core::option::Option<unsafe extern "C" fn(llist: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Add a linked list node to the tail of a linked list.\n\n @param llist A pointer to the linked list.\n @param llist_node A pointer to the linked list node to add."]
    pub llist_add_node_tail: ::core::option::Option<
        unsafe extern "C" fn(llist: *mut ::core::ffi::c_void, llist_node: *mut ::core::ffi::c_void),
    >,
    #[doc = " @brief Add a linked list node to the head of a linked list.\n\n @param llist A pointer to the linked list.\n @param llist_node A pointer to the linked list node to add."]
    pub llist_add_node_head: ::core::option::Option<
        unsafe extern "C" fn(llist: *mut ::core::ffi::c_void, llist_node: *mut ::core::ffi::c_void),
    >,
    #[doc = " @brief Return the head node from a linked list.\n\n @param llist A pointer to the linked list.\n @return A pointer to the head node, or NULL if the linked list is empty."]
    pub llist_get_node_head:
        ::core::option::Option<unsafe extern "C" fn(llist: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Return the node next to the given node in the linked list.\n\n @param llist A pointer to the linked list.\n @param llist_node A pointer to the current node.\n @return A pointer to the next node."]
    pub llist_get_node_nxt: ::core::option::Option<
        unsafe extern "C" fn(
            llist: *mut ::core::ffi::c_void,
            llist_node: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Remove a node from the linked list.\n\n @param llist A pointer to the linked list.\n @param llist_node A pointer to the node to remove."]
    pub llist_del_node: ::core::option::Option<
        unsafe extern "C" fn(llist: *mut ::core::ffi::c_void, llist_node: *mut ::core::ffi::c_void),
    >,
    #[doc = " @brief Return the length of the linked list.\n\n @param llist A pointer to the linked list.\n @return The length of the linked list."]
    pub llist_len: ::core::option::Option<unsafe extern "C" fn(llist: *mut ::core::ffi::c_void) -> ::core::ffi::c_uint>,
    #[doc = " @brief Allocate a network buffer.\n\n @param size The size of the network buffer.\n @return A pointer to the allocated network buffer."]
    pub nbuf_alloc: ::core::option::Option<unsafe extern "C" fn(size: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Free a network buffer.\n\n @param nbuf A pointer to the network buffer to free."]
    pub nbuf_free: ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Reserve headroom at the beginning of the data area of a network buffer.\n\n @param nbuf A pointer to the network buffer.\n @param size The size of the headroom to reserve."]
    pub nbuf_headroom_res:
        ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void, size: ::core::ffi::c_uint)>,
    #[doc = " @brief Get the size of the reserved headroom at the beginning of the\n data area of a network buffer.\n\n @param nbuf A pointer to the network buffer.\n @return The size of the reserved headroom."]
    pub nbuf_headroom_get:
        ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> ::core::ffi::c_uint>,
    #[doc = " @brief Get the size of the data area of a network buffer.\n\n @param nbuf A pointer to the network buffer.\n @return The size of the data area."]
    pub nbuf_data_size:
        ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> ::core::ffi::c_uint>,
    #[doc = " @brief Get the pointer to the data area of a network buffer.\n\n @param nbuf A pointer to the network buffer.\n @return A pointer to the data area."]
    pub nbuf_data_get:
        ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Increase the data area of a network buffer at the end of the area.\n\n @param nbuf A pointer to the network buffer.\n @param size The size to increase the data area by.\n @return A pointer to the beginning of the data area."]
    pub nbuf_data_put: ::core::option::Option<
        unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void, size: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Increase the data area of a network buffer at the start of the area.\n\n @param nbuf A pointer to the network buffer.\n @param size The size to increase the data area by.\n @return A pointer to the beginning of the data area."]
    pub nbuf_data_push: ::core::option::Option<
        unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void, size: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Decrease the data area of a network buffer at the start of the area.\n\n @param nbuf A pointer to the network buffer.\n @param size The size to decrease the data area by.\n @return A pointer to the beginning of the data area."]
    pub nbuf_data_pull: ::core::option::Option<
        unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void, size: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Get the priority of a network buffer.\n\n @param nbuf A pointer to the network buffer.\n @return The priority of the network buffer."]
    pub nbuf_get_priority:
        ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> ::core::ffi::c_uchar>,
    #[doc = " @brief Get the checksum status of a network buffer.\n\n @param nbuf A pointer to the network buffer.\n @return The checksum status of the network buffer."]
    pub nbuf_get_chksum_done:
        ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void) -> ::core::ffi::c_uchar>,
    #[doc = " @brief Set the checksum status of a network buffer.\n\n @param nbuf A pointer to the network buffer.\n @param chksum_done The checksum status to set."]
    pub nbuf_set_chksum_done:
        ::core::option::Option<unsafe extern "C" fn(nbuf: *mut ::core::ffi::c_void, chksum_done: ::core::ffi::c_uchar)>,
    #[doc = " @brief Allocate a tasklet structure.\n\n @param type The type of the tasklet.\n @return A pointer to the allocated tasklet structure."]
    pub tasklet_alloc:
        ::core::option::Option<unsafe extern "C" fn(type_: ::core::ffi::c_int) -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Free a tasklet structure.\n\n @param tasklet A pointer to the tasklet structure to free."]
    pub tasklet_free: ::core::option::Option<unsafe extern "C" fn(tasklet: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Initialize a tasklet structure.\n\n @param tasklet A pointer to the tasklet structure to initialize.\n @param callback The callback function to be invoked when the tasklet is scheduled.\n @param data The data to be passed to the callback function."]
    pub tasklet_init: ::core::option::Option<
        unsafe extern "C" fn(
            tasklet: *mut ::core::ffi::c_void,
            callback: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_ulong)>,
            data: ::core::ffi::c_ulong,
        ),
    >,
    #[doc = " @brief Schedule a tasklet.\n\n @param tasklet A pointer to the tasklet to schedule."]
    pub tasklet_schedule: ::core::option::Option<unsafe extern "C" fn(tasklet: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Terminate a tasklet.\n\n @param tasklet A pointer to the tasklet to terminate."]
    pub tasklet_kill: ::core::option::Option<unsafe extern "C" fn(tasklet: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Sleep for a specified number of milliseconds.\n\n @param msecs The number of milliseconds to sleep.\n @return 0 on success, a negative value on failure."]
    pub sleep_ms: ::core::option::Option<unsafe extern "C" fn(msecs: ::core::ffi::c_int) -> ::core::ffi::c_int>,
    #[doc = " @brief Delay for a specified number of microseconds.\n\n @param usecs The number of microseconds to delay.\n @return 0 on success, a negative value on failure."]
    pub delay_us: ::core::option::Option<unsafe extern "C" fn(usecs: ::core::ffi::c_int) -> ::core::ffi::c_int>,
    #[doc = " @brief Get the current time of the day in microseconds.\n\n @return The current time of the day in microseconds."]
    pub time_get_curr_us: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_ulong>,
    #[doc = " @brief Return the time elapsed in microseconds since a specified time instant.\n\n @param start_time The time instant to measure the elapsed time from.\n @return The time elapsed in microseconds."]
    pub time_elapsed_us:
        ::core::option::Option<unsafe extern "C" fn(start_time: ::core::ffi::c_ulong) -> ::core::ffi::c_uint>,
    #[doc = " @brief Get the current time of the day in milliseconds.\n\n @return The current time of the day in milliseconds."]
    pub time_get_curr_ms: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_ulong>,
    #[doc = " @brief Return the time elapsed in milliseconds since a specified time instant.\n\n @param start_time The time instant to measure the elapsed time from.\n @return The time elapsed in milliseconds."]
    pub time_elapsed_ms:
        ::core::option::Option<unsafe extern "C" fn(start_time_us: ::core::ffi::c_ulong) -> ::core::ffi::c_uint>,
    #[doc = " @brief Initialize the PCIe bus.\n\n @param dev_name The name of the PCIe device.\n @param vendor_id The vendor ID of the PCIe device.\n @param sub_vendor_id The sub-vendor ID of the PCIe device.\n @param device_id The device ID of the PCIe device.\n @param sub_device_id The sub-device ID of the PCIe device.\n @return A pointer to the initialized PCIe bus."]
    pub bus_pcie_init: ::core::option::Option<
        unsafe extern "C" fn(
            dev_name: *const ::core::ffi::c_char,
            vendor_id: ::core::ffi::c_uint,
            sub_vendor_id: ::core::ffi::c_uint,
            device_id: ::core::ffi::c_uint,
            sub_device_id: ::core::ffi::c_uint,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Deinitialize the PCIe bus.\n\n @param os_pcie_priv A pointer to the PCIe bus."]
    pub bus_pcie_deinit: ::core::option::Option<unsafe extern "C" fn(os_pcie_priv: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Add a PCIe device to the bus.\n\n @param pcie_priv A pointer to the PCIe bus.\n @param osal_pcie_dev_ctx A pointer to the PCIe device context.\n @return A pointer to the added PCIe device."]
    pub bus_pcie_dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            pcie_priv: *mut ::core::ffi::c_void,
            osal_pcie_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Remove a PCIe device from the bus.\n\n @param os_pcie_dev_ctx A pointer to the PCIe device."]
    pub bus_pcie_dev_rem: ::core::option::Option<unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Initialize a PCIe device.\n\n @param os_pcie_dev_ctx A pointer to the PCIe device.\n @return The status of the initialization."]
    pub bus_pcie_dev_init:
        ::core::option::Option<unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status>,
    #[doc = " @brief Deinitialize a PCIe device.\n\n @param os_pcie_dev_ctx A pointer to the PCIe device."]
    pub bus_pcie_dev_deinit: ::core::option::Option<unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Register an interrupt handler for a PCIe device.\n\n @param os_pcie_dev_ctx A pointer to the PCIe device.\n @param callbk_data The data to be passed to the callback function.\n @param callback_fn The callback function to be invoked when an interrupt occurs.\n @return The status of the registration."]
    pub bus_pcie_dev_intr_reg: ::core::option::Option<
        unsafe extern "C" fn(
            os_pcie_dev_ctx: *mut ::core::ffi::c_void,
            callbk_data: *mut ::core::ffi::c_void,
            callback_fn: ::core::option::Option<
                unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
            >,
        ) -> nrf_wifi_status,
    >,
    #[doc = " @brief Unregister the interrupt handler for a PCIe device.\n\n @param os_pcie_dev_ctx A pointer to the PCIe device."]
    pub bus_pcie_dev_intr_unreg:
        ::core::option::Option<unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Map a DMA buffer for a PCIe device.\n\n @param os_pcie_dev_ctx A pointer to the PCIe device.\n @param virt_addr The virtual address of the buffer.\n @param size The size of the buffer.\n @param dir The direction of the DMA transfer.\n @return A pointer to the mapped DMA buffer."]
    pub bus_pcie_dev_dma_map: ::core::option::Option<
        unsafe extern "C" fn(
            os_pcie_dev_ctx: *mut ::core::ffi::c_void,
            virt_addr: *mut ::core::ffi::c_void,
            size: usize,
            dir: nrf_wifi_osal_dma_dir,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Unmap a DMA buffer for a PCIe device.\n\n @param os_pcie_dev_ctx A pointer to the PCIe device.\n @param dma_addr The DMA address of the buffer.\n @param size The size of the buffer.\n @param dir The direction of the DMA transfer."]
    pub bus_pcie_dev_dma_unmap: ::core::option::Option<
        unsafe extern "C" fn(
            os_pcie_dev_ctx: *mut ::core::ffi::c_void,
            dma_addr: *mut ::core::ffi::c_void,
            size: usize,
            dir: nrf_wifi_osal_dma_dir,
        ),
    >,
    #[doc = " @brief Get the host mapping of a PCIe device.\n\n @param os_pcie_dev_ctx A pointer to the PCIe device.\n @param host_map A pointer to the host mapping structure."]
    pub bus_pcie_dev_host_map_get: ::core::option::Option<
        unsafe extern "C" fn(os_pcie_dev_ctx: *mut ::core::ffi::c_void, host_map: *mut nrf_wifi_osal_host_map),
    >,
    #[doc = " @brief Initialize the QSPI bus.\n\n @return A pointer to the initialized QSPI bus."]
    pub bus_qspi_init: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Deinitialize the QSPI bus.\n\n @param os_qspi_priv A pointer to the QSPI bus."]
    pub bus_qspi_deinit: ::core::option::Option<unsafe extern "C" fn(os_qspi_priv: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Add a QSPI device to the bus.\n\n @param qspi_priv A pointer to the QSPI bus.\n @param osal_qspi_dev_ctx A pointer to the QSPI device context.\n @return A pointer to the added QSPI device."]
    pub bus_qspi_dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            qspi_priv: *mut ::core::ffi::c_void,
            osal_qspi_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Remove a QSPI device from the bus.\n\n @param os_qspi_dev_ctx A pointer to the QSPI device."]
    pub bus_qspi_dev_rem: ::core::option::Option<unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Initialize a QSPI device.\n\n @param os_qspi_dev_ctx A pointer to the QSPI device.\n @return The status of the initialization."]
    pub bus_qspi_dev_init:
        ::core::option::Option<unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status>,
    #[doc = " @brief Deinitialize a QSPI device.\n\n @param os_qspi_dev_ctx A pointer to the QSPI device."]
    pub bus_qspi_dev_deinit: ::core::option::Option<unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Register an interrupt handler for a QSPI device.\n\n @param os_qspi_dev_ctx A pointer to the QSPI device.\n @param callbk_data The data to be passed to the callback function.\n @param callback_fn The callback function to be invoked when an interrupt occurs.\n @return The status of the registration."]
    pub bus_qspi_dev_intr_reg: ::core::option::Option<
        unsafe extern "C" fn(
            os_qspi_dev_ctx: *mut ::core::ffi::c_void,
            callbk_data: *mut ::core::ffi::c_void,
            callback_fn: ::core::option::Option<
                unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
            >,
        ) -> nrf_wifi_status,
    >,
    #[doc = " @brief Unregister the interrupt handler for a QSPI device.\n\n @param os_qspi_dev_ctx A pointer to the QSPI device."]
    pub bus_qspi_dev_intr_unreg:
        ::core::option::Option<unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Get the host mapping of a QSPI device.\n\n @param os_qspi_dev_ctx A pointer to the QSPI device.\n @param host_map A pointer to the host mapping structure."]
    pub bus_qspi_dev_host_map_get: ::core::option::Option<
        unsafe extern "C" fn(os_qspi_dev_ctx: *mut ::core::ffi::c_void, host_map: *mut nrf_wifi_osal_host_map),
    >,
    #[doc = " @brief Initialize the SPI bus.\n\n @return A pointer to the initialized SPI bus."]
    pub bus_spi_init: ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_void>,
    #[doc = " @brief Deinitialize the SPI bus.\n\n @param os_spi_priv A pointer to the SPI bus."]
    pub bus_spi_deinit: ::core::option::Option<unsafe extern "C" fn(os_spi_priv: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Add a SPI device to the bus.\n\n @param spi_priv A pointer to the SPI bus.\n @param osal_spi_dev_ctx A pointer to the SPI device context.\n @return A pointer to the added SPI device."]
    pub bus_spi_dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            spi_priv: *mut ::core::ffi::c_void,
            osal_spi_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Remove a SPI device from the bus.\n\n @param os_spi_dev_ctx A pointer to the SPI device."]
    pub bus_spi_dev_rem: ::core::option::Option<unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Initialize a SPI device.\n\n @param os_spi_dev_ctx A pointer to the SPI device.\n @return The status of the initialization."]
    pub bus_spi_dev_init:
        ::core::option::Option<unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status>,
    #[doc = " @brief Deinitialize a SPI device.\n\n @param os_spi_dev_ctx A pointer to the SPI device."]
    pub bus_spi_dev_deinit: ::core::option::Option<unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Register an interrupt handler for a SPI device.\n\n @param os_spi_dev_ctx A pointer to the SPI device.\n @param callbk_data The data to be passed to the callback function.\n @param callback_fn The callback function to be invoked when an interrupt occurs.\n @return The status of the registration."]
    pub bus_spi_dev_intr_reg: ::core::option::Option<
        unsafe extern "C" fn(
            os_spi_dev_ctx: *mut ::core::ffi::c_void,
            callbk_data: *mut ::core::ffi::c_void,
            callback_fn: ::core::option::Option<
                unsafe extern "C" fn(callbk_data: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
            >,
        ) -> nrf_wifi_status,
    >,
    #[doc = " @brief Unregister the interrupt handler for a SPI device.\n\n @param os_spi_dev_ctx A pointer to the SPI device."]
    pub bus_spi_dev_intr_unreg: ::core::option::Option<unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Get the host mapping of a SPI device.\n\n @param os_spi_dev_ctx A pointer to the SPI device.\n @param host_map A pointer to the host mapping structure."]
    pub bus_spi_dev_host_map_get: ::core::option::Option<
        unsafe extern "C" fn(os_spi_dev_ctx: *mut ::core::ffi::c_void, host_map: *mut nrf_wifi_osal_host_map),
    >,
    #[doc = " @brief Assert a condition and display an error message if the condition is false.\n\n @param test_val The value to test.\n @param val The value to compare against.\n @param op The comparison operator.\n @param assert_msg The error message to display."]
    pub assert: ::core::option::Option<
        unsafe extern "C" fn(
            test_val: ::core::ffi::c_int,
            val: ::core::ffi::c_int,
            op: nrf_wifi_assert_op_type,
            assert_msg: *mut ::core::ffi::c_char,
        ),
    >,
    #[doc = " @brief Get the length of a string.\n\n @param str A pointer to the string.\n @return The length of the string."]
    pub strlen: ::core::option::Option<unsafe extern "C" fn(str_: *const ::core::ffi::c_void) -> ::core::ffi::c_uint>,
    #[doc = " @brief Get a random 8-bit value.\n\n @return A random 8-bit value."]
    pub rand8_get: ::core::option::Option<unsafe extern "C" fn() -> ::core::ffi::c_uchar>,
}
#[doc = " @brief Ops to be provided by a particular bus implementation.\n\n This structure defines the operations that need to be implemented\n by a specific bus implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_bal_ops {
    #[doc = " @brief Initialize the bus.\n\n @param cfg_params Pointer to the configuration parameters.\n @param intr_callbk_fn Pointer to the interrupt callback function.\n @return Pointer to the initialized instance of the bus."]
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            cfg_params: *mut ::core::ffi::c_void,
            intr_callbk_fn: ::core::option::Option<
                unsafe extern "C" fn(hal_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status,
            >,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Deinitialize the bus.\n\n @param bus_priv Pointer to the bus private data."]
    pub deinit: ::core::option::Option<unsafe extern "C" fn(bus_priv: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Add a device to the bus.\n\n @param bus_priv Pointer to the bus private data.\n @param bal_dev_ctx Pointer to the BAL device context.\n @return Pointer to the added device context."]
    pub dev_add: ::core::option::Option<
        unsafe extern "C" fn(
            bus_priv: *mut ::core::ffi::c_void,
            bal_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " @brief Remove a device from the bus.\n\n @param bus_dev_ctx Pointer to the bus device context."]
    pub dev_rem: ::core::option::Option<unsafe extern "C" fn(bus_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Initialize a device on the bus.\n\n @param bus_dev_ctx Pointer to the bus device context.\n @return Status of the device initialization."]
    pub dev_init:
        ::core::option::Option<unsafe extern "C" fn(bus_dev_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status>,
    #[doc = " @brief Deinitialize a device on the bus.\n\n @param bus_dev_ctx Pointer to the bus device context."]
    pub dev_deinit: ::core::option::Option<unsafe extern "C" fn(bus_dev_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " @brief Read a word from the bus.\n\n @param bus_dev_ctx Pointer to the bus device context.\n @param addr_offset Address offset.\n @return The read word."]
    pub read_word: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            addr_offset: ::core::ffi::c_ulong,
        ) -> ::core::ffi::c_uint,
    >,
    #[doc = " @brief Write a word to the bus.\n\n @param bus_dev_ctx Pointer to the bus device context.\n @param addr_offset Address offset.\n @param val Value to write."]
    pub write_word: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            addr_offset: ::core::ffi::c_ulong,
            val: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " @brief Read a block of data from the bus.\n\n @param bus_dev_ctx Pointer to the bus device context.\n @param dest_addr Destination address.\n @param src_addr_offset Source address offset.\n @param len Length of the block to read."]
    pub read_block: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            dest_addr: *mut ::core::ffi::c_void,
            src_addr_offset: ::core::ffi::c_ulong,
            len: usize,
        ),
    >,
    #[doc = " @brief Write a block of data to the bus.\n\n @param bus_dev_ctx Pointer to the bus device context.\n @param dest_addr_offset Destination address offset.\n @param src_addr Pointer to the source address.\n @param len Length of the block to write."]
    pub write_block: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            dest_addr_offset: ::core::ffi::c_ulong,
            src_addr: *const ::core::ffi::c_void,
            len: usize,
        ),
    >,
    #[doc = " @brief Map a DMA buffer.\n\n @param bus_dev_ctx Pointer to the bus device context.\n @param virt_addr Virtual address of the buffer.\n @param len Length of the buffer.\n @param dma_dir DMA direction.\n @return Physical address of the mapped buffer."]
    pub dma_map: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            virt_addr: ::core::ffi::c_ulong,
            len: usize,
            dma_dir: nrf_wifi_osal_dma_dir,
        ) -> ::core::ffi::c_ulong,
    >,
    #[doc = " @brief Unmap a DMA buffer.\n\n @param bus_dev_ctx Pointer to the bus device context.\n @param phy_addr Physical address of the buffer.\n @param len Length of the buffer.\n @param dma_dir DMA direction.\n @return Physical address of the unmapped buffer."]
    pub dma_unmap: ::core::option::Option<
        unsafe extern "C" fn(
            bus_dev_ctx: *mut ::core::ffi::c_void,
            phy_addr: ::core::ffi::c_ulong,
            len: usize,
            dma_dir: nrf_wifi_osal_dma_dir,
        ) -> ::core::ffi::c_ulong,
    >,
}
#[doc = " @brief Structure holding configuration parameters for the BAL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_bal_cfg_params {
    #[doc = " Base address of the packet RAM."]
    pub addr_pktram_base: ::core::ffi::c_ulong,
}
#[doc = " @brief Structure holding context information for the BAL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_bal_priv {
    #[doc = " Pointer to a specific bus context."]
    pub bus_priv: *mut ::core::ffi::c_void,
    #[doc = " Pointer to bus operations provided by a specific bus implementation."]
    pub ops: *mut nrf_wifi_bal_ops,
    #[doc = " Callback function for device initialization."]
    pub init_dev_callbk_fn:
        ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status>,
    #[doc = " Callback function for device deinitialization."]
    pub deinit_dev_callbk_fn: ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>,
    #[doc = " Callback function for handling interrupts."]
    pub intr_callbk_fn: ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status>,
}
#[doc = " @brief Structure holding the device context for the BAL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_bal_dev_ctx {
    #[doc = " Pointer to the BAL private context."]
    pub bpriv: *mut nrf_wifi_bal_priv,
    #[doc = " Pointer to the HAL device context."]
    pub hal_dev_ctx: *mut ::core::ffi::c_void,
    #[doc = " Pointer to the bus device context."]
    pub bus_dev_ctx: *mut ::core::ffi::c_void,
}
#[repr(u32)]
#[doc = " @brief Enumeration of RPU processor types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RPU_PROC_TYPE {
    #[doc = " MCU LMAC processor type"]
    RPU_PROC_TYPE_MCU_LMAC = 0,
    #[doc = " MCU UMAC processor type"]
    RPU_PROC_TYPE_MCU_UMAC = 1,
    #[doc = " Maximum number of processor types"]
    RPU_PROC_TYPE_MAX = 2,
}
#[repr(u32)]
#[doc = " @brief Enumeration of NRF Wi-Fi region types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NRF_WIFI_REGION_TYPE {
    #[doc = " GRAM region type"]
    NRF_WIFI_REGION_TYPE_GRAM = 0,
    #[doc = " PKTRAM region type"]
    NRF_WIFI_REGION_TYPE_PKTRAM = 1,
    #[doc = " SYSBUS region type"]
    NRF_WIFI_REGION_TYPE_SYSBUS = 2,
    #[doc = " PBUS region type"]
    NRF_WIFI_REGION_TYPE_PBUS = 3,
}
#[repr(u32)]
#[doc = " @brief Enumeration of NRF Wi-Fi HAL message types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NRF_WIFI_HAL_MSG_TYPE {
    #[doc = " Command control message type"]
    NRF_WIFI_HAL_MSG_TYPE_CMD_CTRL = 0,
    #[doc = " Event message type"]
    NRF_WIFI_HAL_MSG_TYPE_EVENT = 1,
    #[doc = " Command data RX message type"]
    NRF_WIFI_HAL_MSG_TYPE_CMD_DATA_RX = 2,
    #[doc = " Command data management message type"]
    NRF_WIFI_HAL_MSG_TYPE_CMD_DATA_MGMT = 3,
    #[doc = " Command data TX message type"]
    NRF_WIFI_HAL_MSG_TYPE_CMD_DATA_TX = 4,
    #[doc = " Maximum number of message types"]
    NRF_WIFI_HAL_MSG_TYPE_MAX = 5,
}
#[repr(u32)]
#[doc = " @brief Enumeration of NRF WiFi HAL status."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NRF_WIFI_HAL_STATUS {
    #[doc = " HAL is enabled"]
    NRF_WIFI_HAL_STATUS_ENABLED = 0,
    #[doc = " HAL is disabled"]
    NRF_WIFI_HAL_STATUS_DISABLED = 1,
}
#[doc = " @brief Structure to hold RPU information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_info {
    #[doc = " Host RPU HPQM information"]
    pub hpqm_info: host_rpu_hpqm_info,
    #[doc = " RX command base"]
    pub rx_cmd_base: ::core::ffi::c_uint,
    #[doc = " TX command base"]
    pub tx_cmd_base: ::core::ffi::c_uint,
}
#[doc = " @brief Structure to hold buffer mapping information for the HAL layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_buf_map_info {
    #[doc = " Flag indicating if the buffer is mapped"]
    pub mapped: bool,
    #[doc = " Virtual address of the buffer"]
    pub virt_addr: ::core::ffi::c_ulong,
    #[doc = " Physical address of the buffer"]
    pub phy_addr: ::core::ffi::c_ulong,
    #[doc = " Length of the buffer"]
    pub buf_len: ::core::ffi::c_uint,
}
#[doc = " @brief Structure to hold configuration parameters for the HAL layer\n in all modes of operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_cfg_params {
    #[doc = " Maximum command size"]
    pub max_cmd_size: ::core::ffi::c_uint,
    #[doc = " Maximum event size"]
    pub max_event_size: ::core::ffi::c_uint,
    #[doc = " RX buffer headroom size"]
    pub rx_buf_headroom_sz: ::core::ffi::c_uchar,
    #[doc = " TX buffer headroom size"]
    pub tx_buf_headroom_sz: ::core::ffi::c_uchar,
    #[doc = " RX buffer pool parameters"]
    pub rx_buf_pool: [rx_buf_pool_params; 3usize],
    #[doc = " Maximum TX frame size"]
    pub max_tx_frm_sz: ::core::ffi::c_uint,
    #[doc = " Maximum AMPDU length per token"]
    pub max_ampdu_len_per_token: ::core::ffi::c_uint,
}
#[doc = " @brief Structure to hold context information for the HAL layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_priv {
    #[doc = " Pointer to BAL private data"]
    pub bpriv: *mut nrf_wifi_bal_priv,
    #[doc = " Number of devices"]
    pub num_devs: ::core::ffi::c_uchar,
    #[doc = " Additional device callback data"]
    pub add_dev_callbk_data: *mut ::core::ffi::c_void,
    #[doc = " Add device callback function"]
    pub add_dev_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            add_dev_callbk_data: *mut ::core::ffi::c_void,
            hal_dev_ctx: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void,
    >,
    #[doc = " Remove device callback function"]
    pub rem_dev_callbk_fn: ::core::option::Option<unsafe extern "C" fn(mac_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " Initialize device callback function"]
    pub init_dev_callbk_fn:
        ::core::option::Option<unsafe extern "C" fn(mac_ctx: *mut ::core::ffi::c_void) -> nrf_wifi_status>,
    #[doc = " Deinitialize device callback function"]
    pub deinit_dev_callbk_fn: ::core::option::Option<unsafe extern "C" fn(mac_ctx: *mut ::core::ffi::c_void)>,
    #[doc = " Interrupt callback function"]
    pub intr_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            mac_ctx: *mut ::core::ffi::c_void,
            event_data: *mut ::core::ffi::c_void,
            len: ::core::ffi::c_uint,
        ) -> nrf_wifi_status,
    >,
    #[doc = " RPU recovery callback function"]
    pub rpu_recovery_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            mac_ctx: *mut ::core::ffi::c_void,
            event_data: *mut ::core::ffi::c_void,
            len: ::core::ffi::c_uint,
        ) -> nrf_wifi_status,
    >,
    pub cfg_params: nrf_wifi_hal_cfg_params,
    #[doc = " PKTRAM base address"]
    pub addr_pktram_base: ::core::ffi::c_ulong,
}
#[doc = " @brief Structure to hold per device context information for the HAL layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_hal_dev_ctx {
    #[doc = " Pointer to HAL private data"]
    pub hpriv: *mut nrf_wifi_hal_priv,
    #[doc = " MAC device context"]
    pub mac_dev_ctx: *mut ::core::ffi::c_void,
    #[doc = " BAL device context"]
    pub bal_dev_ctx: *mut ::core::ffi::c_void,
    #[doc = " Device index"]
    pub idx: ::core::ffi::c_uchar,
    pub rpu_info: nrf_wifi_hal_info,
    #[doc = " Number of commands"]
    pub num_cmds: ::core::ffi::c_uint,
    #[doc = " Command queue"]
    pub cmd_q: *mut ::core::ffi::c_void,
    #[doc = " Event queue"]
    pub event_q: *mut ::core::ffi::c_void,
    #[doc = " Current RPU processor type:\n This is only used during FW loading where we need the information\n about the processor whose core memory the code/data needs to be\n loaded into (since the FW image parser does not have the processor\n information coded into it). Necessitated due to FullMAC\n configuration where the RPU has 2 MCUs."]
    pub curr_proc: RPU_PROC_TYPE,
    #[doc = " HAL lock"]
    pub lock_hal: *mut ::core::ffi::c_void,
    #[doc = " Event tasklet"]
    pub event_tasklet: *mut ::core::ffi::c_void,
    #[doc = " RX lock"]
    pub lock_rx: *mut ::core::ffi::c_void,
    #[doc = " RX buffer information"]
    pub rx_buf_info: [*mut nrf_wifi_hal_buf_map_info; 3usize],
    #[doc = " TX buffer information"]
    pub tx_buf_info: *mut nrf_wifi_hal_buf_map_info,
    #[doc = " RPU PKTRAM base address"]
    pub addr_rpu_pktram_base: ::core::ffi::c_ulong,
    #[doc = " RPU PKTRAM base address for TX"]
    pub addr_rpu_pktram_base_tx: ::core::ffi::c_ulong,
    #[doc = " RPU PKTRAM base address for RX"]
    pub addr_rpu_pktram_base_rx: ::core::ffi::c_ulong,
    #[doc = " RPU PKTRAM base address for RX pool"]
    pub addr_rpu_pktram_base_rx_pool: [::core::ffi::c_ulong; 3usize],
    #[doc = " TX frame offset"]
    pub tx_frame_offset: ::core::ffi::c_ulong,
    #[doc = " Event data"]
    pub event_data: *mut ::core::ffi::c_char,
    #[doc = " Current event data"]
    pub event_data_curr: *mut ::core::ffi::c_char,
    #[doc = " Event data length"]
    pub event_data_len: ::core::ffi::c_uint,
    #[doc = " Pending event data"]
    pub event_data_pending: ::core::ffi::c_uint,
    #[doc = " Event resubmit flag"]
    pub event_resubmit: ::core::ffi::c_uint,
    #[doc = " HAL status"]
    pub hal_status: NRF_WIFI_HAL_STATUS,
    #[doc = " Recovery tasklet"]
    pub recovery_tasklet: *mut ::core::ffi::c_void,
    #[doc = " Recovery lock"]
    pub lock_recovery: *mut ::core::ffi::c_void,
}
#[doc = " @brief Structure to hold information about a HAL message."]
#[repr(C)]
#[derive(Debug)]
pub struct nrf_wifi_hal_msg {
    #[doc = " Length of the message"]
    pub len: ::core::ffi::c_uint,
    #[doc = " Message data"]
    pub data: __IncompleteArrayField<::core::ffi::c_char>,
}
impl nrf_wifi_op_mode {
    pub const NRF_WIFI_OP_MODE_MAX: nrf_wifi_op_mode = nrf_wifi_op_mode::NRF_WIFI_OP_MODE_OFF_RAW_TX;
}
impl nrf_wifi_op_mode {
    pub const NRF_WIFI_OP_MODE_UNKNOWN: nrf_wifi_op_mode = nrf_wifi_op_mode::__NRF_WIFI_OP_MODE_AFTER_LAST;
}
#[repr(u32)]
#[doc = " @brief Device operation modes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_op_mode {
    #[doc = " System mode."]
    NRF_WIFI_OP_MODE_SYS = 0,
    #[doc = " Radio test mode"]
    NRF_WIFI_OP_MODE_RT = 1,
    #[doc = " Offloaded raw TX mode"]
    NRF_WIFI_OP_MODE_OFF_RAW_TX = 2,
    #[doc = " @cond INTERNAL_HIDDEN"]
    __NRF_WIFI_OP_MODE_AFTER_LAST = 3,
}
#[doc = " @brief Structure to hold host specific statistics.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_host_stats {
    #[doc = " Total number of TX frames transmitted."]
    pub total_tx_pkts: ::core::ffi::c_ulonglong,
    #[doc = " Total number of TX dones received."]
    pub total_tx_done_pkts: ::core::ffi::c_ulonglong,
    #[doc = " Total number of TX frames dropped."]
    pub total_tx_drop_pkts: ::core::ffi::c_ulonglong,
    #[doc = " Total number of RX frames received."]
    pub total_rx_pkts: ::core::ffi::c_ulonglong,
    #[doc = " Total number of RX frames dropped."]
    pub total_rx_drop_pkts: ::core::ffi::c_ulonglong,
}
#[doc = " @brief Structure to hold FW patch information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fw_info {
    #[doc = " Pointer to the FW patch data."]
    pub data: *const ::core::ffi::c_void,
    #[doc = " Size of the FW patch data."]
    pub size: ::core::ffi::c_uint,
}
#[doc = " @brief Structure to hold FW patch information for LMAC and UMAC.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_fw_info {
    #[doc = " Primary LMAC FW patch information."]
    pub lmac_patch_pri: nrf_wifi_fw_info,
    #[doc = " Secondary LMAC FW patch information."]
    pub lmac_patch_sec: nrf_wifi_fw_info,
    #[doc = " Primary UMAC FW patch information."]
    pub umac_patch_pri: nrf_wifi_fw_info,
    #[doc = " Secondary UMAC FW patch information."]
    pub umac_patch_sec: nrf_wifi_fw_info,
}
#[doc = " @brief Structure to hold FW patch chunk information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_fw_chunk_info {
    #[doc = " Pointer to the FW patch chunk ID string."]
    pub id_str: [::core::ffi::c_char; 16usize],
    #[doc = " Pointer to the FW patch chunk data."]
    pub data: *const ::core::ffi::c_void,
    #[doc = " Size of the FW patch chunk data."]
    pub size: ::core::ffi::c_uint,
    #[doc = " Destination address of the FW patch chunk data."]
    pub dest_addr: ::core::ffi::c_uint,
}
#[doc = " @brief Structure to hold OTP region information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_otp_info {
    #[doc = " OTP region information."]
    pub info: host_rpu_umac_info,
    #[doc = " Flags indicating which OTP regions are valid."]
    pub flags: ::core::ffi::c_uint,
}
#[doc = " @brief Structure to hold Regulatory parameter data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_reg_info {
    #[doc = " ISO IEC Country code."]
    pub alpha2: [::core::ffi::c_uchar; 2usize],
    #[doc = " Forcefully set regulatory."]
    pub force: bool,
    #[doc = " Regulatory channels count"]
    pub reg_chan_count: ::core::ffi::c_uint,
    #[doc = " Regulatory channel attributes"]
    pub reg_chan_info: [nrf_wifi_get_reg_chn_info; 42usize],
}
#[doc = " @brief Structure to hold common fmac priv parameter data.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct nrf_wifi_fmac_priv {
    #[doc = " Handle to the HAL layer."]
    pub hpriv: *mut nrf_wifi_hal_priv,
    #[doc = " Operation mode. \\ref nrf_wifi_op_mode"]
    pub op_mode: ::core::ffi::c_int,
    #[doc = " Data pointer to mode specific parameters"]
    pub priv_: __IncompleteArrayField<::core::ffi::c_char>,
}
#[doc = " @brief Structure to hold common fmac dev context parameter data.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct nrf_wifi_fmac_dev_ctx {
    #[doc = " Handle to the FMAC IF abstraction layer."]
    pub fpriv: *mut nrf_wifi_fmac_priv,
    #[doc = " Handle to the OS abstraction layer."]
    pub os_dev_ctx: *mut ::core::ffi::c_void,
    #[doc = " Handle to the HAL layer."]
    pub hal_dev_ctx: *mut ::core::ffi::c_void,
    #[doc = " Operation mode. \\ref nrf_wifi_op_mode"]
    pub op_mode: ::core::ffi::c_int,
    #[doc = " Firmware statistics."]
    pub fw_stats: *mut ::core::ffi::c_void,
    #[doc = " Firmware statistics requested."]
    pub stats_req: bool,
    #[doc = " Firmware boot done."]
    pub fw_boot_done: bool,
    #[doc = " Firmware init done."]
    pub fw_init_done: bool,
    #[doc = " Firmware deinit done."]
    pub fw_deinit_done: bool,
    #[doc = " Alpha2 valid."]
    pub alpha2_valid: bool,
    #[doc = " Alpha2 country code, last byte is reserved for null character."]
    pub alpha2: [::core::ffi::c_uchar; 3usize],
    #[doc = " Regulatory channels count"]
    pub reg_chan_count: ::core::ffi::c_uint,
    #[doc = " Regulatory channel attributes"]
    pub reg_chan_info: *mut nrf_wifi_get_reg_chn_info,
    #[doc = " To determine if event is solicited or not"]
    pub waiting_for_reg_event: bool,
    #[doc = " Regulatory set status"]
    pub reg_set_status: ::core::ffi::c_int,
    #[doc = " Regulatory change event"]
    pub reg_change: *mut nrf_wifi_event_regulatory_change,
    #[doc = " TX power ceiling parameters"]
    pub tx_pwr_ceil_params: *mut nrf_wifi_tx_pwr_ceil_params,
    #[doc = " Data pointer to mode specific parameters"]
    pub priv_: __IncompleteArrayField<::core::ffi::c_char>,
}
#[repr(u32)]
#[doc = " @brief WLAN access categories.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fmac_ac {
    #[doc = " Background access category."]
    NRF_WIFI_FMAC_AC_BK = 0,
    #[doc = " Best-effort access category."]
    NRF_WIFI_FMAC_AC_BE = 1,
    #[doc = " Video access category."]
    NRF_WIFI_FMAC_AC_VI = 2,
    #[doc = " Voice access category."]
    NRF_WIFI_FMAC_AC_VO = 3,
    #[doc = " Multicast access category."]
    NRF_WIFI_FMAC_AC_MC = 4,
    #[doc = " Maximum number of WLAN access categories."]
    NRF_WIFI_FMAC_AC_MAX = 5,
}
#[repr(u32)]
#[doc = " @brief The operational state of an interface.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fmac_if_op_state {
    #[doc = " Interface is non-operational."]
    NRF_WIFI_FMAC_IF_OP_STATE_DOWN = 0,
    #[doc = " Interface is operational."]
    NRF_WIFI_FMAC_IF_OP_STATE_UP = 1,
    #[doc = " Invalid value. Used for error checks."]
    NRF_WIFI_FMAC_IF_OP_STATE_INVALID = 2,
}
#[repr(u32)]
#[doc = " @brief The carrier state of an interface.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fmac_if_carr_state {
    #[doc = " Interface is not ready."]
    NRF_WIFI_FMAC_IF_CARR_STATE_OFF = 0,
    #[doc = " Interface is ready."]
    NRF_WIFI_FMAC_IF_CARR_STATE_ON = 1,
    #[doc = " Invalid value. Used for error checks."]
    NRF_WIFI_FMAC_IF_CARR_STATE_INVALID = 2,
}
#[doc = " @brief Callback functions to be invoked by UMAC IF layer when a particular event occurs.\n\n This structure contains function pointers to all the callback functions that\n the UMAC IF layer needs to invoke for various events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_callbk_fns {
    #[doc = " Callback function to be called when RPU recovery is required."]
    pub rpu_recovery_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            event_data: *mut ::core::ffi::c_void,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a scan is started."]
    pub scan_start_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_start_event: *mut nrf_wifi_umac_event_trigger_scan,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a scan is done."]
    pub scan_done_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_done_event: *mut nrf_wifi_umac_event_trigger_scan,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a scan is aborted."]
    pub scan_abort_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_done_event: *mut nrf_wifi_umac_event_trigger_scan,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a scan result is received."]
    pub scan_res_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_res: *mut nrf_wifi_umac_event_new_scan_results,
            event_len: ::core::ffi::c_uint,
            more_res: bool,
        ),
    >,
    #[doc = " Callback function to be called when a display scan result is received."]
    pub disp_scan_res_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            scan_res: *mut nrf_wifi_umac_event_new_scan_display_results,
            event_len: ::core::ffi::c_uint,
            more_res: bool,
        ),
    >,
    #[doc = " Callback function to be called when a get regulatory response is received."]
    pub event_get_reg: ::core::option::Option<
        unsafe extern "C" fn(
            if_priv: *mut ::core::ffi::c_void,
            get_reg: *mut nrf_wifi_reg,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when an interface association state changes."]
    pub if_carr_state_chg_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(os_vif_ctx: *mut ::core::ffi::c_void, cs: nrf_wifi_fmac_if_carr_state) -> nrf_wifi_status,
    >,
    #[doc = " Callback function to be called when a frame is received."]
    pub rx_frm_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(os_vif_ctx: *mut ::core::ffi::c_void, frm: *mut ::core::ffi::c_void),
    >,
    #[doc = " Callback function to be called when an authentication response is received."]
    pub auth_resp_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            auth_resp_event: *mut nrf_wifi_umac_event_mlme,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when an association response is received."]
    pub assoc_resp_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            assoc_resp_event: *mut nrf_wifi_umac_event_mlme,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a deauthentication frame is received."]
    pub deauth_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            deauth_event: *mut nrf_wifi_umac_event_mlme,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a disassociation frame is received."]
    pub disassoc_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            disassoc_event: *mut nrf_wifi_umac_event_mlme,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a management frame is received."]
    pub mgmt_rx_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            mgmt_rx_event: *mut nrf_wifi_umac_event_mlme,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when an unprotected management frame is received."]
    pub unprot_mlme_mgmt_rx_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            unprot_mlme_event: *mut nrf_wifi_umac_event_mlme,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a get TX power response is received."]
    pub tx_pwr_get_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            info: *mut nrf_wifi_umac_event_get_tx_power,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a get channel response is received."]
    pub chnl_get_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            info: *mut nrf_wifi_umac_event_get_channel,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a cookie response is received."]
    pub cookie_rsp_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            cookie_rsp: *mut nrf_wifi_umac_event_cookie_rsp,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a TX status is received."]
    pub tx_status_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            tx_status_event: *mut nrf_wifi_umac_event_mlme,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a set interface response is received."]
    pub set_if_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            set_if_event: *mut nrf_wifi_umac_event_set_interface,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a remain on channel response is received."]
    pub roc_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            roc_event: *mut nrf_wifi_event_remain_on_channel,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a remain on channel cancel response is received."]
    pub roc_cancel_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            roc_cancel_event: *mut nrf_wifi_event_remain_on_channel,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a get station response is received."]
    pub get_station_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            info: *mut nrf_wifi_umac_event_new_station,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a get interface response is received."]
    pub get_interface_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            info: *mut nrf_wifi_interface_info,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a management TX status is received."]
    pub mgmt_tx_status: ::core::option::Option<
        unsafe extern "C" fn(
            if_priv: *mut ::core::ffi::c_void,
            mlme_event: *mut nrf_wifi_umac_event_mlme,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a TWT configuration response is received."]
    pub twt_config_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            if_priv: *mut ::core::ffi::c_void,
            twt_config_event_info: *mut nrf_wifi_umac_cmd_config_twt,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a TWT teardown response is received."]
    pub twt_teardown_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            if_priv: *mut ::core::ffi::c_void,
            twt_teardown_event_info: *mut nrf_wifi_umac_cmd_teardown_twt,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a get wiphy response is received."]
    pub event_get_wiphy: ::core::option::Option<
        unsafe extern "C" fn(
            if_priv: *mut ::core::ffi::c_void,
            get_wiphy: *mut nrf_wifi_event_get_wiphy,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a TWT sleep response is received."]
    pub twt_sleep_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            if_priv: *mut ::core::ffi::c_void,
            twt_sleep_event_info: *mut nrf_wifi_umac_event_twt_sleep,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a get power save information\n response is received."]
    pub event_get_ps_info: ::core::option::Option<
        unsafe extern "C" fn(
            if_priv: *mut ::core::ffi::c_void,
            get_ps_config: *mut nrf_wifi_umac_event_power_save_info,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when a get connection info response is received."]
    pub get_conn_info_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            info: *mut nrf_wifi_umac_event_conn_info,
            event_len: ::core::ffi::c_uint,
        ),
    >,
    #[doc = " Callback function to be called when rssi is to be processed from the received frame."]
    pub process_rssi_from_rx: ::core::option::Option<
        unsafe extern "C" fn(os_vif_ctx: *mut ::core::ffi::c_void, signal: ::core::ffi::c_short),
    >,
    pub reg_change_callbk_fn: ::core::option::Option<
        unsafe extern "C" fn(
            os_vif_ctx: *mut ::core::ffi::c_void,
            reg_change: *mut nrf_wifi_event_regulatory_change,
            event_len: ::core::ffi::c_uint,
        ),
    >,
}
#[repr(u32)]
#[doc = " @brief The TWT sleep state of device.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fmac_twt_state {
    #[doc = " RPU in TWT sleep state."]
    NRF_WIFI_FMAC_TWT_STATE_SLEEP = 0,
    #[doc = " RPU in TWT awake state."]
    NRF_WIFI_FMAC_TWT_STATE_AWAKE = 1,
}
#[doc = " @brief Structure to hold peer context information.\n\n This structure holds context information for a peer that the RPU is\n connected with."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct peers_info {
    #[doc = " Peer ID."]
    pub peer_id: ::core::ffi::c_int,
    #[doc = " VIF index."]
    pub if_idx: ::core::ffi::c_uchar,
    #[doc = " Power save state."]
    pub ps_state: ::core::ffi::c_uchar,
    #[doc = " Legacy or HT/VHT/HE."]
    pub is_legacy: ::core::ffi::c_uchar,
    #[doc = " QoS supported."]
    pub qos_supported: ::core::ffi::c_uchar,
    #[doc = " Pending queue bitmap."]
    pub pend_q_bmp: ::core::ffi::c_uchar,
    pub __bindgen_padding_0: [u8; 3usize],
    #[doc = " Receiver address, this is programmed to nRF70, so, should be aligned to 4."]
    pub ra_addr: [::core::ffi::c_uchar; 6usize],
    #[doc = " Pairwise cipher."]
    pub pairwise_cipher: ::core::ffi::c_uint,
    #[doc = " 802.11 power save token count."]
    pub ps_token_count: ::core::ffi::c_int,
}
#[doc = " @brief Structure to hold transmit path context information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tx_config {
    #[doc = " Lock used to make code portions in the TX path atomic."]
    pub tx_lock: *mut ::core::ffi::c_void,
    #[doc = " Context information about peers that the RPU firmware is connected to."]
    pub peers: [peers_info; 6usize],
    #[doc = " Coalesce count of TX frames."]
    pub send_pkt_coalesce_count_p: *mut ::core::ffi::c_uint,
    #[doc = " per-peer/per-AC Queue for frames waiting to be passed to the RPU firmware for TX."]
    pub data_pending_txq: [[*mut ::core::ffi::c_void; 5usize]; 6usize],
    #[doc = " Queue for peers which have woken up from 802.11 power save."]
    pub wakeup_client_q: *mut ::core::ffi::c_void,
    #[doc = " Used to store tx descs(buff pool ids)."]
    pub buf_pool_bmp_p: *mut ::core::ffi::c_ulong,
    #[doc = " TX descriptors which have been queued to the RPU firmware."]
    pub outstanding_descs: [::core::ffi::c_uint; 5usize],
    #[doc = " Peer who will be get the next opportunity for TX."]
    pub curr_peer_opp: [::core::ffi::c_uint; 5usize],
    #[doc = " Access category which will get the next spare descriptor."]
    pub next_spare_desc_ac: ::core::ffi::c_uint,
    #[doc = " Frame context information."]
    pub pkt_info_p: *mut tx_pkt_info,
    #[doc = " Map for the spare descriptor queues\n  - First four bits : Spare desc1 queue number,\n  - Second four bits: Spare desc2 queue number."]
    pub spare_desc_queue_map: ::core::ffi::c_uint,
}
#[doc = " @brief Structure to hold context information for the UMAC IF layer.\n\n This structure maintains the context information necessary for the\n operation of the UMAC IF layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sys_fmac_priv {
    #[doc = " Callback functions to be called on various events."]
    pub callbk_fns: nrf_wifi_fmac_callbk_fns,
    #[doc = " Data path configuration parameters."]
    pub data_config: nrf_wifi_data_config_params,
    #[doc = " RX buffer pool configuration data."]
    pub rx_buf_pools: [rx_buf_pool_params; 3usize],
    #[doc = " Starting RX descriptor number for a RX buffer pool."]
    pub rx_desc: [::core::ffi::c_uint; 3usize],
    #[doc = " Maximum number of host buffers needed for RX frames."]
    pub num_rx_bufs: ::core::ffi::c_uint,
    #[doc = " Maximum number of tokens available for TX."]
    pub num_tx_tokens: ::core::ffi::c_uchar,
    #[doc = " Maximum number of TX tokens available reserved per AC."]
    pub num_tx_tokens_per_ac: ::core::ffi::c_uchar,
    #[doc = " Number of spare tokens (common to all ACs) available for TX."]
    pub num_tx_tokens_spare: ::core::ffi::c_uchar,
    #[doc = " Maximum supported AMPDU length per token."]
    pub max_ampdu_len_per_token: ::core::ffi::c_uint,
    #[doc = " Available (remaining) AMPDU length per token."]
    pub avail_ampdu_len_per_token: ::core::ffi::c_uint,
}
#[doc = " @brief Structure to hold per device context information for the UMAC IF layer.\n\n This structure maintains the context information necessary for\n a single instance of a FullMAC-based RPU."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_sys_fmac_dev_ctx {
    #[doc = " Array of pointers to virtual interfaces created on this device."]
    pub vif_ctx: [*mut nrf_wifi_fmac_vif_ctx; 2usize],
    #[doc = " Host statistics."]
    pub host_stats: rpu_host_stats,
    #[doc = " Number of interfaces in STA mode."]
    pub num_sta: ::core::ffi::c_uchar,
    #[doc = " Number of interfaces in AP mode."]
    pub num_ap: ::core::ffi::c_uchar,
    #[doc = " Queue for storing mapping info of RX buffers."]
    pub rx_buf_info: *mut nrf_wifi_fmac_buf_map_info,
    #[doc = " Queue for storing mapping info of TX buffers."]
    pub tx_buf_info: *mut nrf_wifi_fmac_buf_map_info,
    #[doc = " Context information related to TX path."]
    pub tx_config: tx_config,
    #[doc = " TWT state of the RPU."]
    pub twt_sleep_status: nrf_wifi_fmac_twt_state,
}
#[doc = " @brief Structure to hold per VIF context information for the UMAC IF layer.\n\n This structure maintains the context information necessary for\n a single instance of an VIF."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_vif_ctx {
    #[doc = " Handle to the FMAC IF abstraction layer."]
    pub fmac_dev_ctx: *mut nrf_wifi_fmac_dev_ctx,
    #[doc = " Handle to the OS abstraction layer."]
    pub os_vif_ctx: *mut ::core::ffi::c_void,
    #[doc = " MAC address of the VIF."]
    pub mac_addr: [::core::ffi::c_char; 6usize],
    #[doc = " Groupwise cipher being used on this VIF."]
    pub groupwise_cipher: ::core::ffi::c_int,
    #[doc = " Interface flags related to this VIF."]
    pub ifflags: bool,
    #[doc = " Interface type of this VIF."]
    pub if_type: ::core::ffi::c_int,
    #[doc = " BSSID of the AP to which this VIF is connected (applicable only in STA mode)."]
    pub bssid: [::core::ffi::c_uchar; 6usize],
    #[doc = " Mode setting for the current VIF"]
    pub mode: ::core::ffi::c_uchar,
}
#[doc = " @brief Structure to hold TX/RX buffer pool configuration data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_buf_map_info {
    #[doc = " Flag indicating whether the buffer is mapped or not."]
    pub mapped: bool,
    #[doc = " The number of words in the buffer."]
    pub nwb: ::core::ffi::c_ulong,
}
#[doc = " @brief - Structure to hold per device host and firmware statistics.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_sys_op_stats {
    #[doc = " Host statistics."]
    pub host: rpu_host_stats,
    #[doc = " Firmware statistics."]
    pub fw: rpu_sys_fw_stats,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fmac_rx_cmd_type {
    NRF_WIFI_FMAC_RX_CMD_TYPE_INIT = 0,
    NRF_WIFI_FMAC_RX_CMD_TYPE_DEINIT = 1,
    NRF_WIFI_FMAC_RX_CMD_TYPE_MAX = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf_wifi_fmac_rx_pool_map_info {
    pub pool_id: ::core::ffi::c_uint,
    pub buf_id: ::core::ffi::c_uint,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf70_feature_flags {
    NRF70_FEAT_SYSTEM_MODE = 1,
    NRF70_FEAT_RADIO_TEST = 2,
    NRF70_FEAT_SCAN_ONLY = 4,
    NRF70_FEAT_SYSTEM_WITH_RAW_MODES = 8,
    NRF70_FEAT_OFFLOADED_RAW_TX = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf70_image_ids {
    NRF70_IMAGE_UMAC_PRI = 0,
    NRF70_IMAGE_UMAC_SEC = 1,
    NRF70_IMAGE_LMAC_PRI = 2,
    NRF70_IMAGE_LMAC_SEC = 3,
}
#[repr(C, packed)]
pub struct nrf70_fw_image {
    pub type_: ::core::ffi::c_uint,
    pub len: ::core::ffi::c_uint,
    pub data: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(C, packed)]
pub struct nrf70_fw_image_info {
    pub signature: ::core::ffi::c_uint,
    pub num_images: ::core::ffi::c_uint,
    pub version: ::core::ffi::c_uint,
    pub feature_flags: ::core::ffi::c_uint,
    pub len: ::core::ffi::c_uint,
    pub hash: [::core::ffi::c_uchar; 32usize],
    pub data: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(u32)]
#[doc = " Enum defining the types of RPU memory."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HAL_RPU_MEM_TYPE {
    #[doc = " GRAM memory type"]
    HAL_RPU_MEM_TYPE_GRAM = 0,
    #[doc = " PKTRAM memory type"]
    HAL_RPU_MEM_TYPE_PKTRAM = 1,
    #[doc = " Core ROM memory type"]
    HAL_RPU_MEM_TYPE_CORE_ROM = 2,
    #[doc = " Core RET memory type"]
    HAL_RPU_MEM_TYPE_CORE_RET = 3,
    #[doc = " Core SCRATCH memory type"]
    HAL_RPU_MEM_TYPE_CORE_SCRATCH = 4,
    #[doc = " Maximum number of memory types"]
    HAL_RPU_MEM_TYPE_MAX = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fw_patch_type {
    NRF_WIFI_FW_PATCH_TYPE_PRI = 0,
    NRF_WIFI_FW_PATCH_TYPE_SEC = 1,
    NRF_WIFI_FW_PATCH_TYPE_MAX = 2,
}
#[doc = " @brief Structure containing information about the firmware address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nrf70_fw_addr_info {
    #[doc = " RPU process type."]
    pub rpu_proc: RPU_PROC_TYPE,
    #[doc = " Name of the address register."]
    pub name: [::core::ffi::c_char; 16usize],
    #[doc = " Destination address."]
    pub dest_addr: ::core::ffi::c_uint,
}
unsafe extern "C" {
    pub static nrf70_fw_addr_info: [nrf70_fw_addr_info; 0usize];
}
unsafe extern "C" {
    pub static SOC_MMAP_ADDR_OFFSETS_MCU: [::core::ffi::c_uint; 2usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fw_type {
    NRF_WIFI_FW_TYPE_LMAC_PATCH = 0,
    NRF_WIFI_FW_TYPE_UMAC_PATCH = 1,
    NRF_WIFI_FW_TYPE_MAX = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum nrf_wifi_fw_subtype {
    NRF_WIFI_FW_SUBTYPE_PRI = 0,
    NRF_WIFI_FW_SUBTYPE_SEC = 1,
    NRF_WIFI_FW_SUBTYPE_MAX = 2,
}
#[doc = " Frame context information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tx_pkt_info {
    pub _address: u8,
}
